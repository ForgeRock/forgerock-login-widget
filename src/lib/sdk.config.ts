import { CallbackType, Config, FRCallback } from '@forgerock/javascript-sdk';
import { z } from 'zod';

/**
 * Configure underlying SDK
 */
const configSchema = z
  .object({
    callbackFactory: z
      .function()
      .args(
        z.object({
          _id: z.number().optional(),
          input: z
            .array(
              z.object({
                name: z.string(),
                value: z.unknown(),
              }),
            )
            .optional(),
          output: z.array(
            z.object({
              name: z.string(),
              value: z.unknown(),
            }),
          ),
          type: z.nativeEnum(CallbackType),
        }),
      )
      .returns(z.instanceof(FRCallback))
      .optional(),
    clientId: z.string().optional(),
    logLevel: z
      .union([
        z.literal('none'),
        z.literal('error'),
        z.literal('warn'),
        z.literal('info'),
        z.literal('debug'),
      ])
      .optional(),
    middleware: z.array(z.function()).optional(),
    realmPath: z.string(),
    redirectUri: z.string().optional(),
    scope: z.string().optional(),
    serverConfig: z
      .object({
        baseUrl: z
          .string({
            invalid_type_error:
              '`serverConfig.baseUrl` is a required URL string (this is generated by the Zod library).',
            required_error:
              'Setting the `serverConfig.baseUrl` is required (this is generated by the Zod library).',
          })
          .url({
            message:
              '`serverConfig.baseUrl` must be a full URL (this is generated by the Zod library).',
          }),
        paths: z
          .object({
            authenticate: z.string().optional(),
            authorize: z.string().optional(),
            accessToken: z.string().optional(),
            endSession: z.string().optional(),
            userInfo: z.string().optional(),
            revoke: z.string().optional(),
            sessions: z.string().optional(),
          })
          .strict()
          .optional(),
        timeout: z
          .number({
            invalid_type_error:
              '`serverConfig.timeout` is a required number and in milliseconds (this is generated by the Zod library).',
          })
          .optional(),
      })
      .strict(),
    support: z.union([z.literal('legacy'), z.literal('modern')]).optional(),
    tokenStore: z
      .union([
        z
          .object({
            get: z
              .function()
              .args(z.string())
              .returns(
                z.promise(
                  z.object({
                    accessToken: z.string(),
                    idToken: z.string().optional(),
                    refreshToken: z.string().optional(),
                    tokenExpiry: z.number().optional(),
                  }),
                ),
              ),
            set: z.function().args(z.string()).returns(z.promise(z.void())),
            remove: z.function().args(z.string()).returns(z.promise(z.void())),
          })
          .strict(),
        z.literal('sessionStorage'),
        z.literal('localStorage'),
      ])
      .optional(),
    tree: z.string().optional(),
    type: z.string().optional(),
    oauthThreshold: z.number().optional(),
  })
  .strict();
export const partialConfigSchema = configSchema.partial();

/**
 * @function - Sets the configuration for the SDK
 * @param {object} config - The configuration object
 * @returns {void}
 */
export default function (config: z.infer<typeof partialConfigSchema>) {
  configSchema.parse(config);
  Config.set(config);
}
