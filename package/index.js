/**
 * @forgerock/login-widget
 *
 * Copyright (c) 2024 ForgeRock. All rights reserved.
 * This software may be modified and distributed under the terms
 * of the MIT license.
 *
 * MIT License
 *
 * Copyright (c) 2024
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
        e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
            if (k !== 'default' && !(k in n)) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    });
    return Object.freeze(n);
}

function noop() { }
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function to_number(value) {
    return value === '' ? null : +value;
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
class HtmlTag {
    constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            if (this.is_svg)
                this.e = svg_element(target.nodeName);
            else
                this.e = element(target.nodeName);
            this.t = target;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}
function construct_svelte_component(component, props) {
    return new component(props);
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs#run-time-svelte-onmount
 */
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 */
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    // Do not reenter flush while dirty components are updated, as this can
    // result in an infinite loop. Instead, let the inner flush handle it.
    // Reentrancy is ok afterwards for bindings etc.
    if (flushidx !== 0) {
        return;
    }
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        try {
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
        }
        catch (e) {
            // reset dirty state to not end up in a deadlocked state and then rethrow
            dirty_components.length = 0;
            flushidx = 0;
            throw e;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
    else if (callback) {
        callback();
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
            // if the component was destroyed immediately
            // it will update the `$$.on_destroy` reference to `null`.
            // the destructured on_destroy may still reference to the old array
            if (component.$$.on_destroy) {
                component.$$.on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        if (!is_function(callback)) {
            return noop;
        }
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = is_function(result) ? result : noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (inited) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        inited = true;
        sync();
        return function stop() {
            run_all(unsubscribers);
            cleanup();
        };
    });
}

const componentStore = writable({
    lastAction: null,
    error: null,
    form: null,
    modal: null,
    mounted: false,
    open: null,
    reason: null,
    type: null,
});
/**
 * @function closeComponent - this is a widget internal function not to be exposed to user
 * @param {object} args - object containing  the reason for closing component
 * @param {boolean} shouldCloseDialog - if true, the close command comes from outside of dialog component
 */
function closeComponent(args, shouldCloseDialog) {
    componentStore.update((state) => {
        if (state.type === 'inline') {
            console.warn('Component type of "inline" has no `close` method');
            // There's nothing to do, so just return existing state
            return state;
        }
        if (!state.modal?.component) {
            console.warn('Modal component is not mounted. Please instantiate the Widget before use.');
            // There's nothing to do, so just return existing state
            return state;
        }
        shouldCloseDialog && state.modal.component.closeDialog();
        return {
            ...state,
            lastAction: 'close',
            open: false,
            reason: args?.reason || null,
        };
    });
}
/**
 * @function componentApi - this is a widget external API
 * @returns {object} - the public component API
 */
const componentApi = () => {
    const { update } = componentStore;
    // Create derived store to minimize what's exposed to the dev
    const { subscribe, } = derived([componentStore], ([$componentStore], set) => {
        set({
            error: $componentStore.error,
            lastAction: $componentStore.lastAction,
            mounted: $componentStore.mounted,
            open: $componentStore.open,
            reason: $componentStore.reason,
        });
    });
    return {
        /**
         * Close a modal
         * @param {object} args - object containing  the reason for closing component
         * @returns {void}
         */
        close: (args) => {
            closeComponent(args, true);
        },
        /**
         * Open a modal
         * @param: void
         * @returns: void
         */
        open: () => {
            update((state) => {
                if (state.type === 'inline') {
                    console.warn('Component type of "inline" has no `open` method');
                    // There's nothing to do, so just return existing state
                    return state;
                }
                if (!state.modal?.component) {
                    console.warn('Modal component is not mounted. Please instantiate the Widget before use.');
                    // There's nothing to do, so just return existing state
                    return state;
                }
                state.modal.element.showModal();
                return {
                    ...state,
                    lastAction: 'open',
                    open: true,
                    reason: null,
                };
            });
        },
        /**
         * Subscribe to modal events
         * returns the latest value from the event
         */
        subscribe,
    };
};
/**
 * @function mount - this is a widget internal function not to be exposed to user
 * @param {object} component - actual Svelte component representing the dialog
 * @param {object} element - actual DOM element representing the dialog
 */
function mount(component, element) {
    componentStore.update((state) => {
        return {
            ...state,
            lastAction: 'mount',
            modal: {
                ...(component && { component, element }),
            },
            mounted: true,
            type: component ? 'modal' : 'inline',
            reason: null,
        };
    });
}

const T$4 = 5e3, E$3 = 3e4, o$5 = "FR-SDK";

function f$4(t, { type: a, payload: o }) {
  const i = Object.freeze({ type: a, payload: o });
  return (e) => {
    if (!Array.isArray(e))
      return t;
    const c = e.map((r) => r);
    function n() {
      const r = c.shift();
      return r && r(t, i, n), t;
    }
    return n();
  };
}

function T$3(t, o = T$4) {
  const i = o || T$4, r = new Promise(
    (n, m) => setTimeout(() => m(new Error("Timeout")), i)
  );
  return Promise.race([t, r]);
}

var e$2 = /* @__PURE__ */ ((E) => (E.Authenticate = "AUTHENTICATE", E.Authorize = "AUTHORIZE", E.EndSession = "END_SESSION", E.Logout = "LOGOUT", E.ExchangeToken = "EXCHANGE_TOKEN", E.RefreshToken = "REFRESH_TOKEN", E.ResumeAuthenticate = "RESUME_AUTHENTICATE", E.RevokeToken = "REVOKE_TOKEN", E.StartAuthenticate = "START_AUTHENTICATE", E.UserInfo = "USER_INFO", E.WellKnown = "WELL_KNOWN", E))(e$2 || {});

function d$3(e, n) {
  var o, l;
  if (!e.authorization_endpoint)
    throw new Error("Wellknown endpoint did not return `authorization_endpoint`");
  const s = new URL(e.authorization_endpoint).origin;
  let t, r;
  n != null && n.paths ? (t = (o = n == null ? void 0 : n.paths) == null ? void 0 : o.authenticate, r = (l = n == null ? void 0 : n.paths) == null ? void 0 : l.sessions) : e.issuer.includes("/am/") ? (t = `${e.issuer.replace("oauth2", "json")}/authenticate`, r = `${e.issuer.replace("oauth2", "json")}/sessions`) : e.issuer.includes("/as/");
  const a = {
    ...t ? { authenticate: new URL(t).pathname } : {},
    authorize: new URL(e.authorization_endpoint).pathname,
    accessToken: new URL(e.token_endpoint).pathname,
    endSession: new URL(e.end_session_endpoint).pathname,
    userInfo: new URL(e.userinfo_endpoint).pathname,
    revoke: new URL(e.revocation_endpoint).pathname,
    ...r ? { sessions: new URL(r).pathname } : {}
  };
  return {
    baseUrl: s,
    paths: a
  };
}
async function p$4(e) {
  var r;
  if (!e.serverConfig.wellknown)
    throw new Error("wellknown URL is missing in options");
  const i = f$4(
    {
      url: new URL((r = e.serverConfig) == null ? void 0 : r.wellknown),
      init: { method: "GET" }
    },
    {
      type: e$2.WellKnown,
      payload: {}
    }
  )(e.middleware);
  return await (await T$3(fetch(i.url.toString(), i.init), e.serverConfig.timeout)).json();
}

function w$1(n) {
  return {
    ...n,
    oauthThreshold: n.oauthThreshold || E$3,
    logLevel: n.logLevel || "none",
    platformHeader: n.platformHeader || !1,
    prefix: n.prefix || o$5
  };
}
let c$3 = class c {
  /**
   * Sets the default options.
   *
   * @param options The options to use as defaults
   */
  static set(e) {
    if (!this.isValid(e))
      throw new Error("Configuration is invalid");
    e.serverConfig && this.validateServerConfig(e.serverConfig), this.options = { ...w$1(e) };
  }
  /**
   * @method setAsync - Asynchronously calls the WellKnown endpoint to collect the APIs for OAuth
   * @param {AsyncConfigOptions} options - config options with wellknown endpoint URL
   * @returns {Promise<void>} - Returns a success or failure message object
   */
  static async setAsync(e) {
    if (!e.serverConfig.wellknown)
      throw new Error(
        "Missing well-known property. Use `Config.set` method if not using well-known endpoint."
      );
    e.serverConfig.baseUrl && console.warn(
      "The baseUrl property passed in will be ignored, and replaced with well-known origin."
    );
    const r = await p$4(e), i = d$3(r);
    delete e.serverConfig.wellknown;
    const t = e;
    t.serverConfig = i, this.set(t);
  }
  /**
   * Merges the provided options with the default options.  Ensures a server configuration exists.
   *
   * @param options The options to merge with defaults
   */
  static get(e) {
    if (!this.options && !e)
      throw new Error("Configuration has not been set");
    const r = { ...this.options, ...e };
    if (!r.serverConfig || !r.serverConfig.baseUrl)
      throw new Error("Server configuration has not been set");
    return r;
  }
  static isValid(e) {
    return !!(e && e.serverConfig);
  }
  static validateServerConfig(e) {
    e.timeout || (e.timeout = T$4);
    const r = e.baseUrl;
    r && r.charAt(r.length - 1) !== "/" && (e.baseUrl = r + "/");
  }
};

const E$2 = "forgerock-sdk", o$4 = "javascript";

function n$3(o) {
  const r = (o || "").split("/").map((t) => t.trim()).filter((t) => t !== "");
  return r[0] !== "root" && r.unshift("root"), r.map((t) => `realms/${t}`).join("/");
}

function r$b(t) {
  const o = t.protocol === "http:" && ["", "80"].indexOf(t.port) === -1 || t.protocol === "https:" && ["", "443"].indexOf(t.port) === -1 ? `:${t.port}` : "";
  return `${t.protocol}//${t.hostname}${o}`;
}
function h$1(t, e, o) {
  const n = n$3(e), s = {
    authenticate: `json/${n}/authenticate`,
    authorize: `oauth2/${n}/authorize`,
    accessToken: `oauth2/${n}/access_token`,
    endSession: `oauth2/${n}/connect/endSession`,
    userInfo: `oauth2/${n}/userinfo`,
    revoke: `oauth2/${n}/token/revoke`,
    sessions: `json/${n}/sessions/`
  };
  return o && o[t] ? o[t] : s[t];
}
function f$3(t, e) {
  const o = new URL(t);
  if (e.startsWith("/"))
    return `${r$b(o)}${e}`;
  const n = o.pathname.split("/"), s = e.split("/").filter((i) => !!i), a = [...n.slice(0, -1), ...s].join("/");
  return `${r$b(o)}${a}`;
}
function p$3(t) {
  const e = new URL(t), o = {};
  return e.searchParams.forEach((n, s) => o[s] = n), o;
}
function $$1(t) {
  const e = [];
  for (const o in t)
    t[o] && e.push(o + "=" + encodeURIComponent(t[o]));
  return e.join("&");
}

let J$1 = class J {
  /**
   * Gets the next step in the authentication tree.
   *
   * @param {Step} previousStep The previous step, including any required input.
   * @param {StepOptions} options Configuration default overrides.
   * @return {Step} The next step in the authentication tree.
   */
  static async next(t, e) {
    const { middleware: r, platformHeader: n, realmPath: u, serverConfig: i, tree: o, type: a } = c$3.get(e), d = e ? e.query : {}, p = this.constructUrl(i, u, o, d), s = f$4(
      {
        url: new URL(p),
        init: this.configureRequest(t)
      },
      {
        type: t ? e$2.Authenticate : e$2.StartAuthenticate,
        payload: {
          tree: o,
          type: a || "service"
        }
      }
    )(r);
    n && (s.init.headers instanceof Headers ? s.init.headers.set("X-Requested-Platform", o$4) : Array.isArray(s.init.headers) ? s.init.headers.push(["X-Requested-Platform", o$4]) : s.init.headers ? s.init.headers["X-Requested-Platform"] = o$4 : s.init.headers = {
      "X-Requested-Platform": o$4
    });
    const h = await T$3(fetch(s.url.toString(), s.init), i.timeout);
    return await this.getResponseJson(h);
  }
  static constructUrl(t, e, r, n) {
    const i = { ...n, ...r ? { authIndexType: "service", authIndexValue: r } : void 0 }, o = Object.keys(i).length > 0 ? `?${$$1(i)}` : "", a = h$1("authenticate", e, t.paths);
    return f$3(t.baseUrl, `${a}${o}`);
  }
  static configureRequest(t) {
    return {
      body: t ? JSON.stringify(t) : void 0,
      credentials: "include",
      headers: new Headers({
        Accept: "application/json",
        "Accept-API-Version": "protocol=1.0,resource=2.1",
        "Content-Type": "application/json",
        "X-Requested-With": E$2
      }),
      method: "POST"
    };
  }
  static async getResponseJson(t) {
    const e = t.headers.get("content-type"), n = e && e.indexOf("application/json") > -1 ? await t.json() : {};
    return n.status = t.status, n.ok = t.ok, n;
  }
};

var l = /* @__PURE__ */ ((a) => (a.BooleanAttributeInputCallback = "BooleanAttributeInputCallback", a.ChoiceCallback = "ChoiceCallback", a.ConfirmationCallback = "ConfirmationCallback", a.DeviceProfileCallback = "DeviceProfileCallback", a.HiddenValueCallback = "HiddenValueCallback", a.KbaCreateCallback = "KbaCreateCallback", a.MetadataCallback = "MetadataCallback", a.NameCallback = "NameCallback", a.NumberAttributeInputCallback = "NumberAttributeInputCallback", a.PasswordCallback = "PasswordCallback", a.PingOneProtectEvaluationCallback = "PingOneProtectEvaluationCallback", a.PingOneProtectInitializeCallback = "PingOneProtectInitializeCallback", a.PollingWaitCallback = "PollingWaitCallback", a.ReCaptchaCallback = "ReCaptchaCallback", a.RedirectCallback = "RedirectCallback", a.SelectIdPCallback = "SelectIdPCallback", a.StringAttributeInputCallback = "StringAttributeInputCallback", a.SuspendedTextOutputCallback = "SuspendedTextOutputCallback", a.TermsAndConditionsCallback = "TermsAndConditionsCallback", a.TextInputCallback = "TextInputCallback", a.TextOutputCallback = "TextOutputCallback", a.ValidatedCreatePasswordCallback = "ValidatedCreatePasswordCallback", a.ValidatedCreateUsernameCallback = "ValidatedCreateUsernameCallback", a))(l || {});

var _$4 = /* @__PURE__ */ ((A) => (A.CannotContainCharacters = "CANNOT_CONTAIN_CHARACTERS", A.CannotContainDuplicates = "CANNOT_CONTAIN_DUPLICATES", A.CannotContainOthers = "CANNOT_CONTAIN_OTHERS", A.LeastCapitalLetters = "AT_LEAST_X_CAPITAL_LETTERS", A.LeastNumbers = "AT_LEAST_X_NUMBERS", A.MatchRegexp = "MATCH_REGEXP", A.MaximumLength = "MAX_LENGTH", A.MaximumNumber = "MAXIMUM_NUMBER_VALUE", A.MinimumLength = "MIN_LENGTH", A.MinimumNumber = "MINIMUM_NUMBER_VALUE", A.Required = "REQUIRED", A.Unique = "UNIQUE", A.UnknownPolicy = "UNKNOWN_POLICY", A.ValidArrayItems = "VALID_ARRAY_ITEMS", A.ValidDate = "VALID_DATE", A.ValidEmailAddress = "VALID_EMAIL_ADDRESS_FORMAT", A.ValidNameFormat = "VALID_NAME_FORMAT", A.ValidNumber = "VALID_NUMBER", A.ValidPhoneFormat = "VALID_PHONE_FORMAT", A.ValidQueryFilter = "VALID_QUERY_FILTER", A.ValidType = "VALID_TYPE", A))(_$4 || {});

function f$2(o, r, n) {
  return o === 1 ? r : n !== void 0 ? n : r + "s";
}

function n$2(r, t, e) {
  return !r || r[t] === void 0 ? e : r[t];
}

const u$3 = {
  [_$4.CannotContainCharacters]: (a, n) => {
    const t = n$2(n, "forbiddenChars", "");
    return `${a} must not contain following characters: "${t}"`;
  },
  [_$4.CannotContainDuplicates]: (a, n) => {
    const t = n$2(n, "duplicateValue", "");
    return `${a}  must not contain duplicates: "${t}"`;
  },
  [_$4.CannotContainOthers]: (a, n) => {
    const t = n$2(n, "disallowedFields", "");
    return `${a} must not contain: "${t}"`;
  },
  [_$4.LeastCapitalLetters]: (a, n) => {
    const t = n$2(n, "numCaps", 0);
    return `${a} must contain at least ${t} capital ${f$2(t, "letter")}`;
  },
  [_$4.LeastNumbers]: (a, n) => {
    const t = n$2(n, "numNums", 0);
    return `${a} must contain at least ${t} numeric ${f$2(t, "value")}`;
  },
  [_$4.MatchRegexp]: (a) => `${a} has failed the "MATCH_REGEXP" policy`,
  [_$4.MaximumLength]: (a, n) => {
    const t = n$2(n, "maxLength", 0);
    return `${a} must be at most ${t} ${f$2(t, "character")}`;
  },
  [_$4.MaximumNumber]: (a) => `${a} has failed the "MAXIMUM_NUMBER_VALUE" policy`,
  [_$4.MinimumLength]: (a, n) => {
    const t = n$2(n, "minLength", 0);
    return `${a} must be at least ${t} ${f$2(t, "character")}`;
  },
  [_$4.MinimumNumber]: (a) => `${a} has failed the "MINIMUM_NUMBER_VALUE" policy`,
  [_$4.Required]: (a) => `${a} is required`,
  [_$4.Unique]: (a) => `${a} must be unique`,
  [_$4.UnknownPolicy]: (a, n) => {
    const t = n$2(n, "policyRequirement", "Unknown");
    return `${a}: Unknown policy requirement "${t}"`;
  },
  [_$4.ValidArrayItems]: (a) => `${a} has failed the "VALID_ARRAY_ITEMS" policy`,
  [_$4.ValidDate]: (a) => `${a} has an invalid date`,
  [_$4.ValidEmailAddress]: (a) => `${a} has an invalid email address`,
  [_$4.ValidNameFormat]: (a) => `${a} has an invalid name format`,
  [_$4.ValidNumber]: (a) => `${a} has an invalid number`,
  [_$4.ValidPhoneFormat]: (a) => `${a} has an invalid phone number`,
  [_$4.ValidQueryFilter]: (a) => `${a} has failed the "VALID_QUERY_FILTER" policy`,
  [_$4.ValidType]: (a) => `${a} has failed the "VALID_TYPE" policy`
};

let y$1 = class y {
  /**
   * Parses policy errors and generates human readable error messages.
   *
   * @param {Step} err The step containing the error.
   * @param {MessageCreator} messageCreator
   * Extensible and overridable custom error messages for policy failures.
   * @return {ProcessedPropertyError[]} Array of objects containing all processed policy errors.
   */
  static parseErrors(e, r) {
    const s = [];
    return e.detail && e.detail.failedPolicyRequirements && e.detail.failedPolicyRequirements.map((t) => {
      s.push.apply(s, [
        {
          detail: t,
          messages: this.parseFailedPolicyRequirement(t, r)
        }
      ]);
    }), s;
  }
  /**
   * Parses a failed policy and returns a string array of error messages.
   *
   * @param {FailedPolicyRequirement} failedPolicy The detail data of the failed policy.
   * @param {MessageCreator} customMessage
   * Extensible and overridable custom error messages for policy failures.
   * @return {string[]} Array of strings with all processed policy errors.
   */
  static parseFailedPolicyRequirement(e, r) {
    const s = [];
    return e.policyRequirements.map((t) => {
      s.push(
        this.parsePolicyRequirement(e.property, t, r)
      );
    }), s;
  }
  /**
   * Parses a policy error into a human readable error message.
   *
   * @param {string} property The property with the policy failure.
   * @param {PolicyRequirement} policy The policy failure data.
   * @param {MessageCreator} customMessage
   * Extensible and overridable custom error messages for policy failures.
   * @return {string} Human readable error message.
   */
  static parsePolicyRequirement(e, r, s = {}) {
    const t = typeof r == "string" ? JSON.parse(r) : { ...r }, a = t.policyRequirement, o = s[a] || u$3[a] || u$3[_$4.UnknownPolicy], c = t.params ? { ...t.params, policyRequirement: a } : { policyRequirement: a };
    return o(e, c);
  }
};

var r$a = /* @__PURE__ */ ((i) => (i.LoginFailure = "LoginFailure", i.LoginSuccess = "LoginSuccess", i.Step = "Step", i))(r$a || {});

let i$9 = class i {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(e) {
    this.payload = e, this.type = r$a.LoginFailure;
  }
  /**
   * Gets the error code.
   */
  getCode() {
    return Number(this.payload.code);
  }
  /**
   * Gets the failure details.
   */
  getDetail() {
    return this.payload.detail;
  }
  /**
   * Gets the failure message.
   */
  getMessage() {
    return this.payload.message;
  }
  /**
   * Gets processed failure message.
   */
  getProcessedMessage(e) {
    return y$1.parseErrors(this.payload, e);
  }
  /**
   * Gets the failure reason.
   */
  getReason() {
    return this.payload.reason;
  }
};

let r$9 = class r {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(e) {
    this.payload = e, this.type = r$a.LoginSuccess;
  }
  /**
   * Gets the step's realm.
   */
  getRealm() {
    return this.payload.realm;
  }
  /**
   * Gets the step's session token.
   */
  getSessionToken() {
    return this.payload.tokenId;
  }
  /**
   * Gets the step's success URL.
   */
  getSuccessUrl() {
    return this.payload.successUrl;
  }
};

let r$8 = class r {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(e) {
    this.payload = e;
  }
  /**
   * Gets the name of this callback type.
   */
  getType() {
    return this.payload.type;
  }
  /**
   * Gets the value of the specified input element, or the first element if `selector` is not
   * provided.
   *
   * @param selector The index position or name of the desired element
   */
  getInputValue(e = 0) {
    return this.getArrayElement(this.payload.input, e).value;
  }
  /**
   * Sets the value of the specified input element, or the first element if `selector` is not
   * provided.
   *
   * @param selector The index position or name of the desired element
   */
  setInputValue(e, t = 0) {
    this.getArrayElement(this.payload.input, t).value = e;
  }
  /**
   * Gets the value of the specified output element, or the first element if `selector`
   * is not provided.
   *
   * @param selector The index position or name of the desired element
   */
  getOutputValue(e = 0) {
    return this.getArrayElement(this.payload.output, e).value;
  }
  /**
   * Gets the value of the first output element with the specified name or the
   * specified default value.
   *
   * @param name The name of the desired element
   */
  getOutputByName(e, t) {
    const n = this.payload.output.find((a) => a.name === e);
    return n ? n.value : t;
  }
  getArrayElement(e, t = 0) {
    if (e === void 0)
      throw new Error(`No NameValue array was provided to search (selector ${t})`);
    if (typeof t == "number") {
      if (t < 0 || t > e.length - 1)
        throw new Error(`Selector index ${t} is out of range`);
      return e[t];
    }
    if (typeof t == "string") {
      const n = e.find((a) => a.name === t);
      if (!n)
        throw new Error(`Missing callback input entry "${t}"`);
      return n;
    }
    if (typeof t == "object" && t.test && t.exec) {
      const n = e.find((a) => t.test(a.name));
      if (!n)
        throw new Error(`Missing callback input entry "${t}"`);
      return n;
    }
    throw new Error("Invalid selector value type");
  }
};

let s$4 = class s extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(e) {
    super(e), this.payload = e;
  }
  /**
   * Gets the attribute name.
   */
  getName() {
    return this.getOutputByName("name", "");
  }
  /**
   * Gets the attribute prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Gets whether the attribute is required.
   */
  isRequired() {
    return this.getOutputByName("required", !1);
  }
  /**
   * Gets the callback's failed policies.
   */
  getFailedPolicies() {
    const e = this.getOutputByName(
      "failedPolicies",
      []
    );
    try {
      return e.map((t) => JSON.parse(t));
    } catch {
      throw new Error(
        'Unable to parse "failed policies" from the ForgeRock server. The JSON within `AttributeInputCallback` was either malformed or missing.'
      );
    }
  }
  /**
   * Gets the callback's applicable policies.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getPolicies() {
    return this.getOutputByName("policies", {});
  }
  /**
   * Set if validating value only.
   */
  setValidateOnly(e) {
    this.setInputValue(e, /validateOnly/);
  }
  /**
   * Sets the attribute's value.
   */
  setValue(e) {
    this.setInputValue(e);
  }
};

class h extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the choice's prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Gets the choice's default answer.
   */
  getDefaultChoice() {
    return this.getOutputByName("defaultChoice", 0);
  }
  /**
   * Gets the choice's possible answers.
   */
  getChoices() {
    return this.getOutputByName("choices", []);
  }
  /**
   * Sets the choice's answer by index position.
   */
  setChoiceIndex(t) {
    const e = this.getChoices().length;
    if (t < 0 || t > e - 1)
      throw new Error(`${t} is out of bounds`);
    this.setInputValue(t);
  }
  /**
   * Sets the choice's answer by value.
   */
  setChoiceValue(t) {
    const e = this.getChoices().indexOf(t);
    if (e === -1)
      throw new Error(`"${t}" is not a valid choice`);
    this.setInputValue(e);
  }
}

let i$8 = class i extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the index position of the confirmation's default answer.
   */
  getDefaultOption() {
    return Number(this.getOutputByName("defaultOption", 0));
  }
  /**
   * Gets the confirmation's message type.
   */
  getMessageType() {
    return Number(this.getOutputByName("messageType", 0));
  }
  /**
   * Gets the confirmation's possible answers.
   */
  getOptions() {
    return this.getOutputByName("options", []);
  }
  /**
   * Gets the confirmation's option type.
   */
  getOptionType() {
    return Number(this.getOutputByName("optionType", 0));
  }
  /**
   * Gets the confirmation's prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Set option index.
   */
  setOptionIndex(t) {
    if (t !== 0 && t !== 1)
      throw new Error(`"${t}" is not a valid choice`);
    this.setInputValue(t);
  }
  /**
   * Set option value.
   */
  setOptionValue(t) {
    const e = this.getOptions().indexOf(t);
    if (e === -1)
      throw new Error(`"${t}" is not a valid choice`);
    this.setInputValue(e);
  }
};

let i$7 = class i extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(e) {
    super(e), this.payload = e;
  }
  /**
   * Gets the callback's data.
   */
  getMessage() {
    return this.getOutputByName("message", "");
  }
  /**
   * Does callback require metadata?
   */
  isMetadataRequired() {
    return this.getOutputByName("metadata", !1);
  }
  /**
   * Does callback require location data?
   */
  isLocationRequired() {
    return this.getOutputByName("location", !1);
  }
  /**
   * Sets the profile.
   */
  setProfile(e) {
    this.setInputValue(JSON.stringify(e));
  }
};

let t$2 = class t extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(a) {
    super(a), this.payload = a;
  }
};

let u$2 = class u extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the callback prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Gets the callback's list of pre-defined security questions.
   */
  getPredefinedQuestions() {
    return this.getOutputByName("predefinedQuestions", []);
  }
  /**
   * Sets the callback's security question.
   */
  setQuestion(t) {
    this.setValue("question", t);
  }
  /**
   * Sets the callback's security question answer.
   */
  setAnswer(t) {
    this.setValue("answer", t);
  }
  setValue(t, s) {
    if (!this.payload.input)
      throw new Error("KBA payload is missing input");
    const e = this.payload.input.find((i) => i.name.endsWith(t));
    if (!e)
      throw new Error(`No input has name ending in "${t}"`);
    e.value = s;
  }
};

let s$3 = class s extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the callback's data.
   */
  getData() {
    return this.getOutputByName("data", {});
  }
};

let r$7 = class r extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the callback's prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Sets the username.
   */
  setName(t) {
    this.setInputValue(t);
  }
};

let r$6 = class r extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the callback's failed policies.
   */
  getFailedPolicies() {
    return this.getOutputByName("failedPolicies", []);
  }
  /**
   * Gets the callback's applicable policies.
   */
  getPolicies() {
    return this.getOutputByName("policies", []);
  }
  /**
   * Gets the callback's prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Sets the password.
   */
  setPassword(t) {
    this.setInputValue(t);
  }
};

let r$5 = class r extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the callback's pauseBehavioralData value.
   * @returns {boolean}
   */
  getPauseBehavioralData() {
    return this.getOutputByName("pauseBehavioralData", !1);
  }
  /**
   * @method setData - Set the result of data collection
   * @param {string} data - Data from calling pingProtect.get()
   * @returns {void}
   */
  setData(t) {
    this.setInputValue(t, /signals/);
  }
  /**
   * @method setClientError - Set the client error message
   * @param {string} errorMessage - Error message
   * @returns {void}
   */
  setClientError(t) {
    this.setInputValue(t, /clientError/);
  }
};

let i$6 = class i extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Get callback's initialization config settings
   */
  getConfig() {
    return {
      envId: this.getOutputByName("envId", ""),
      consoleLogEnabled: this.getOutputByName("consoleLogEnabled", !1),
      deviceAttributesToIgnore: this.getOutputByName("deviceAttributesToIgnore", []),
      customHost: this.getOutputByName("customHost", ""),
      lazyMetadata: this.getOutputByName("lazyMetadata", !1),
      behavioralDataCollection: this.getOutputByName("behavioralDataCollection", !0),
      deviceKeyRsyncIntervals: this.getOutputByName("deviceKeyRsyncIntervals", 14),
      enableTrust: this.getOutputByName("enableTrust", !1),
      disableTags: this.getOutputByName("disableTags", !1),
      disableHub: this.getOutputByName("disableHub", !1)
    };
  }
  setClientError(t) {
    this.setInputValue(t, /clientError/);
  }
};

let r$4 = class r extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the message to display while polling.
   */
  getMessage() {
    return this.getOutputByName("message", "");
  }
  /**
   * Gets the polling interval in milliseconds.
   */
  getWaitTime() {
    return Number(this.getOutputByName("waitTime", 0));
  }
};

let r$3 = class r extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the reCAPTCHA site key.
   */
  getSiteKey() {
    return this.getOutputByName("recaptchaSiteKey", "");
  }
  /**
   * Sets the reCAPTCHA result.
   */
  setResult(t) {
    this.setInputValue(t);
  }
};

let c$2 = class c extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the redirect URL.
   */
  getRedirectUrl() {
    return this.getOutputByName("redirectUrl", "");
  }
};

let d$2 = class d extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(r) {
    super(r), this.payload = r;
  }
  /**
   * Gets the available providers.
   */
  getProviders() {
    return this.getOutputByName("providers", []);
  }
  /**
   * Sets the provider by name.
   */
  setProvider(r) {
    const t = this.getProviders().find((e) => e.provider === r);
    if (!t)
      throw new Error(`"${r}" is not a valid choice`);
    this.setInputValue(t.provider);
  }
};

let u$1 = class u extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(e) {
    super(e), this.payload = e;
  }
  /**
   * Gets the message content.
   */
  getMessage() {
    return this.getOutputByName("message", "");
  }
  /**
   * Gets the message type.
   */
  getMessageType() {
    return this.getOutputByName("messageType", "");
  }
};

let a$5 = class a extends u$1 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
};

let a$4 = class a extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the terms and conditions content.
   */
  getTerms() {
    return this.getOutputByName("terms", "");
  }
  /**
   * Gets the version of the terms and conditions.
   */
  getVersion() {
    return this.getOutputByName("version", "");
  }
  /**
   * Gets the date of the terms and conditions.
   */
  getCreateDate() {
    const t = this.getOutputByName("createDate", "");
    return new Date(t);
  }
  /**
   * Sets the callback's acceptance.
   */
  setAccepted(t = !0) {
    this.setInputValue(t);
  }
};

let r$2 = class r extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(t) {
    super(t), this.payload = t;
  }
  /**
   * Gets the callback's prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Sets the callback's input value.
   */
  setInput(t) {
    this.setInputValue(t);
  }
};

let i$5 = class i extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(e) {
    super(e), this.payload = e;
  }
  /**
   * Gets the callback's failed policies.
   */
  getFailedPolicies() {
    const e = this.getOutputByName(
      "failedPolicies",
      []
    );
    try {
      return e.map((t) => JSON.parse(t));
    } catch {
      throw new Error(
        'Unable to parse "failed policies" from the ForgeRock server. The JSON within `ValidatedCreatePasswordCallback` was either malformed or missing.'
      );
    }
  }
  /**
   * Gets the callback's applicable policies.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getPolicies() {
    return this.getOutputByName("policies", {});
  }
  /**
   * Gets the callback's prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Gets whether the password is required.
   */
  isRequired() {
    return this.getOutputByName("required", !1);
  }
  /**
   * Sets the callback's password.
   */
  setPassword(e) {
    this.setInputValue(e);
  }
  /**
   * Set if validating value only.
   */
  setValidateOnly(e) {
    this.setInputValue(e, /validateOnly/);
  }
};

let s$2 = class s extends r$8 {
  /**
   * @param payload The raw payload returned by OpenAM
   */
  constructor(e) {
    super(e), this.payload = e;
  }
  /**
   * Gets the callback's prompt.
   */
  getPrompt() {
    return this.getOutputByName("prompt", "");
  }
  /**
   * Gets the callback's failed policies.
   */
  getFailedPolicies() {
    const e = this.getOutputByName(
      "failedPolicies",
      []
    );
    try {
      return e.map((t) => JSON.parse(t));
    } catch {
      throw new Error(
        'Unable to parse "failed policies" from the ForgeRock server. The JSON within `ValidatedCreateUsernameCallback` was either malformed or missing.'
      );
    }
  }
  /**
   * Gets the callback's applicable policies.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getPolicies() {
    return this.getOutputByName("policies", {});
  }
  /**
   * Gets whether the username is required.
   */
  isRequired() {
    return this.getOutputByName("required", !1);
  }
  /**
   * Sets the callback's username.
   */
  setName(e) {
    this.setInputValue(e);
  }
  /**
   * Set if validating value only.
   */
  setValidateOnly(e) {
    this.setInputValue(e, /validateOnly/);
  }
};

function L$1(e) {
  switch (e.type) {
    case l.BooleanAttributeInputCallback:
      return new s$4(e);
    case l.ChoiceCallback:
      return new h(e);
    case l.ConfirmationCallback:
      return new i$8(e);
    case l.DeviceProfileCallback:
      return new i$7(e);
    case l.HiddenValueCallback:
      return new t$2(e);
    case l.KbaCreateCallback:
      return new u$2(e);
    case l.MetadataCallback:
      return new s$3(e);
    case l.NameCallback:
      return new r$7(e);
    case l.NumberAttributeInputCallback:
      return new s$4(e);
    case l.PasswordCallback:
      return new r$6(e);
    case l.PingOneProtectEvaluationCallback:
      return new r$5(e);
    case l.PingOneProtectInitializeCallback:
      return new i$6(e);
    case l.PollingWaitCallback:
      return new r$4(e);
    case l.ReCaptchaCallback:
      return new r$3(e);
    case l.RedirectCallback:
      return new c$2(e);
    case l.SelectIdPCallback:
      return new d$2(e);
    case l.StringAttributeInputCallback:
      return new s$4(e);
    case l.SuspendedTextOutputCallback:
      return new a$5(e);
    case l.TermsAndConditionsCallback:
      return new a$4(e);
    case l.TextInputCallback:
      return new r$2(e);
    case l.TextOutputCallback:
      return new u$1(e);
    case l.ValidatedCreatePasswordCallback:
      return new i$5(e);
    case l.ValidatedCreateUsernameCallback:
      return new s$2(e);
    default:
      return new r$8(e);
  }
}

let i$4 = class i {
  /**
   * @param payload The raw payload returned by OpenAM
   * @param callbackFactory A function that returns am implementation of FRCallback
   */
  constructor(t, e) {
    this.payload = t, this.type = r$a.Step, this.callbacks = [], t.callbacks && (this.callbacks = this.convertCallbacks(t.callbacks, e));
  }
  /**
   * Gets the first callback of the specified type in this step.
   *
   * @param type The type of callback to find.
   */
  getCallbackOfType(t) {
    const e = this.getCallbacksOfType(t);
    if (e.length !== 1)
      throw new Error(`Expected 1 callback of type "${t}", but found ${e.length}`);
    return e[0];
  }
  /**
   * Gets all callbacks of the specified type in this step.
   *
   * @param type The type of callback to find.
   */
  getCallbacksOfType(t) {
    return this.callbacks.filter((e) => e.getType() === t);
  }
  /**
   * Sets the value of the first callback of the specified type in this step.
   *
   * @param type The type of callback to find.
   * @param value The value to set for the callback.
   */
  setCallbackValue(t, e) {
    const a = this.getCallbacksOfType(t);
    if (a.length !== 1)
      throw new Error(`Expected 1 callback of type "${t}", but found ${a.length}`);
    a[0].setInputValue(e);
  }
  /**
   * Gets the step's description.
   */
  getDescription() {
    return this.payload.description;
  }
  /**
   * Gets the step's header.
   */
  getHeader() {
    return this.payload.header;
  }
  /**
   * Gets the step's stage.
   */
  getStage() {
    return this.payload.stage;
  }
  convertCallbacks(t, e) {
    return t.map((l) => (e || L$1)(l) || L$1(l));
  }
};

let f$1 = class f {
  static get previousStepKey() {
    return `${c$3.get().prefix}-PreviousStep`;
  }
  /**
   * Requests the next step in the authentication tree.
   *
   * Call `FRAuth.next()` recursively.  At each step, check for session token or error, otherwise
   * populate the step's callbacks and call `next()` again.
   *
   * Example:
   *
   * ```js
   * async function nextStep(previousStep) {
   *   const thisStep = await FRAuth.next(previousStep);
   *
   *   switch (thisStep.type) {
   *     case StepType.LoginSuccess:
   *       const token = thisStep.getSessionToken();
   *       break;
   *     case StepType.LoginFailure:
   *       const detail = thisStep.getDetail();
   *       break;
   *     case StepType.Step:
   *       // Populate `thisStep` callbacks here, and then continue
   *       thisStep.setInputValue('foo');
   *       nextStep(thisStep);
   *       break;
   *   }
   * }
   * ```
   *
   * @param previousStep The previous step with its callback values populated
   * @param options Configuration overrides
   * @return The next step in the authentication tree
   */
  static async next(t, r) {
    const e = await J$1.next(t ? t.payload : void 0, r);
    if (e.authId) {
      const a = r ? r.callbackFactory : void 0;
      return new i$4(e, a);
    }
    return !e.authId && e.ok ? new r$9(e) : new i$9(e);
  }
  /**
   * Redirects to the URL identified in the RedirectCallback and saves the full
   * step information to localStorage for retrieval when user returns from login.
   *
   * Example:
   * ```js
   * forgerock.FRAuth.redirect(step);
   * ```
   */
  static redirect(t) {
    const e = t.getCallbackOfType(l.RedirectCallback).getRedirectUrl();
    localStorage.setItem(this.previousStepKey, JSON.stringify(t)), location.assign(e);
  }
  /**
   * Resumes a tree after returning from an external client or provider.
   * Requires the full URL of the current window. It will parse URL for
   * key-value pairs as well as, if required, retrieves previous step.
   *
   * Example;
   * ```js
   * forgerock.FRAuth.resume(window.location.href)
   * ```
   */
  static async resume(t, r) {
    const e = new URL(t), a = e.searchParams.get("code"), n = e.searchParams.get("error"), i = e.searchParams.get("errorCode"), m = e.searchParams.get("errorMessage"), s = e.searchParams.get("form_post_entry"), l = e.searchParams.get("nonce"), u = e.searchParams.get("RelayState"), c = e.searchParams.get("responsekey"), d = e.searchParams.get("scope"), o = e.searchParams.get("state"), g = e.searchParams.get("suspendedId"), h = e.searchParams.get("authIndexValue") ?? void 0;
    let y;
    function S() {
      return a && o || s || c;
    }
    if (S()) {
      const p = localStorage.getItem(this.previousStepKey);
      if (!p)
        throw new Error("Error: could not retrieve original redirect information.");
      try {
        y = JSON.parse(p);
      } catch {
        throw new Error("Error: could not parse redirect params or step information");
      }
      localStorage.removeItem(this.previousStepKey);
    }
    const P = {
      ...r,
      query: {
        // Conditionally spread properties into object. Don't spread props with undefined/null.
        ...a && { code: a },
        ...n && { error: n },
        ...i && { errorCode: i },
        ...m && { errorMessage: m },
        ...s && { form_post_entry: s },
        ...l && { nonce: l },
        ...u && { RelayState: u },
        ...c && { responsekey: c },
        ...d && { scope: d },
        ...o && { state: o },
        ...g && { suspendedId: g },
        // Allow developer to add or override params with their own.
        ...r && r.query
      },
      ...((r == null ? void 0 : r.tree) ?? h) && {
        tree: (r == null ? void 0 : r.tree) ?? h
      }
    };
    return await this.next(y, P);
  }
  /**
   * Requests the first step in the authentication tree.
   * This is essentially an alias to calling FRAuth.next without a previous step.
   *
   * @param options Configuration overrides
   * @return The next step in the authentication tree
   */
  static async start(t) {
    return await f.next(void 0, t);
  }
};

const o$3 = [
  "userAgent",
  "appName",
  "appCodeName",
  "appVersion",
  "appMinorVersion",
  "buildID",
  "product",
  "productSub",
  "vendor",
  "vendorSub",
  "browserLanguage"
], a$3 = [
  "fontNames",
  "displayProps",
  "browserProps",
  "hardwareProps",
  "platformProps"
], e$1 = 3e4, r$1 = {
  mac: ["Macintosh", "MacIntel", "MacPPC", "Mac68K"],
  windows: ["Win32", "Win64", "Windows", "WinCE"],
  ios: ["iPhone", "iPad", "iPod"]
}, n$1 = ["width", "height", "pixelDepth", "orientation.angle"], s$1 = [
  "cursive",
  "monospace",
  "serif",
  "sans-serif",
  "fantasy",
  "Arial",
  "Arial Black",
  "Arial Narrow",
  "Arial Rounded MT Bold",
  "Bookman Old Style",
  "Bradley Hand ITC",
  "Century",
  "Century Gothic",
  "Comic Sans MS",
  "Courier",
  "Courier New",
  "Georgia",
  "Gentium",
  "Impact",
  "King",
  "Lucida Console",
  "Lalit",
  "Modena",
  "Monotype Corsiva",
  "Papyrus",
  "Tahoma",
  "TeX",
  "Times",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana",
  "Verona"
], i$3 = [
  "cpuClass",
  "deviceMemory",
  "hardwareConcurrency",
  "maxTouchPoints",
  "oscpu"
], t$1 = ["language", "platform", "userLanguage", "systemLanguage"];

let p$2 = class p {
  /**
   * @method reduceToObject - goes one to two levels into source to collect attribute
   * @param props - array of strings; can use dot notation for two level lookup
   * @param src - source of attributes to check
   */
  // eslint-disable-next-line
  reduceToObject(n, t) {
    return n.reduce((e, o) => {
      if (o.includes(".")) {
        const l = o.split("."), d = l[0], i = l[1], s = t[d] && t[d][i];
        e[i] = s ?? "";
      } else
        e[o] = t[o] != null ? t[o] : null;
      return e;
    }, {});
  }
  /**
   * @method reduceToString - goes one level into source to collect attribute
   * @param props - array of strings
   * @param src - source of attributes to check
   */
  // eslint-disable-next-line
  reduceToString(n, t) {
    return n.reduce((e, o) => (e = `${e}${t[o].filename};`, e), "");
  }
};

class t {
  static enabled() {
    const { logLevel: o } = c$3.get();
    return {
      none: 0,
      error: 25,
      warn: 50,
      info: 75,
      debug: 100
    }[o];
  }
  static info(...o) {
    const { logger: e } = c$3.get();
    this.enabled() >= 50 && (e && e.info ? e.info(...o) : console.info(...o));
  }
  static warn(...o) {
    const { logger: e } = c$3.get();
    this.enabled() >= 50 && (e && e.warn ? e.warn(...o) : console.warn(...o));
  }
  static error(...o) {
    const { logger: e } = c$3.get();
    this.enabled() >= 25 && (e && e.error ? e.error(...o) : console.error(...o));
  }
  static log(...o) {
    const { logger: e } = c$3.get();
    this.enabled() >= 75 && (e && e.log ? e.log(...o) : console.log(...o));
  }
}

let O$1 = class O extends p$2 {
  constructor(t) {
    super(), this.config = {
      fontNames: s$1,
      devicePlatforms: r$1,
      displayProps: n$1,
      browserProps: o$3,
      hardwareProps: i$3,
      platformProps: t$1
    }, t && Object.keys(t).forEach((e) => {
      if (!a$3.includes(e))
        throw new Error("Device profile configuration category does not exist.");
      this.config[e] = t[e];
    });
  }
  getBrowserMeta() {
    return typeof navigator > "u" ? (t.warn("Cannot collect browser metadata. navigator is not defined."), {}) : this.reduceToObject(this.config.browserProps, navigator);
  }
  getBrowserPluginsNames() {
    return typeof navigator < "u" && navigator.plugins ? this.reduceToString(Object.keys(navigator.plugins), navigator.plugins) : (t.warn("Cannot collect browser plugin information. navigator.plugins is not defined."), "");
  }
  getDeviceName() {
    if (typeof navigator > "u")
      return t.warn("Cannot collect device name. navigator is not defined."), "";
    const t$1 = navigator.userAgent, e = navigator.platform;
    switch (!0) {
      case this.config.devicePlatforms.mac.includes(e):
        return "Mac (Browser)";
      case this.config.devicePlatforms.ios.includes(e):
        return `${e} (Browser)`;
      case this.config.devicePlatforms.windows.includes(e):
        return "Windows (Browser)";
      case (/Android/.test(e) || /Android/.test(t$1)):
        return "Android (Browser)";
      case (/CrOS/.test(t$1) || /Chromebook/.test(t$1)):
        return "Chrome OS (Browser)";
      case /Linux/.test(e):
        return "Linux (Browser)";
      default:
        return `${e || "Unknown"} (Browser)`;
    }
  }
  getDisplayMeta() {
    return typeof screen > "u" ? (t.warn("Cannot collect screen information. screen is not defined."), {}) : this.reduceToObject(this.config.displayProps, screen);
  }
  getHardwareMeta() {
    return typeof navigator > "u" ? (t.warn("Cannot collect OS metadata. Navigator is not defined."), {}) : this.reduceToObject(this.config.hardwareProps, navigator);
  }
  getIdentifier() {
    const t$1 = `${c$3.get().prefix}-DeviceID`;
    if (!(typeof globalThis.crypto < "u" && globalThis.crypto.getRandomValues))
      return t.warn("Cannot generate profile ID. Crypto and/or getRandomValues is not supported."), "";
    if (!localStorage)
      return t.warn("Cannot store profile ID. localStorage is not supported."), "";
    let e = localStorage.getItem(t$1);
    return e || (e = globalThis.crypto.getRandomValues(new Uint32Array(3)).join("-"), localStorage.setItem(t$1, e)), e;
  }
  getInstalledFonts() {
    if (typeof document > "u")
      return t.warn("Cannot collect font data. Global document object is undefined."), "";
    const t$1 = document.createElement("canvas");
    if (!t$1)
      return t.warn("Cannot collect font data. Browser does not support canvas element"), "";
    const e = t$1.getContext && t$1.getContext("2d");
    if (!e)
      return t.warn("Cannot collect font data. Browser does not support 2d canvas context"), "";
    const o = "abcdefghi0123456789";
    e.font = "72px Comic Sans";
    const i = e.measureText(o).width;
    return this.config.fontNames.reduce((r, a) => (e.font = `72px ${a}, Comic Sans`, e.measureText(o).width !== i && (r = `${r}${a};`), r), "");
  }
  async getLocationCoordinates() {
    return typeof navigator < "u" && navigator.geolocation ? new Promise(async (t$1) => {
      navigator.geolocation.getCurrentPosition(
        (e) => t$1({
          latitude: e.coords.latitude,
          longitude: e.coords.longitude
        }),
        (e) => {
          t.warn(
            "Cannot collect geolocation information. " + e.code + ": " + e.message
          ), t$1({});
        },
        {
          enableHighAccuracy: !0,
          timeout: e$1,
          maximumAge: 0
        }
      );
    }) : (t.warn(
      "Cannot collect geolocation information. navigator.geolocation is not defined."
    ), Promise.resolve({}));
  }
  getOSMeta() {
    return typeof navigator > "u" ? (t.warn("Cannot collect OS metadata. navigator is not defined."), {}) : this.reduceToObject(this.config.platformProps, navigator);
  }
  async getProfile({ location: t, metadata: e }) {
    const o = {
      identifier: this.getIdentifier()
    };
    return e && (o.metadata = {
      hardware: {
        ...this.getHardwareMeta(),
        display: this.getDisplayMeta()
      },
      browser: {
        ...this.getBrowserMeta(),
        plugins: this.getBrowserPluginsNames()
      },
      platform: {
        ...this.getOSMeta(),
        deviceName: this.getDeviceName(),
        fonts: this.getInstalledFonts(),
        timezone: this.getTimezoneOffset()
      }
    }), t && (o.location = await this.getLocationCoordinates()), o;
  }
  getTimezoneOffset() {
    try {
      return (/* @__PURE__ */ new Date()).getTimezoneOffset();
    } catch {
      return t.warn("Cannot collect timezone information. getTimezoneOffset is not defined."), null;
    }
  }
};

let i$2 = class i {
  /**
   * @method isQRCodeStep - determines if step contains QR Code callbacks
   * @param {FRStep} step - step object from AM response
   * @returns {boolean}
   */
  static isQRCodeStep(s) {
    const t = s.getCallbacksOfType(l.HiddenValueCallback);
    return t.length === 0 ? !1 : !!this.getQRCodeURICb(t);
  }
  /**
   * @method getQRCodeData - gets the necessary information from the QR Code callbacks
   * @param {FRStep} step - step object from AM response
   * @returns {QRCodeData}
   */
  static getQRCodeData(s) {
    const t = s.getCallbacksOfType(l.HiddenValueCallback);
    if (t.length === 0)
      throw new Error(
        "QR Code step must contain a HiddenValueCallback. Use `FRQRCode.isQRCodeStep` to guard."
      );
    const e = this.getQRCodeURICb(t), a = e ? e.getOutputValue("value") : "", u = typeof a == "string" && a.includes("otpauth://") ? "otp" : "push", n = s.getCallbacksOfType(l.TextOutputCallback).find((o) => o.getMessageType() !== "4");
    return {
      message: n ? n.getMessage() : "",
      use: u,
      uri: typeof a == "string" ? a : ""
    };
  }
  static getQRCodeURICb(s) {
    return s.find((t) => {
      const e = t.getOutputValue("value");
      return typeof e == "string" ? (e == null ? void 0 : e.includes("otpauth://")) || (e == null ? void 0 : e.includes("pushauth://")) : !1;
    });
  }
};

function o$2(e) {
  const s = e.match(/\s[\w\W]"([\w]*)\\/g);
  return Array.isArray(s) && s.map((a) => {
    const r = a.match(/"([\w]*)\\/);
    return Array.isArray(r) ? r[1] : "";
  }) || [];
}
function y(e) {
  var c, a, r;
  return ((r = (a = (c = e == null ? void 0 : e.match(/<em\s*.*>\s*.*<\/em>/g)) == null ? void 0 : c[0]) == null ? void 0 : a.replace("<em>", "")) == null ? void 0 : r.replace("</em>", "")) ?? "New Security Key";
}

let p$1 = class p {
  static getDeviceName(t) {
    var e;
    const a = ((e = this.getDisplayCallback(t)) == null ? void 0 : e.getOutputByName("message", "")) ?? "";
    return y(a);
  }
  /**
   * Retrieves the recovery codes by parsing the JavaScript message text in callback.
   *
   * @param step The step to evaluate
   * @return Recovery Code values in array
   */
  static getCodes(t) {
    var e;
    const a = (e = this.getDisplayCallback(t)) == null ? void 0 : e.getOutputByName("message", "");
    return o$2(a || "");
  }
  /**
   * Determines if the given step is a Display Recovery Codes step.
   *
   * @param step The step to evaluate
   * @return Is this step a Display Recovery Codes step
   */
  static isDisplayStep(t) {
    return !!this.getDisplayCallback(t);
  }
  /**
   * Gets the recovery codes step.
   *
   * @param step The step to evaluate
   * @return gets the Display Recovery Codes' callback
   */
  static getDisplayCallback(t) {
    return t.getCallbacksOfType(l.TextOutputCallback).find((a) => {
      const e = a.getOutputByName("message", void 0);
      return e && (e.includes("Recovery Codes") || e.includes("recovery codes"));
    });
  }
};

class n {
  /**
   * Retrieve tokens.
   */
  static async get(t) {
    const e = localStorage.getItem(`${c$3.get().prefix}-${t}`);
    if (e)
      try {
        return JSON.parse(e || "");
      } catch {
        throw new Error("Could not parse token object from localStorage");
      }
  }
  /**
   * Saves tokens.
   */
  static async set(t, e) {
    const o = JSON.stringify(e);
    localStorage.setItem(`${c$3.get().prefix}-${t}`, o);
  }
  /**
   * Removes stored tokens.
   */
  static async remove(t) {
    localStorage.removeItem(`${c$3.get().prefix}-${t}`);
  }
}

let a$2 = class a {
  /**
   * Retrieve tokens.
   */
  static async get(e) {
    const t = sessionStorage.getItem(`${c$3.get().prefix}-${e}`);
    if (t)
      try {
        return JSON.parse(t || "");
      } catch {
        throw new Error("Could not parse token from sessionStorage");
      }
  }
  /**
   * Saves tokens.
   */
  static async set(e, t) {
    const s = JSON.stringify(t);
    sessionStorage.setItem(`${c$3.get().prefix}-${e}`, s);
  }
  /**
   * Removes stored tokens.
   */
  static async remove(e) {
    sessionStorage.removeItem(`${c$3.get().prefix}-${e}`);
  }
};

let d$1 = class d {
  /**
   * Gets stored tokens.
   */
  static async get() {
    const { clientId: t$1, tokenStore: e } = this.getClientConfig();
    if (e === "sessionStorage")
      return await a$2.get(t$1);
    if (e === "localStorage")
      return await n.get(t$1);
    if (e === "indexedDB")
      t.warn("IndexedDB is not supported in this version.");
    else if (e && e.get)
      return await e.get(t$1);
    return await n.get(t$1);
  }
  /**
   * Saves tokens.
   */
  static async set(t$1) {
    const { clientId: e, tokenStore: r } = this.getClientConfig();
    if (r === "sessionStorage")
      return await a$2.set(e, t$1);
    if (r === "localStorage")
      return await n.set(e, t$1);
    if (r === "indexedDB")
      t.warn("IndexedDB is not supported in this version.");
    else if (r && r.set)
      return await r.set(e, t$1);
    return await n.set(e, t$1);
  }
  /**
   * Removes stored tokens.
   */
  static async remove() {
    const { clientId: t$1, tokenStore: e } = this.getClientConfig();
    if (e === "sessionStorage")
      return await a$2.remove(t$1);
    if (e === "localStorage")
      return await n.remove(t$1);
    if (e === "indexedDB")
      t.warn("IndexedDB is not supported in this version.");
    else if (e && e.remove)
      return await e.remove(t$1);
    return await n.remove(t$1);
  }
  static getClientConfig() {
    const { clientId: t = "unconfiguredClient", tokenStore: e = "localStorage" } = c$3.get();
    return { clientId: t, tokenStore: e };
  }
};

function o$1(t) {
  return t.ok || Math.floor(t.status / 100) === 4;
}

let c$1 = class c {
  /**
   * Creates a random state.
   */
  static createState() {
    return this.createRandomString(16);
  }
  /**
   * Creates a random verifier.
   */
  static createVerifier() {
    return this.createRandomString(32);
  }
  /**
   * Creates a SHA-256 hash of the verifier.
   *
   * @param verifier The verifier to hash
   */
  static async createChallenge(e) {
    const t = await this.sha256(e);
    return this.base64UrlEncode(t);
  }
  /**
   * Creates a base64 encoded, URL-friendly version of the specified array.
   *
   * @param array The array of numbers to encode
   */
  static base64UrlEncode(e) {
    const t = Array.prototype.slice.call(e);
    return btoa(String.fromCharCode.apply(null, t)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  /**
   * Creates a SHA-256 hash of the specified string.
   *
   * @param value The string to hash
   */
  static async sha256(e) {
    const t = new TextEncoder().encode(e), a = await crypto.subtle.digest("SHA-256", t);
    return new Uint8Array(a);
  }
  /**
   * Creates a random string.
   *
   * @param size The number for entropy (default: 32)
   */
  static createRandomString(e = 32) {
    const t = new Uint8Array(e);
    return crypto.getRandomValues(t), btoa(t.join("")).replace(/[^a-zA-Z0-9]+/, "");
  }
};

const A$1 = {
  // AM error for consent requirement
  AuthenticationConsentRequired: "Authentication or consent required",
  // Manual iframe error
  AuthorizationTimeout: "Authorization timed out",
  // Chromium browser error
  FailedToFetch: "Failed to fetch",
  // Mozilla browser error
  NetworkError: "NetworkError when attempting to fetch resource.",
  // Webkit browser error
  CORSError: "Cross-origin redirection",
  // prompt=none errors
  InteractionNotAllowed: "The request requires some interaction that is not allowed.",
  // PingOne login error
  LoginRequired: "User authentication is required"
};
let b$1 = class b {
  static async createAuthorizeUrl(e) {
    const { clientId: t, middleware: o, redirectUri: n, scope: i } = c$3.get(e), r = {
      ...e.query,
      client_id: t,
      redirect_uri: n,
      response_type: e.responseType,
      scope: i,
      state: e.state,
      ...e.prompt ? { prompt: e.prompt } : {}
    };
    if (e.verifier) {
      const a = await c$1.createChallenge(e.verifier);
      r.code_challenge = a, r.code_challenge_method = "S256";
    }
    const s = f$4(
      {
        url: new URL(this.getUrl("authorize", r, e)),
        init: {}
      },
      { type: e$2.Authorize }
    ), { url: c } = s(o);
    return c.toString();
  }
  /**
   * Calls the authorize URL with an iframe. If successful,
   * it returns the callback URL with authentication code,
   * optionally using PKCE.
   * Method renamed in v3.
   * Original Name: getAuthorizeUrl
   * New Name: getAuthCodeByIframe
   */
  static async getAuthCodeByIframe(e) {
    const t = await this.createAuthorizeUrl({ ...e, prompt: "none" }), { serverConfig: o } = c$3.get(e);
    return new Promise((n, i) => {
      const r = document.createElement("iframe"), s = () => {
      };
      let c = s, a = s, d = 0;
      a = () => {
        clearTimeout(d), r.removeEventListener("load", c), r.remove();
      }, c = () => {
        if (r.contentWindow) {
          const u = r.contentWindow.location.href;
          (this.containsAuthCode(u) || this.containsAuthError(u)) && (a(), n(u));
        }
      }, d = setTimeout(() => {
        a(), i(new Error(A$1.AuthorizationTimeout));
      }, o.timeout), r.style.display = "none", r.addEventListener("load", c), document.body.appendChild(r), r.src = t;
    });
  }
  /**
   * Exchanges an authorization code for OAuth tokens.
   */
  static async getOAuth2Tokens(e) {
    const { clientId: t, redirectUri: o } = c$3.get(e), n = {
      client_id: t,
      code: e.authorizationCode,
      grant_type: "authorization_code",
      redirect_uri: o
    };
    e.verifier && (n.code_verifier = e.verifier);
    const i = $$1(n), r = {
      body: i,
      headers: new Headers({
        "Content-Length": i.length.toString(),
        "Content-Type": "application/x-www-form-urlencoded"
      }),
      method: "POST"
    }, s = await this.request("accessToken", void 0, !1, r, e), c = await this.getBody(s);
    if (s.status !== 200) {
      const u = typeof c == "string" ? `Expected 200, received ${s.status}` : this.parseError(c);
      throw new Error(u);
    }
    const a = c;
    if (!a.access_token)
      throw new Error("Access token not found in response");
    let d;
    return a.expires_in && (d = Date.now() + a.expires_in * 1e3), {
      accessToken: a.access_token,
      idToken: a.id_token,
      refreshToken: a.refresh_token,
      tokenExpiry: d
    };
  }
  /**
   * Gets OIDC user information.
   */
  static async getUserInfo(e) {
    const t = await this.request("userInfo", void 0, !0, void 0, e);
    if (t.status !== 200)
      throw new Error(`Failed to get user info; received ${t.status}`);
    return await t.json();
  }
  /**
   * Invokes the OIDC end session endpoint.
   * Can result in a redirect to `/signoff` if using PingOne
   * It's best to explicitly provide the logout redirect URL in options
   *
   * @function endSession - call authorization server to end associated session
   * @param options {LogoutOptions} - an extension of ConfigOptions, but with two additional props
   * @param options.logoutRedirectUri {string} - the URL you want the AS to redirect to after signout
   * @param options.redirect {boolean} - to explicitly deactivate redirect, pass `false`
   */
  static async endSession(e) {
    const t = { ...e };
    delete t.redirect, delete t.logoutRedirectUri;
    const o = {}, n = await d$1.get();
    o.id_token_hint = n && n.idToken || (e && "idToken" in e ? e.idToken : "");
    const i = await this.request("endSession", o, !0, void 0, t, {
      redirect: e == null ? void 0 : e.redirect,
      logoutRedirectUri: e == null ? void 0 : e.logoutRedirectUri
    });
    if (!o$1(i))
      throw new Error(`Failed to end session; received ${i.status}`);
    return i;
  }
  /**
   * Immediately revokes the stored access token.
   */
  static async revokeToken(e) {
    const { clientId: t } = c$3.get(e), o = await d$1.get(), n = o && o.accessToken, i = {
      client_id: t
    };
    n && (i.token = n);
    const r = {
      body: $$1(i),
      credentials: "include",
      headers: new Headers({
        "Content-Type": "application/x-www-form-urlencoded"
      }),
      method: "POST"
    }, s = await this.request("revoke", void 0, !1, r, e);
    if (!o$1(s))
      throw new Error(`Failed to revoke token; received ${s.status}`);
    return s;
  }
  static async request(e, t, o, n, i, r) {
    const { redirectUri: s, middleware: c, serverConfig: a } = c$3.get(i), d = r != null && r.logoutRedirectUri ? r.logoutRedirectUri : s, u = this.getUrl(e, t, i), m = (w) => {
      switch (w) {
        case "accessToken":
          return e$2.ExchangeToken;
        case "endSession":
          return e$2.EndSession;
        case "revoke":
          return e$2.RevokeToken;
        default:
          return e$2.UserInfo;
      }
    };
    if (n = n || {}, o) {
      const w = await d$1.get(), v = w && w.accessToken;
      n.credentials = "include", n.headers = n.headers || new Headers(), n.headers.set("Authorization", `Bearer ${v}`);
    }
    const h = f$4(
      { url: new URL(u), init: n },
      { type: m(e) }
    )(c);
    return m(e) === e$2.EndSession && // endSession action only
    (r == null ? void 0 : r.redirect) === !0 ? (h.url.searchParams.append("post_logout_redirect_uri", d || ""), window.location.assign(h.url.toString()), new Response()) : m(e) === e$2.EndSession && // endSession action only
    (r == null ? void 0 : r.redirect) !== !1 && // Only `false` explicitly disables this behavior for rare edge cases
    // If we explicitly get a logout redirect URL, then that's enough of a hint to redirect
    // If we don't have that, let's see if they are calling the typical PingOne `/signoff` endpoint
    (r != null && r.logoutRedirectUri || this.getUrl("endSession").includes("/as/signoff")) ? (h.url.searchParams.append("post_logout_redirect_uri", d || ""), window.location.assign(h.url.toString()), new Response()) : await T$3(fetch(h.url.toString(), h.init), a.timeout);
  }
  static containsAuthCode(e) {
    return !!e && /code=([^&]+)/.test(e);
  }
  static containsAuthError(e) {
    return !!e && /error=([^&]+)/.test(e);
  }
  static async getBody(e) {
    const t = e.headers.get("Content-Type");
    return t && t.indexOf("application/json") > -1 ? await e.json() : await e.text();
  }
  static parseError(e) {
    if (e) {
      if (e.error && e.error_description)
        return `${e.error}: ${e.error_description}`;
      if (e.code && e.message)
        return `${e.code}: ${e.message}`;
    }
  }
  static getUrl(e, t, o) {
    const { realmPath: n, serverConfig: i } = c$3.get(o), r = h$1(e, n, i.paths);
    let s = f$3(i.baseUrl, r);
    return t && (s += `?${$$1(t)}`), s;
  }
};

let M$1 = class M {
  /**
   * Ends the current session.
   */
  static async logout(i) {
    const { middleware: s, platformHeader: a, realmPath: n, serverConfig: r } = c$3.get(i), d = {
      credentials: "include",
      headers: new Headers({
        "Accept-API-Version": "protocol=1.0,resource=2.0",
        "X-Requested-With": E$2
      }),
      method: "POST"
    }, l = `${h$1("sessions", n, r.paths)}?_action=logout`, m = f$3(r.baseUrl, l), e = f$4(
      { url: new URL(m), init: d },
      { type: e$2.Logout }
    )(s);
    a && (e.init.headers instanceof Headers ? e.init.headers.set("X-Requested-Platform", o$4) : Array.isArray(e.init.headers) ? e.init.headers.push(["X-Requested-Platform", o$4]) : e.init.headers ? e.init.headers["X-Requested-Platform"] = o$4 : e.init.headers = {
      "X-Requested-Platform": o$4
    });
    const o = await T$3(fetch(e.url.toString(), e.init), r.timeout);
    if (!o$1(o))
      throw new Error(`Failed to log out; received ${o.status}`);
    return o;
  }
};

function i$1(e, n) {
  return e && n ? n - e < Date.now() : !1;
}

var r = /* @__PURE__ */ ((o) => (o.Code = "code", o.Token = "token", o))(r || {});

let T$2 = class T {
  /**
     * Token Manager class that provides high-level abstraction for Authorization Code flow,
     * PKCE value generation, token exchange and token storage.
     *
     * Supports both embedded authentication as well as external authentication via redirects
     *
     Example 1:
  
     ```js
     const tokens = forgerock.TokenManager.getTokens({
       forceRenew: true, // If you want to get new tokens, despite existing ones
       login: 'embedded', // If user authentication is handled in-app
       serverConfig: {
         timeout: 5000, // If using "legacy", use a short timeout to catch error
       },
     });
     ```
  
     Example 2:
  
     ```js
     const tokens = forgerock.TokenManager.getTokens({
       forceRenew: false, // Will immediately return stored tokens, if they exist
       login: 'redirect', // If user authentication is handled in external Web app
     });
     ```
  
     Example 3:
  
     ```js
     const tokens = forgerock.TokenManager.getTokens({
       query: {
         code: 'lFJQYdoQG1u7nUm8 ... ', // Authorization code from redirect URL
         state: 'MTY2NDkxNTQ2Nde3D ... ', // State from redirect URL
       },
     });
     ```
     */
  static async getTokens(e) {
    var g, d, w;
    const { clientId: u, oauthThreshold: f } = c$3.get(e), i = `${c$3.get().prefix}-authflow-${u}`, o = await d$1.get();
    if (o && !(e != null && e.forceRenew) && !((g = e == null ? void 0 : e.query) != null && g.code) && !i$1(f, o.tokenExpiry))
      return o;
    if (o)
      try {
        await b$1.revokeToken(e), await T.deleteTokens();
      } catch (r) {
        t.warn("Existing tokens could not be revoked or deleted", r);
      }
    if ((d = e == null ? void 0 : e.query) != null && d.code && ((w = e == null ? void 0 : e.query) != null && w.state)) {
      const r = sessionStorage.getItem(i);
      sessionStorage.removeItem(i);
      const h = JSON.parse(r);
      return await this.tokenExchange(e, h);
    }
    const a = c$1.createVerifier(), n = c$1.createState(), s = Object.assign({}, e);
    delete s.forceRenew, delete s.login;
    const c = {
      ...s,
      responseType: r.Code,
      state: n,
      verifier: a
    };
    try {
      const r = new URL(await b$1.getAuthCodeByIframe(c));
      if (r.searchParams.get("error"))
        throw Error(`${r.searchParams.get("error_description")}`);
      if (!r.searchParams.get("code"))
        throw Error(A$1.AuthenticationConsentRequired);
      const h = p$3(r.toString());
      e || (e = {}), e.query = h;
    } catch (r) {
      if (!(r instanceof Error) || (e == null ? void 0 : e.login) !== "redirect" || A$1.AuthenticationConsentRequired !== r.message && A$1.AuthorizationTimeout !== r.message && A$1.FailedToFetch !== r.message && A$1.NetworkError !== r.message && A$1.InteractionNotAllowed !== r.message && // Check for Ping Identity Login Required error
      // Long message, so just check substring
      !r.message.includes(A$1.LoginRequired) && // Safari has a very long error message, so we check for a substring
      !r.message.includes(A$1.CORSError))
        throw r;
      sessionStorage.setItem(i, JSON.stringify(c));
      const h = await b$1.createAuthorizeUrl(c);
      return location.assign(h);
    }
    return await this.tokenExchange(e, { state: n, verifier: a });
  }
  static async deleteTokens() {
    await d$1.remove();
  }
  static async tokenExchange(e, u) {
    var n, s, c, g;
    if (((n = e.query) == null ? void 0 : n.state) !== u.state)
      throw new Error("State mismatch");
    if (!((s = e.query) != null && s.code) || Array.isArray((c = e.query) == null ? void 0 : c.code))
      throw new Error("Failed to acquire authorization code");
    const f = (g = e.query) == null ? void 0 : g.code, i = u.verifier, o = { ...e, authorizationCode: f, verifier: i }, a = await b$1.getOAuth2Tokens(o);
    if (!a || !a.accessToken)
      throw new Error("Unable to exchange authorization for tokens");
    try {
      await d$1.set(a);
    } catch (d) {
      t.error("Failed to store tokens", d);
    }
    return a;
  }
};

class k {
  /**
   * Logs the user in with the specified step handler, acquires OAuth tokens, and retrieves
   * user profile.  **Currently not implemented.**
   *
   * @typeparam T The type of user object expected
   * @param handler The function to invoke when handling authentication steps
   * @param options Configuration overrides
   */
  static async login(e, o) {
    throw t.info(e, o), new Error("FRUser.login() not implemented");
  }
  /**
   * Ends the user's session and revokes OAuth tokens.
   *
   * @param options Configuration overrides
   */
  static async logout(e) {
    const o = { ...e };
    delete o.redirect;
    try {
      await M$1.logout(o);
    } catch {
      t.warn("Session logout was not successful");
    }
    try {
      await b$1.revokeToken(o);
    } catch {
      t.warn("OAuth revokeToken was not successful");
    }
    const n = await d$1.get(), { idToken: a = "" } = n || {};
    await T$2.deleteTokens();
    try {
      await b$1.endSession({ ...e, idToken: a });
    } catch {
      t.warn("OAuth endSession was not successful");
    }
  }
}

var o = /* @__PURE__ */ ((r) => (r.Error = "ERROR", r.Unsupported = "unsupported", r))(o || {}), E$1 = /* @__PURE__ */ ((r) => (r.AbortError = "AbortError", r.DataError = "DataError", r.ConstraintError = "ConstraintError", r.EncodingError = "EncodingError", r.InvalidError = "InvalidError", r.NetworkError = "NetworkError", r.NotAllowedError = "NotAllowedError", r.NotSupportedError = "NotSupportedError", r.SecurityError = "SecurityError", r.TimeoutError = "TimeoutError", r.UnknownError = "UnknownError", r))(E$1 || {}), i = /* @__PURE__ */ ((r) => (r[r.None = 0] = "None", r[r.Authentication = 1] = "Authentication", r[r.Registration = 2] = "Registration", r))(i || {});

function s(r) {
  return r || [];
}
function u(r) {
  const n = new Uint8Array(r);
  return new TextDecoder().decode(n);
}
function f(r) {
  return r ? r[1] : "";
}
function a$1(r) {
  try {
    return r.split("}").filter((e) => !!e && e !== "]").map((e) => {
      const t = c(e);
      return {
        id: new Int8Array(t).buffer,
        type: "public-key"
      };
    });
  } catch {
    const e = new Error("Transforming credential object to string failed");
    throw e.name = E$1.EncodingError, e;
  }
}
function c(r) {
  const n = /new Int8Array\((.+)\)/.exec(r);
  return n === null || n.length < 2 ? [] : JSON.parse(n[1]);
}
function p(r) {
  if (Array.isArray(r))
    return r;
  if (typeof r == "string")
    return r && r[0] === "[" ? JSON.parse(r) : (r = r.replace(/(\w+):/g, '"$1":'), JSON.parse(`[${r}]`));
}
function d(r) {
  return r.includes("rpId") ? r.replace(/rpId: "(.+)",/, "$1") : r.replace(/id: "(.+)",/, "$1");
}

function T$1(t) {
  const s$1 = new TextEncoder(), r = f(t.match(/attestation"{0,}:\s{0,}"(\w+)"/)), c = Number(f(t.match(/timeout"{0,}:\s{0,}(\d+)/))), l = f(
    t.match(/userVerification"{0,}:\s{0,}"(\w+)"/)
  ), i = f(
    t.match(/requireResidentKey"{0,}:\s{0,}(\w+)/)
  ), o = f(
    t.match(/authenticatorAttachment"{0,}:\s{0,}"([\w-]+)/)
  ), m = f(t.match(/rp"{0,}:\s{0,}{([^}]+)}/)).trim(), a = f(m.match(/id"{0,}:\s{0,}"([^"]*)"/)), w = f(m.match(/name"{0,}:\s{0,}"([^"]*)"/)), n = f(t.match(/user"{0,}:\s{0,}{([^]{0,})},/)).trim(), u = f(n.match(/id"{0,}:\s{0,}Uint8Array.from\("([^"]+)"/)), d = f(n.match(/name"{0,}:\s{0,}"([\d\w._-]+)"/)), h = f(n.match(/displayName"{0,}:\s{0,}"([\d\w\s.@_-]+)"/)), p$1 = f(
    // Capture the `pubKeyCredParams` without also matching `excludeCredentials` as well.
    // `excludeCredentials` values are very similar to this property, so we need to make sure
    // our last value doesn't end with "buffer", so we are only capturing objects that
    // end in a digit and possibly a space.
    t.match(/pubKeyCredParams"*:\s*\[([^]+\d\s*})\s*]/)
  ).trim(), A = p(p$1);
  if (!A) {
    const b = new Error("Missing pubKeyCredParams property from registration options");
    throw b.name = E$1.DataError, b;
  }
  const g = f(
    t.match(/excludeCredentials"{0,}:\s{0,}\[([^]+)\s{0,}]/)
  ).trim(), f$1 = a$1(g), C = s(
    t.match(/challenge"{0,}:\s{0,}new\s{0,}(Uint|Int)8Array\(([^\)]+)/)
  ), N = JSON.parse(C[2]), I = new Int8Array(N).buffer;
  return {
    attestation: r,
    authenticatorSelection: {
      userVerification: l,
      // Only include authenticatorAttachment prop if the value is truthy
      ...o && { authenticatorAttachment: o },
      // Only include requireResidentKey prop if the value is of string "true"
      ...i === "true" && {
        requireResidentKey: !!i
      }
    },
    challenge: I,
    ...f$1.length && { excludeCredentials: f$1 },
    pubKeyCredParams: A,
    rp: {
      name: w,
      // only add key-value pair if truthy value is provided
      ...a && { id: a }
    },
    timeout: c,
    user: {
      displayName: h,
      id: s$1.encode(u),
      name: d
    }
  };
}
function E(t) {
  let s$1, r;
  t.includes("acceptableCredentials") ? r = f(
    t.match(/acceptableCredentials"*\s*=\s*\[([^]+)\s*]/)
  ).trim() : r = f(
    t.match(/allowCredentials"{0,}:\s{0,}\[([^]+)\s{0,}]/)
  ).trim();
  const c = f(
    t.match(/userVerification"{0,}:\s{0,}"(\w+)"/)
  );
  r && (s$1 = (r.split("},") || [r]).map((n) => {
    const u = f(n.match(/type"{0,}:\s{0,}"([\w-]+)"/)), d = s(n.match(/id"{0,}:\s{0,}new\s{0,}(Uint|Int)8Array\(([^\)]+)/)), h = JSON.parse(d[2]), p = new Int8Array(h).buffer;
    return {
      type: u,
      id: p
    };
  }));
  const l = Number(f(t.match(/timeout"{0,}:\s{0,}(\d+)/))), i = s(
    t.match(/challenge"{0,}:\s{0,}new\s{0,}(Uint|Int)8Array\(([^\)]+)/)
  ), o = JSON.parse(i[2]), m = new Int8Array(o).buffer, a = f(t.match(/rpId"{0,}:\s{0,}\\{0,}"([^"\\]*)/));
  return {
    challenge: m,
    timeout: l,
    // only add key-value pairs if the truthy values are provided
    ...s$1 && { allowCredentials: s$1 },
    ...c && { userVerification: c },
    ...a && { rpId: a }
  };
}

class T {
  /**
   * Determines if the given step is a WebAuthn step.
   *
   * @param step The step to evaluate
   * @return A WebAuthnStepType value
   */
  static getWebAuthnStepType(e) {
    const a = this.getOutcomeCallback(e), t = this.getMetadataCallback(e), i$1 = this.getTextOutputCallback(e);
    if (a && t) {
      const n = t.getOutputValue("data");
      return n != null && n.pubKeyCredParams ? i.Registration : i.Authentication;
    } else
      return a && i$1 ? i$1.getMessage().includes("pubKeyCredParams") ? i.Registration : i.Authentication : i.None;
  }
  /**
   * Populates the step with the necessary authentication outcome.
   *
   * @param step The step that contains WebAuthn authentication data
   * @return The populated step
   */
  static async authenticate(e) {
    const { hiddenCallback: a, metadataCallback: t, textOutputCallback: i } = this.getCallbacks(e);
    if (a && (t || i)) {
      let n;
      try {
        let r;
        if (t) {
          const c = t.getOutputValue("data");
          r = this.createAuthenticationPublicKey(c);
        } else
          i && (r = E(i.getMessage()));
        const o = await this.getAuthenticationCredential(r);
        n = this.getAuthenticationOutcome(o);
      } catch (r) {
        throw r instanceof Error ? r.name === E$1.NotSupportedError ? (a.setInputValue(o.Unsupported), r) : (a.setInputValue(`${o.Error}::${r.name}:${r.message}`), r) : r;
      }
      return a.setInputValue(n), e;
    } else {
      const n = new Error("Incorrect callbacks for WebAuthn authentication");
      throw n.name = E$1.DataError, a == null || a.setInputValue(`${o.Error}::${n.name}:${n.message}`), n;
    }
  }
  /**
   * Populates the step with the necessary registration outcome.
   *
   * @param step The step that contains WebAuthn registration data
   * @return The populated step
   */
  // Can make this generic const in Typescript 5.0 > and the name itself will
  // be inferred from the type so `typeof deviceName` will not just return string
  // but the actual name of the deviceName passed in as a generic.
  static async register(e, a) {
    const { hiddenCallback: t, metadataCallback: i, textOutputCallback: n } = this.getCallbacks(e);
    if (t && (i || n)) {
      let r;
      try {
        let o;
        if (i) {
          const c = i.getOutputValue("data");
          o = this.createRegistrationPublicKey(c);
          const l = await this.getRegistrationCredential(
            o
          );
          r = this.getRegistrationOutcome(l);
        } else if (n) {
          o = T$1(n.getMessage());
          const c = await this.getRegistrationCredential(
            o
          );
          r = this.getRegistrationOutcome(c);
        } else
          throw new Error("No Credential found from Public Key");
      } catch (o$1) {
        throw o$1 instanceof Error ? o$1.name === E$1.NotSupportedError ? (t.setInputValue(o.Unsupported), o$1) : (t.setInputValue(`${o.Error}::${o$1.name}:${o$1.message}`), o$1) : o$1;
      }
      return t.setInputValue(
        a && a.length > 0 ? `${r}::${a}` : r
      ), e;
    } else {
      const r = new Error("Incorrect callbacks for WebAuthn registration");
      throw r.name = E$1.DataError, t == null || t.setInputValue(`${o.Error}::${r.name}:${r.message}`), r;
    }
  }
  /**
   * Returns an object containing the two WebAuthn callbacks.
   *
   * @param step The step that contains WebAuthn callbacks
   * @return The WebAuthn callbacks
   */
  static getCallbacks(e) {
    const a = this.getOutcomeCallback(e), t = this.getMetadataCallback(e), i = this.getTextOutputCallback(e), n = {
      hiddenCallback: a
    };
    return t ? n.metadataCallback = t : i && (n.textOutputCallback = i), n;
  }
  /**
   * Returns the WebAuthn metadata callback containing data to pass to the browser
   * Web Authentication API.
   *
   * @param step The step that contains WebAuthn callbacks
   * @return The metadata callback
   */
  static getMetadataCallback(e) {
    return e.getCallbacksOfType(l.MetadataCallback).find((a) => {
      const t = a.getOutputByName("data", void 0);
      return t && t.hasOwnProperty("relyingPartyId");
    });
  }
  /**
   * Returns the WebAuthn hidden value callback where the outcome should be populated.
   *
   * @param step The step that contains WebAuthn callbacks
   * @return The hidden value callback
   */
  static getOutcomeCallback(e) {
    return e.getCallbacksOfType(l.HiddenValueCallback).find((a) => a.getOutputByName("id", "") === "webAuthnOutcome");
  }
  /**
   * Returns the WebAuthn metadata callback containing data to pass to the browser
   * Web Authentication API.
   *
   * @param step The step that contains WebAuthn callbacks
   * @return The metadata callback
   */
  static getTextOutputCallback(e) {
    return e.getCallbacksOfType(l.TextOutputCallback).find((a) => {
      const t = a.getOutputByName("message", void 0);
      return t && t.includes("webAuthnOutcome");
    });
  }
  /**
   * Retrieves the credential from the browser Web Authentication API.
   *
   * @param options The public key options associated with the request
   * @return The credential
   */
  static async getAuthenticationCredential(e) {
    if (!window.PublicKeyCredential) {
      const t = new Error("PublicKeyCredential not supported by this browser");
      throw t.name = E$1.NotSupportedError, t;
    }
    return await navigator.credentials.get({ publicKey: e });
  }
  /**
   * Converts an authentication credential into the outcome expected by OpenAM.
   *
   * @param credential The credential to convert
   * @return The outcome string
   */
  static getAuthenticationOutcome(e) {
    if (e === null) {
      const a = new Error("No credential generated from authentication");
      throw a.name = E$1.UnknownError, a;
    }
    try {
      const a = u(e.response.clientDataJSON), t = e.response, i = new Int8Array(
        t.authenticatorData
      ).toString(), n = new Int8Array(t.signature).toString(), r = u(e.response.userHandle);
      let o = `${a}::${i}::${n}::${e.id}`;
      return r && (o = `${o}::${r}`), o;
    } catch {
      const t = new Error("Transforming credential object to string failed");
      throw t.name = E$1.EncodingError, t;
    }
  }
  /**
   * Retrieves the credential from the browser Web Authentication API.
   *
   * @param options The public key options associated with the request
   * @return The credential
   */
  static async getRegistrationCredential(e) {
    if (!window.PublicKeyCredential) {
      const t = new Error("PublicKeyCredential not supported by this browser");
      throw t.name = E$1.NotSupportedError, t;
    }
    return await navigator.credentials.create({
      publicKey: e
    });
  }
  /**
   * Converts a registration credential into the outcome expected by OpenAM.
   *
   * @param credential The credential to convert
   * @return The outcome string
   */
  static getRegistrationOutcome(e) {
    if (e === null) {
      const a = new Error("No credential generated from registration");
      throw a.name = E$1.UnknownError, a;
    }
    try {
      const a = u(e.response.clientDataJSON), t = e.response, i = new Int8Array(
        t.attestationObject
      ).toString();
      return `${a}::${i}::${e.id}`;
    } catch {
      const t = new Error("Transforming credential object to string failed");
      throw t.name = E$1.EncodingError, t;
    }
  }
  /**
   * Converts authentication tree metadata into options required by the browser
   * Web Authentication API.
   *
   * @param metadata The metadata provided in the authentication tree MetadataCallback
   * @return The Web Authentication API request options
   */
  static createAuthenticationPublicKey(e) {
    const {
      acceptableCredentials: a,
      allowCredentials: t,
      challenge: i,
      relyingPartyId: n,
      timeout: r,
      userVerification: o
    } = e, c = d(n), l = a$1(t || a || "");
    return {
      challenge: Uint8Array.from(atob(i), (p) => p.charCodeAt(0)).buffer,
      timeout: r,
      // only add key-value pair if proper value is provided
      ...l && { allowCredentials: l },
      ...o && { userVerification: o },
      ...c && { rpId: c }
    };
  }
  /**
   * Converts authentication tree metadata into options required by the browser
   * Web Authentication API.
   *
   * @param metadata The metadata provided in the authentication tree MetadataCallback
   * @return The Web Authentication API request options
   */
  static createRegistrationPublicKey(e) {
    const { pubKeyCredParams: a } = e, t = p(a);
    if (!t) {
      const u = new Error("Missing pubKeyCredParams property from registration options");
      throw u.name = E$1.DataError, u;
    }
    const i = a$1(e.excludeCredentials), {
      attestationPreference: n,
      authenticatorSelection: r,
      challenge: o,
      relyingPartyId: c,
      relyingPartyName: l,
      timeout: p$1,
      userId: w,
      userName: m,
      displayName: O
    } = e, y = d(c), k = {
      name: l,
      ...y && { id: y }
    };
    return {
      attestation: n,
      authenticatorSelection: JSON.parse(r),
      challenge: Uint8Array.from(atob(o), (u) => u.charCodeAt(0)).buffer,
      ...i.length && { excludeCredentials: i },
      pubKeyCredParams: t,
      rp: k,
      timeout: p$1,
      user: {
        displayName: O || m,
        id: Int8Array.from(w.split("").map((u) => u.charCodeAt(0))),
        name: m
      }
    };
  }
}

function P(e, t, n) {
  const i = new Headers(e.headers);
  return t.AuthenticateToServiceConditionAdvice ? i.set("X-Tree", t.AuthenticateToServiceConditionAdvice[0]) : t.TransactionConditionAdvice && i.set("X-TxID", t.TransactionConditionAdvice[0]), n && n.idToken && i.set("X-IdToken", n.idToken), i;
}
function W(e, t, n) {
  const i = new URL(e);
  if (t.TransactionConditionAdvice) {
    const c = t.TransactionConditionAdvice[0];
    i.searchParams.append("_txid", c);
  }
  return n && n.idToken && i.searchParams.append("_idtoken", n.idToken), i.toString();
}
function b(e, t, n, i, c) {
  const r = e.advices && e.advices.AuthenticateToServiceConditionAdvice, a = e.advices && e.advices.TransactionConditionAdvice;
  let d = "", s = "";
  r ? (d = r.reduce((o, u) => {
    const l = o && ` ${o}`;
    return o = `${u}${l}`, o;
  }, ""), s = "AuthenticateToServiceConditionAdvice") : a && (d = a.reduce((o, u) => {
    const l = o && ` ${o}`;
    return o = `${u}${l}`, o;
  }, ""), s = "TransactionConditionAdvice");
  const v = "<Advices><AttributeValuePair>", h = `<Attribute name="${s}"/>`, T = `<Value>${d}</Value>`, f = `${v}${h}${T}</AttributeValuePair></Advices>`, p = h$1("authenticate", i, c), m = {
    authIndexType: "composite_advice",
    authIndexValue: f
  };
  return {
    init: {
      method: "POST",
      credentials: "include",
      headers: new Headers({
        "Accept-API-Version": "resource=2.0, protocol=1.0"
      })
    },
    timeout: n,
    url: f$3(t, `${p}?${$$1(m)}`)
  };
}
function H(e) {
  return (e.headers.get("Content-Type") || "").includes("html") && e.url.includes("composite_advice");
}
function L(e) {
  return (e.get("WWW-Authenticate") || "").includes("advices");
}
async function w(e) {
  return !!(await e.clone().json()).advices;
}
function A(e) {
  const n = new URL(e).searchParams.get("authIndexValue") || "", i = new DOMParser(), c = decodeURIComponent(n), a = i.parseFromString(c, "application/xml").querySelector("Value");
  return a ? a.innerHTML : "";
}
function V(e) {
  const n = (e.split(",") || []).find((c) => c.includes("advices")) || "";
  let i;
  try {
    const c = n.match(/"(\S+)"/), r = c ? c[1] : "", a = atob(r);
    return i = JSON.parse(a), i;
  } catch {
    t.error("Could not parse advices value from WWW-Authenticate header");
  }
  return {};
}
function z$1(e) {
  return e.advices && e.advices.AuthenticateToServiceConditionAdvice ? Array.isArray(e.advices.AuthenticateToServiceConditionAdvice) && e.advices.AuthenticateToServiceConditionAdvice.length > 0 : e.advices && e.advices.TransactionConditionAdvice ? Array.isArray(e.advices.TransactionConditionAdvice) && e.advices.TransactionConditionAdvice.length > 0 : !1;
}
async function F(e) {
  return !!(await e.clone().json()).callbacks;
}
function O(e, t) {
  return typeof t == "function" ? t(e) : e.status === 401;
}
function U(e) {
  const t = {};
  return e.url.includes("AuthenticateToServiceConditionAdvice") ? t.AuthenticateToServiceConditionAdvice = [A(e.url)] : t.TransactionConditionAdvice = [A(e.url)], {
    resource: "",
    actions: {},
    attributes: {},
    advices: t,
    ttl: 0
  };
}
function J(e) {
  const t = e.headers.get("WWW-Authenticate") || "", n = V(t);
  return {
    resource: "",
    actions: {},
    attributes: {},
    advices: n,
    ttl: 0
  };
}
async function N(e) {
  return await e.json();
}

class D {
  /**
   * Makes a request using the specified options.
   *
   * @param options The options to use when making the request
   */
  static async request(e) {
    let r = await this._request(e, !1), t, a = !1;
    if (O(r, e.requiresNewToken) && (r = await this._request(e, !0)), e.authorization && e.authorization.handleStep)
      if (r.status === 401 && L(r.headers) ? (a = !0, t = J(r)) : r.redirected && H(r) ? (a = !0, t = U(r)) : await w(r) && (t = await N(r)), t && t.advices) {
        const { middleware: n, realmPath: i, serverConfig: o } = c$3.get(e.authorization.config), s = b(
          t,
          o.baseUrl,
          e.timeout,
          i,
          o.paths
        ), c = new URL(s.url), u = c.searchParams.get("authIndexType"), m = c.searchParams.get("authIndexValue"), w = f$4(
          {
            url: new URL(s.url),
            init: s.init
          },
          {
            type: e$2.StartAuthenticate,
            payload: { type: u, tree: m }
          }
        ), { url: p, init: A } = w(n);
        s.url = p.toString(), s.init = A;
        const h = await this._request(s, !1);
        if (!await F(h))
          throw new Error('Error: Initial response from auth server not a "step".');
        if (!z$1(t))
          throw new Error("Error: Transactional or Service Advice is empty.");
        await this.stepIterator(h, e.authorization.handleStep);
        const l = await d$1.get();
        a ? e.url = W(e.url, t.advices, l) : e.init.headers = P(
          e.init,
          t.advices,
          l
        ), r = await this._request(e, !1);
      } else
        throw new Error("Error: Unable to process advice");
    return r;
  }
  static async setAuthHeaders(e, r) {
    let t = await d$1.get();
    return t && t.accessToken && (t = await T$2.getTokens({ forceRenew: r }), t && t.accessToken && e.set("Authorization", `Bearer ${t.accessToken}`)), e;
  }
  static async stepIterator(e, r) {
    const t = await e.json(), a = new i$4(t);
    return new Promise(async (n, i) => {
      async function o(s) {
        const c = await r(s), u = await f$1.next(c, { tree: "", type: "" });
        u.type === r$a.LoginSuccess ? n() : u.type === r$a.LoginFailure ? i("Authentication tree failure.") : o(u);
      }
      o(a);
    });
  }
  static async _request(e, r) {
    const { url: t, init: a, timeout: n } = e;
    let i = new Headers(a.headers || {});
    return e.authorization && i.set("x-authenticate-response", "header"), e.bypassAuthentication || (i = await this.setAuthHeaders(i, r)), a.headers = i, T$3(fetch(t, a), n);
  }
}

class a {
  /**
   * Gets the current user's profile.
   */
  static getCurrentUser(e) {
    return b$1.getUserInfo(e);
  }
}

class e {
  /**
   * @method getData - Method to get the device data
   * @returns {Promise<string>} - Returns the device data
   */
  static async getData() {
    return await window._pingOneSignals.getData();
  }
  /**
   * @method start - Method to initialize and start the PingOne Signals SDK
   * @param {InitParams} options - The init parameters
   * @returns {Promise<void>} - Returns a promise
   */
  static async start(a) {
    try {
      await Promise.resolve().then(function () { return index3; });
    } catch (i) {
      console.error("error loading ping signals", i);
    }
    await window._pingOneSignals.init(a), a.behavioralDataCollection === !0 && window._pingOneSignals.resumeBehavioralData();
  }
  /**
   * @method pauseBehavioralData - Method to pause the behavioral data collection
   * @returns {void}
   * @description Pause the behavioral data collection only; device profile data will still be collected
   */
  static pauseBehavioralData() {
    window._pingOneSignals.pauseBehavioralData();
  }
  /**
   * @method resumeBehavioralData - Method to resume the behavioral data collection
   * @returns {void}
   * @description Resume the behavioral data collection
   */
  static resumeBehavioralData() {
    window._pingOneSignals.resumeBehavioralData();
  }
}

/**
 * @function logErrorAndThrow - Logs an error message and throws an error.
 * @param {string} type - The type of error. This will be used to determine what error message to log.
 * @throws {Error} - An error with a message that depends on the value of `type`.
 */
function logErrorAndThrow(type) {
    if (type === 'missingStores') {
        const errorMessage = 'Error: missing configuration.';
        console.error(errorMessage);
        console.error('Please configure Widget by importing `configuration` and calling `set` with your settings.');
        throw new Error(errorMessage);
    }
    else if (type === 'missingBaseUrl') {
        const errorMessage = 'Error: missing `serverConfig.baseUrl`.';
        console.error(errorMessage);
        console.error('Please configure Widget by importing `configuration` and calling `set` with your ForgeRock server URL.');
        throw new Error(errorMessage);
    }
}

var util$2;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util$2 || (util$2 = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$2.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util$2.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util$2.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$2.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util$2.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util$2.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util$2.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util$2.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util$2.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" &&
                (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
// Adapted from https://stackoverflow.com/a/3143231
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    }
    else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    }
    else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$2.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util$2.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$2.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util$2.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$2.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util$2.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util$2.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util$2.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util$2.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util$2.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util$2.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util$2.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return Object.keys(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util$2.objectKeys(b);
        const sharedKeys = util$2
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util$2.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values) {
        return ZodEnum.create(values);
    }
    exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util$2.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util$2.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util$2.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util$2.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.issues.length) {
                return {
                    status: "dirty",
                    value: ctx.data,
                };
            }
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util$2.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        if (isValid(result)) {
            result.value = Object.freeze(result.value);
        }
        return result;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
const custom = (check, params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function"
                    ? params(data)
                    : typeof params === "string"
                        ? { message: params }
                        : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
            }
        });
    return ZodAny.create();
};
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
const NEVER = INVALID;

var z = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util () { return util$2; },
    get objectUtil () { return objectUtil; },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    ZodReadonly: ZodReadonly,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
});

/**
 * Configure underlying SDK
 */
const configSchema = z
    .object({
    callbackFactory: z
        .function()
        .args(z.object({
        _id: z.number().optional(),
        input: z
            .array(z.object({
            name: z.string(),
            value: z.unknown(),
        }))
            .optional(),
        output: z.array(z.object({
            name: z.string(),
            value: z.unknown(),
        })),
        type: z.nativeEnum(l),
    }))
        .returns(z.instanceof(r$8))
        .optional(),
    clientId: z.string().optional(),
    middleware: z.array(z.function()).optional(),
    realmPath: z.string(),
    redirectUri: z.string().optional(),
    scope: z.string().optional(),
    serverConfig: z
        .object({
        baseUrl: z
            .string({
            invalid_type_error: '`serverConfig.baseUrl` is a required URL string (this is generated by the Zod library).',
            required_error: 'Setting the `serverConfig.baseUrl` is required (this is generated by the Zod library).',
        })
            .url({
            message: '`serverConfig.baseUrl` must be a full URL (this is generated by the Zod library).',
        }),
        paths: z
            .object({
            authenticate: z.string().optional(),
            authorize: z.string().optional(),
            accessToken: z.string().optional(),
            endSession: z.string().optional(),
            userInfo: z.string().optional(),
            revoke: z.string().optional(),
            sessions: z.string().optional(),
        })
            .strict()
            .optional(),
        timeout: z
            .number({
            invalid_type_error: '`serverConfig.timeout` is a required number and in milliseconds (this is generated by the Zod library).',
        })
            .optional(),
    })
        .strict(),
    support: z.union([z.literal('legacy'), z.literal('modern')]).optional(),
    tokenStore: z
        .union([
        z
            .object({
            get: z
                .function()
                .args(z.string())
                .returns(z.promise(z.object({
                accessToken: z.string(),
                idToken: z.string().optional(),
                refreshToken: z.string().optional(),
                tokenExpiry: z.number().optional(),
            }))),
            set: z.function().args(z.string()).returns(z.promise(z.void())),
            remove: z.function().args(z.string()).returns(z.promise(z.void())),
        })
            .strict(),
        z.literal('sessionStorage'),
        z.literal('localStorage'),
    ])
        .optional(),
    tree: z.string().optional(),
    type: z.string().optional(),
    oauthThreshold: z.number().optional(),
})
    .strict();
configSchema.partial();
/**
 * @function - Sets the configuration for the SDK
 * @param {object} config - The configuration object
 * @returns {void}
 */
function configure (config) {
    configSchema.parse(config);
    c$3.set(config);
}

const journeyConfigItemSchema = z
    .object({
    journey: z.string().optional(),
    match: z
        .string()
        .regex(/^(#\/service|\?journey)/, {
        message: 'HREF string must start with `?journey` or `#/service`',
    })
        .array(),
})
    .optional();
const journeyConfigSchema = z.object({
    forgotPassword: journeyConfigItemSchema,
    forgotUsername: journeyConfigItemSchema,
    login: journeyConfigItemSchema,
    register: journeyConfigItemSchema,
});
const defaultJourneys = {
    forgotPassword: {
        journey: 'ResetPassword',
        match: ['#/service/ResetPassword', '?journey=ResetPassword'],
    },
    forgotUsername: {
        journey: 'ForgottenUsername',
        match: ['#/service/ForgottenUsername', '?journey=ForgottenUsername'],
    },
    login: {
        journey: 'Login',
        match: ['#/service/Login', '?journey', '?journey=Login'],
    },
    register: {
        journey: 'Registration',
        match: ['#/service/Registration', '?journey=Registration'],
    },
};
// Ensure default follows schema
journeyConfigSchema.parse(defaultJourneys);
const fallbackJourneyConfig = Object.keys(defaultJourneys).map((key) => ({
    ...defaultJourneys[key],
    key,
}));
const configuredJourneysStore = writable(fallbackJourneyConfig);
/**
 * @function initialize - Initialize the configured journeys store
 * @param {object} customJourneys - An object of custom journeys to merge with the default
 * @returns {object} - The configured journeys store
 * @example initialize({ login: { journey: 'Login', match: ['?journey=Login'] } })
 */
function initialize$6(customJourneys) {
    if (customJourneys) {
        // Provide developer feedback if customized
        journeyConfigSchema.parse(customJourneys);
        // Merge the two journey configs, dev's overwriting the default
        const mergedJourneyObjects = {
            ...defaultJourneys,
            ...customJourneys,
        };
        const customJourneyKeys = Object.keys(mergedJourneyObjects);
        configuredJourneysStore.set(customJourneyKeys.map((key) => ({
            ...mergedJourneyObjects[key],
            key,
        })));
    }
    else {
        configuredJourneysStore.set(fallbackJourneyConfig);
    }
    return configuredJourneysStore;
}

/*
 * forgerock-sample-web-react
 *
 * decode.js
 *
 * Copyright (c) 2021 ForgeRock. All rights reserved.
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file for details.
 */
/**
 * @function htmlDecode - Decodes HTML encoded strings
 * @param {string} input - string that needs to be HTML decoded
 * @returns {string} - decoded string
 */
function htmlDecode(input) {
    // Check if running in server before using the document object
    if (typeof document !== 'object') {
        return null;
    }
    const e = document.createElement('div');
    e.innerHTML = input;
    return e.childNodes.length === 0 ? '' : e.childNodes[0].nodeValue;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var lib$1 = {exports: {}};

var _default$1 = {};

var lib = {exports: {}};

var _default = {};

/**
 * cssfilter
 *
 * @author 老雷<leizongmin@gmail.com>
 */

function getDefaultWhiteList$1 () {
  // 白名单值说明：
  // true: 允许该属性
  // Function: function (val) { } 返回true表示允许该属性，其他值均表示不允许
  // RegExp: regexp.test(val) 返回true表示允许该属性，其他值均表示不允许
  // 除上面列出的值外均表示不允许
  var whiteList = {};

  whiteList['align-content'] = false; // default: auto
  whiteList['align-items'] = false; // default: auto
  whiteList['align-self'] = false; // default: auto
  whiteList['alignment-adjust'] = false; // default: auto
  whiteList['alignment-baseline'] = false; // default: baseline
  whiteList['all'] = false; // default: depending on individual properties
  whiteList['anchor-point'] = false; // default: none
  whiteList['animation'] = false; // default: depending on individual properties
  whiteList['animation-delay'] = false; // default: 0
  whiteList['animation-direction'] = false; // default: normal
  whiteList['animation-duration'] = false; // default: 0
  whiteList['animation-fill-mode'] = false; // default: none
  whiteList['animation-iteration-count'] = false; // default: 1
  whiteList['animation-name'] = false; // default: none
  whiteList['animation-play-state'] = false; // default: running
  whiteList['animation-timing-function'] = false; // default: ease
  whiteList['azimuth'] = false; // default: center
  whiteList['backface-visibility'] = false; // default: visible
  whiteList['background'] = true; // default: depending on individual properties
  whiteList['background-attachment'] = true; // default: scroll
  whiteList['background-clip'] = true; // default: border-box
  whiteList['background-color'] = true; // default: transparent
  whiteList['background-image'] = true; // default: none
  whiteList['background-origin'] = true; // default: padding-box
  whiteList['background-position'] = true; // default: 0% 0%
  whiteList['background-repeat'] = true; // default: repeat
  whiteList['background-size'] = true; // default: auto
  whiteList['baseline-shift'] = false; // default: baseline
  whiteList['binding'] = false; // default: none
  whiteList['bleed'] = false; // default: 6pt
  whiteList['bookmark-label'] = false; // default: content()
  whiteList['bookmark-level'] = false; // default: none
  whiteList['bookmark-state'] = false; // default: open
  whiteList['border'] = true; // default: depending on individual properties
  whiteList['border-bottom'] = true; // default: depending on individual properties
  whiteList['border-bottom-color'] = true; // default: current color
  whiteList['border-bottom-left-radius'] = true; // default: 0
  whiteList['border-bottom-right-radius'] = true; // default: 0
  whiteList['border-bottom-style'] = true; // default: none
  whiteList['border-bottom-width'] = true; // default: medium
  whiteList['border-collapse'] = true; // default: separate
  whiteList['border-color'] = true; // default: depending on individual properties
  whiteList['border-image'] = true; // default: none
  whiteList['border-image-outset'] = true; // default: 0
  whiteList['border-image-repeat'] = true; // default: stretch
  whiteList['border-image-slice'] = true; // default: 100%
  whiteList['border-image-source'] = true; // default: none
  whiteList['border-image-width'] = true; // default: 1
  whiteList['border-left'] = true; // default: depending on individual properties
  whiteList['border-left-color'] = true; // default: current color
  whiteList['border-left-style'] = true; // default: none
  whiteList['border-left-width'] = true; // default: medium
  whiteList['border-radius'] = true; // default: 0
  whiteList['border-right'] = true; // default: depending on individual properties
  whiteList['border-right-color'] = true; // default: current color
  whiteList['border-right-style'] = true; // default: none
  whiteList['border-right-width'] = true; // default: medium
  whiteList['border-spacing'] = true; // default: 0
  whiteList['border-style'] = true; // default: depending on individual properties
  whiteList['border-top'] = true; // default: depending on individual properties
  whiteList['border-top-color'] = true; // default: current color
  whiteList['border-top-left-radius'] = true; // default: 0
  whiteList['border-top-right-radius'] = true; // default: 0
  whiteList['border-top-style'] = true; // default: none
  whiteList['border-top-width'] = true; // default: medium
  whiteList['border-width'] = true; // default: depending on individual properties
  whiteList['bottom'] = false; // default: auto
  whiteList['box-decoration-break'] = true; // default: slice
  whiteList['box-shadow'] = true; // default: none
  whiteList['box-sizing'] = true; // default: content-box
  whiteList['box-snap'] = true; // default: none
  whiteList['box-suppress'] = true; // default: show
  whiteList['break-after'] = true; // default: auto
  whiteList['break-before'] = true; // default: auto
  whiteList['break-inside'] = true; // default: auto
  whiteList['caption-side'] = false; // default: top
  whiteList['chains'] = false; // default: none
  whiteList['clear'] = true; // default: none
  whiteList['clip'] = false; // default: auto
  whiteList['clip-path'] = false; // default: none
  whiteList['clip-rule'] = false; // default: nonzero
  whiteList['color'] = true; // default: implementation dependent
  whiteList['color-interpolation-filters'] = true; // default: auto
  whiteList['column-count'] = false; // default: auto
  whiteList['column-fill'] = false; // default: balance
  whiteList['column-gap'] = false; // default: normal
  whiteList['column-rule'] = false; // default: depending on individual properties
  whiteList['column-rule-color'] = false; // default: current color
  whiteList['column-rule-style'] = false; // default: medium
  whiteList['column-rule-width'] = false; // default: medium
  whiteList['column-span'] = false; // default: none
  whiteList['column-width'] = false; // default: auto
  whiteList['columns'] = false; // default: depending on individual properties
  whiteList['contain'] = false; // default: none
  whiteList['content'] = false; // default: normal
  whiteList['counter-increment'] = false; // default: none
  whiteList['counter-reset'] = false; // default: none
  whiteList['counter-set'] = false; // default: none
  whiteList['crop'] = false; // default: auto
  whiteList['cue'] = false; // default: depending on individual properties
  whiteList['cue-after'] = false; // default: none
  whiteList['cue-before'] = false; // default: none
  whiteList['cursor'] = false; // default: auto
  whiteList['direction'] = false; // default: ltr
  whiteList['display'] = true; // default: depending on individual properties
  whiteList['display-inside'] = true; // default: auto
  whiteList['display-list'] = true; // default: none
  whiteList['display-outside'] = true; // default: inline-level
  whiteList['dominant-baseline'] = false; // default: auto
  whiteList['elevation'] = false; // default: level
  whiteList['empty-cells'] = false; // default: show
  whiteList['filter'] = false; // default: none
  whiteList['flex'] = false; // default: depending on individual properties
  whiteList['flex-basis'] = false; // default: auto
  whiteList['flex-direction'] = false; // default: row
  whiteList['flex-flow'] = false; // default: depending on individual properties
  whiteList['flex-grow'] = false; // default: 0
  whiteList['flex-shrink'] = false; // default: 1
  whiteList['flex-wrap'] = false; // default: nowrap
  whiteList['float'] = false; // default: none
  whiteList['float-offset'] = false; // default: 0 0
  whiteList['flood-color'] = false; // default: black
  whiteList['flood-opacity'] = false; // default: 1
  whiteList['flow-from'] = false; // default: none
  whiteList['flow-into'] = false; // default: none
  whiteList['font'] = true; // default: depending on individual properties
  whiteList['font-family'] = true; // default: implementation dependent
  whiteList['font-feature-settings'] = true; // default: normal
  whiteList['font-kerning'] = true; // default: auto
  whiteList['font-language-override'] = true; // default: normal
  whiteList['font-size'] = true; // default: medium
  whiteList['font-size-adjust'] = true; // default: none
  whiteList['font-stretch'] = true; // default: normal
  whiteList['font-style'] = true; // default: normal
  whiteList['font-synthesis'] = true; // default: weight style
  whiteList['font-variant'] = true; // default: normal
  whiteList['font-variant-alternates'] = true; // default: normal
  whiteList['font-variant-caps'] = true; // default: normal
  whiteList['font-variant-east-asian'] = true; // default: normal
  whiteList['font-variant-ligatures'] = true; // default: normal
  whiteList['font-variant-numeric'] = true; // default: normal
  whiteList['font-variant-position'] = true; // default: normal
  whiteList['font-weight'] = true; // default: normal
  whiteList['grid'] = false; // default: depending on individual properties
  whiteList['grid-area'] = false; // default: depending on individual properties
  whiteList['grid-auto-columns'] = false; // default: auto
  whiteList['grid-auto-flow'] = false; // default: none
  whiteList['grid-auto-rows'] = false; // default: auto
  whiteList['grid-column'] = false; // default: depending on individual properties
  whiteList['grid-column-end'] = false; // default: auto
  whiteList['grid-column-start'] = false; // default: auto
  whiteList['grid-row'] = false; // default: depending on individual properties
  whiteList['grid-row-end'] = false; // default: auto
  whiteList['grid-row-start'] = false; // default: auto
  whiteList['grid-template'] = false; // default: depending on individual properties
  whiteList['grid-template-areas'] = false; // default: none
  whiteList['grid-template-columns'] = false; // default: none
  whiteList['grid-template-rows'] = false; // default: none
  whiteList['hanging-punctuation'] = false; // default: none
  whiteList['height'] = true; // default: auto
  whiteList['hyphens'] = false; // default: manual
  whiteList['icon'] = false; // default: auto
  whiteList['image-orientation'] = false; // default: auto
  whiteList['image-resolution'] = false; // default: normal
  whiteList['ime-mode'] = false; // default: auto
  whiteList['initial-letters'] = false; // default: normal
  whiteList['inline-box-align'] = false; // default: last
  whiteList['justify-content'] = false; // default: auto
  whiteList['justify-items'] = false; // default: auto
  whiteList['justify-self'] = false; // default: auto
  whiteList['left'] = false; // default: auto
  whiteList['letter-spacing'] = true; // default: normal
  whiteList['lighting-color'] = true; // default: white
  whiteList['line-box-contain'] = false; // default: block inline replaced
  whiteList['line-break'] = false; // default: auto
  whiteList['line-grid'] = false; // default: match-parent
  whiteList['line-height'] = false; // default: normal
  whiteList['line-snap'] = false; // default: none
  whiteList['line-stacking'] = false; // default: depending on individual properties
  whiteList['line-stacking-ruby'] = false; // default: exclude-ruby
  whiteList['line-stacking-shift'] = false; // default: consider-shifts
  whiteList['line-stacking-strategy'] = false; // default: inline-line-height
  whiteList['list-style'] = true; // default: depending on individual properties
  whiteList['list-style-image'] = true; // default: none
  whiteList['list-style-position'] = true; // default: outside
  whiteList['list-style-type'] = true; // default: disc
  whiteList['margin'] = true; // default: depending on individual properties
  whiteList['margin-bottom'] = true; // default: 0
  whiteList['margin-left'] = true; // default: 0
  whiteList['margin-right'] = true; // default: 0
  whiteList['margin-top'] = true; // default: 0
  whiteList['marker-offset'] = false; // default: auto
  whiteList['marker-side'] = false; // default: list-item
  whiteList['marks'] = false; // default: none
  whiteList['mask'] = false; // default: border-box
  whiteList['mask-box'] = false; // default: see individual properties
  whiteList['mask-box-outset'] = false; // default: 0
  whiteList['mask-box-repeat'] = false; // default: stretch
  whiteList['mask-box-slice'] = false; // default: 0 fill
  whiteList['mask-box-source'] = false; // default: none
  whiteList['mask-box-width'] = false; // default: auto
  whiteList['mask-clip'] = false; // default: border-box
  whiteList['mask-image'] = false; // default: none
  whiteList['mask-origin'] = false; // default: border-box
  whiteList['mask-position'] = false; // default: center
  whiteList['mask-repeat'] = false; // default: no-repeat
  whiteList['mask-size'] = false; // default: border-box
  whiteList['mask-source-type'] = false; // default: auto
  whiteList['mask-type'] = false; // default: luminance
  whiteList['max-height'] = true; // default: none
  whiteList['max-lines'] = false; // default: none
  whiteList['max-width'] = true; // default: none
  whiteList['min-height'] = true; // default: 0
  whiteList['min-width'] = true; // default: 0
  whiteList['move-to'] = false; // default: normal
  whiteList['nav-down'] = false; // default: auto
  whiteList['nav-index'] = false; // default: auto
  whiteList['nav-left'] = false; // default: auto
  whiteList['nav-right'] = false; // default: auto
  whiteList['nav-up'] = false; // default: auto
  whiteList['object-fit'] = false; // default: fill
  whiteList['object-position'] = false; // default: 50% 50%
  whiteList['opacity'] = false; // default: 1
  whiteList['order'] = false; // default: 0
  whiteList['orphans'] = false; // default: 2
  whiteList['outline'] = false; // default: depending on individual properties
  whiteList['outline-color'] = false; // default: invert
  whiteList['outline-offset'] = false; // default: 0
  whiteList['outline-style'] = false; // default: none
  whiteList['outline-width'] = false; // default: medium
  whiteList['overflow'] = false; // default: depending on individual properties
  whiteList['overflow-wrap'] = false; // default: normal
  whiteList['overflow-x'] = false; // default: visible
  whiteList['overflow-y'] = false; // default: visible
  whiteList['padding'] = true; // default: depending on individual properties
  whiteList['padding-bottom'] = true; // default: 0
  whiteList['padding-left'] = true; // default: 0
  whiteList['padding-right'] = true; // default: 0
  whiteList['padding-top'] = true; // default: 0
  whiteList['page'] = false; // default: auto
  whiteList['page-break-after'] = false; // default: auto
  whiteList['page-break-before'] = false; // default: auto
  whiteList['page-break-inside'] = false; // default: auto
  whiteList['page-policy'] = false; // default: start
  whiteList['pause'] = false; // default: implementation dependent
  whiteList['pause-after'] = false; // default: implementation dependent
  whiteList['pause-before'] = false; // default: implementation dependent
  whiteList['perspective'] = false; // default: none
  whiteList['perspective-origin'] = false; // default: 50% 50%
  whiteList['pitch'] = false; // default: medium
  whiteList['pitch-range'] = false; // default: 50
  whiteList['play-during'] = false; // default: auto
  whiteList['position'] = false; // default: static
  whiteList['presentation-level'] = false; // default: 0
  whiteList['quotes'] = false; // default: text
  whiteList['region-fragment'] = false; // default: auto
  whiteList['resize'] = false; // default: none
  whiteList['rest'] = false; // default: depending on individual properties
  whiteList['rest-after'] = false; // default: none
  whiteList['rest-before'] = false; // default: none
  whiteList['richness'] = false; // default: 50
  whiteList['right'] = false; // default: auto
  whiteList['rotation'] = false; // default: 0
  whiteList['rotation-point'] = false; // default: 50% 50%
  whiteList['ruby-align'] = false; // default: auto
  whiteList['ruby-merge'] = false; // default: separate
  whiteList['ruby-position'] = false; // default: before
  whiteList['shape-image-threshold'] = false; // default: 0.0
  whiteList['shape-outside'] = false; // default: none
  whiteList['shape-margin'] = false; // default: 0
  whiteList['size'] = false; // default: auto
  whiteList['speak'] = false; // default: auto
  whiteList['speak-as'] = false; // default: normal
  whiteList['speak-header'] = false; // default: once
  whiteList['speak-numeral'] = false; // default: continuous
  whiteList['speak-punctuation'] = false; // default: none
  whiteList['speech-rate'] = false; // default: medium
  whiteList['stress'] = false; // default: 50
  whiteList['string-set'] = false; // default: none
  whiteList['tab-size'] = false; // default: 8
  whiteList['table-layout'] = false; // default: auto
  whiteList['text-align'] = true; // default: start
  whiteList['text-align-last'] = true; // default: auto
  whiteList['text-combine-upright'] = true; // default: none
  whiteList['text-decoration'] = true; // default: none
  whiteList['text-decoration-color'] = true; // default: currentColor
  whiteList['text-decoration-line'] = true; // default: none
  whiteList['text-decoration-skip'] = true; // default: objects
  whiteList['text-decoration-style'] = true; // default: solid
  whiteList['text-emphasis'] = true; // default: depending on individual properties
  whiteList['text-emphasis-color'] = true; // default: currentColor
  whiteList['text-emphasis-position'] = true; // default: over right
  whiteList['text-emphasis-style'] = true; // default: none
  whiteList['text-height'] = true; // default: auto
  whiteList['text-indent'] = true; // default: 0
  whiteList['text-justify'] = true; // default: auto
  whiteList['text-orientation'] = true; // default: mixed
  whiteList['text-overflow'] = true; // default: clip
  whiteList['text-shadow'] = true; // default: none
  whiteList['text-space-collapse'] = true; // default: collapse
  whiteList['text-transform'] = true; // default: none
  whiteList['text-underline-position'] = true; // default: auto
  whiteList['text-wrap'] = true; // default: normal
  whiteList['top'] = false; // default: auto
  whiteList['transform'] = false; // default: none
  whiteList['transform-origin'] = false; // default: 50% 50% 0
  whiteList['transform-style'] = false; // default: flat
  whiteList['transition'] = false; // default: depending on individual properties
  whiteList['transition-delay'] = false; // default: 0s
  whiteList['transition-duration'] = false; // default: 0s
  whiteList['transition-property'] = false; // default: all
  whiteList['transition-timing-function'] = false; // default: ease
  whiteList['unicode-bidi'] = false; // default: normal
  whiteList['vertical-align'] = false; // default: baseline
  whiteList['visibility'] = false; // default: visible
  whiteList['voice-balance'] = false; // default: center
  whiteList['voice-duration'] = false; // default: auto
  whiteList['voice-family'] = false; // default: implementation dependent
  whiteList['voice-pitch'] = false; // default: medium
  whiteList['voice-range'] = false; // default: medium
  whiteList['voice-rate'] = false; // default: normal
  whiteList['voice-stress'] = false; // default: normal
  whiteList['voice-volume'] = false; // default: medium
  whiteList['volume'] = false; // default: medium
  whiteList['white-space'] = false; // default: normal
  whiteList['widows'] = false; // default: 2
  whiteList['width'] = true; // default: auto
  whiteList['will-change'] = false; // default: auto
  whiteList['word-break'] = true; // default: normal
  whiteList['word-spacing'] = true; // default: normal
  whiteList['word-wrap'] = true; // default: normal
  whiteList['wrap-flow'] = false; // default: auto
  whiteList['wrap-through'] = false; // default: wrap
  whiteList['writing-mode'] = false; // default: horizontal-tb
  whiteList['z-index'] = false; // default: auto

  return whiteList;
}


/**
 * 匹配到白名单上的一个属性时
 *
 * @param {String} name
 * @param {String} value
 * @param {Object} options
 * @return {String}
 */
function onAttr (name, value, options) {
  // do nothing
}

/**
 * 匹配到不在白名单上的一个属性时
 *
 * @param {String} name
 * @param {String} value
 * @param {Object} options
 * @return {String}
 */
function onIgnoreAttr (name, value, options) {
  // do nothing
}

var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;

/**
 * 过滤属性值
 *
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function safeAttrValue$1(name, value) {
  if (REGEXP_URL_JAVASCRIPT.test(value)) return '';
  return value;
}


_default.whiteList = getDefaultWhiteList$1();
_default.getDefaultWhiteList = getDefaultWhiteList$1;
_default.onAttr = onAttr;
_default.onIgnoreAttr = onIgnoreAttr;
_default.safeAttrValue = safeAttrValue$1;

var util$1 = {
  indexOf: function (arr, item) {
    var i, j;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      if (arr[i] === item) {
        return i;
      }
    }
    return -1;
  },
  forEach: function (arr, fn, scope) {
    var i, j;
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      fn.call(scope, arr[i], i, arr);
    }
  },
  trim: function (str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, '');
  },
  trimRight: function (str) {
    if (String.prototype.trimRight) {
      return str.trimRight();
    }
    return str.replace(/(\s*$)/g, '');
  }
};

/**
 * cssfilter
 *
 * @author 老雷<leizongmin@gmail.com>
 */

var _$3 = util$1;


/**
 * 解析style
 *
 * @param {String} css
 * @param {Function} onAttr 处理属性的函数
 *   参数格式： function (sourcePosition, position, name, value, source)
 * @return {String}
 */
function parseStyle$1 (css, onAttr) {
  css = _$3.trimRight(css);
  if (css[css.length - 1] !== ';') css += ';';
  var cssLength = css.length;
  var isParenthesisOpen = false;
  var lastPos = 0;
  var i = 0;
  var retCSS = '';

  function addNewAttr () {
    // 如果没有正常的闭合圆括号，则直接忽略当前属性
    if (!isParenthesisOpen) {
      var source = _$3.trim(css.slice(lastPos, i));
      var j = source.indexOf(':');
      if (j !== -1) {
        var name = _$3.trim(source.slice(0, j));
        var value = _$3.trim(source.slice(j + 1));
        // 必须有属性名称
        if (name) {
          var ret = onAttr(lastPos, retCSS.length, name, value, source);
          if (ret) retCSS += ret + '; ';
        }
      }
    }
    lastPos = i + 1;
  }

  for (; i < cssLength; i++) {
    var c = css[i];
    if (c === '/' && css[i + 1] === '*') {
      // 备注开始
      var j = css.indexOf('*/', i + 2);
      // 如果没有正常的备注结束，则后面的部分全部跳过
      if (j === -1) break;
      // 直接将当前位置调到备注结尾，并且初始化状态
      i = j + 1;
      lastPos = i + 1;
      isParenthesisOpen = false;
    } else if (c === '(') {
      isParenthesisOpen = true;
    } else if (c === ')') {
      isParenthesisOpen = false;
    } else if (c === ';') {
      if (isParenthesisOpen) ; else {
        addNewAttr();
      }
    } else if (c === '\n') {
      addNewAttr();
    }
  }

  return _$3.trim(retCSS);
}

var parser$2 = parseStyle$1;

/**
 * cssfilter
 *
 * @author 老雷<leizongmin@gmail.com>
 */

var DEFAULT$1 = _default;
var parseStyle = parser$2;


/**
 * 返回值是否为空
 *
 * @param {Object} obj
 * @return {Boolean}
 */
function isNull$1 (obj) {
  return (obj === undefined || obj === null);
}

/**
 * 浅拷贝对象
 *
 * @param {Object} obj
 * @return {Object}
 */
function shallowCopyObject$1 (obj) {
  var ret = {};
  for (var i in obj) {
    ret[i] = obj[i];
  }
  return ret;
}

/**
 * 创建CSS过滤器
 *
 * @param {Object} options
 *   - {Object} whiteList
 *   - {Function} onAttr
 *   - {Function} onIgnoreAttr
 *   - {Function} safeAttrValue
 */
function FilterCSS$2 (options) {
  options = shallowCopyObject$1(options || {});
  options.whiteList = options.whiteList || DEFAULT$1.whiteList;
  options.onAttr = options.onAttr || DEFAULT$1.onAttr;
  options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT$1.onIgnoreAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT$1.safeAttrValue;
  this.options = options;
}

FilterCSS$2.prototype.process = function (css) {
  // 兼容各种奇葩输入
  css = css || '';
  css = css.toString();
  if (!css) return '';

  var me = this;
  var options = me.options;
  var whiteList = options.whiteList;
  var onAttr = options.onAttr;
  var onIgnoreAttr = options.onIgnoreAttr;
  var safeAttrValue = options.safeAttrValue;

  var retCSS = parseStyle(css, function (sourcePosition, position, name, value, source) {

    var check = whiteList[name];
    var isWhite = false;
    if (check === true) isWhite = check;
    else if (typeof check === 'function') isWhite = check(value);
    else if (check instanceof RegExp) isWhite = check.test(value);
    if (isWhite !== true) isWhite = false;

    // 如果过滤后 value 为空则直接忽略
    value = safeAttrValue(name, value);
    if (!value) return;

    var opts = {
      position: position,
      sourcePosition: sourcePosition,
      source: source,
      isWhite: isWhite
    };

    if (isWhite) {

      var ret = onAttr(name, value, opts);
      if (isNull$1(ret)) {
        return name + ':' + value;
      } else {
        return ret;
      }

    } else {

      var ret = onIgnoreAttr(name, value, opts);
      if (!isNull$1(ret)) {
        return ret;
      }

    }
  });

  return retCSS;
};


var css = FilterCSS$2;

/**
 * cssfilter
 *
 * @author 老雷<leizongmin@gmail.com>
 */

(function (module, exports) {
	var DEFAULT = _default;
	var FilterCSS = css;


	/**
	 * XSS过滤
	 *
	 * @param {String} css 要过滤的CSS代码
	 * @param {Object} options 选项：whiteList, onAttr, onIgnoreAttr
	 * @return {String}
	 */
	function filterCSS (html, options) {
	  var xss = new FilterCSS(options);
	  return xss.process(html);
	}


	// 输出
	exports = module.exports = filterCSS;
	exports.FilterCSS = FilterCSS;
	for (var i in DEFAULT) exports[i] = DEFAULT[i];

	// 在浏览器端使用
	if (typeof window !== 'undefined') {
	  window.filterCSS = module.exports;
	} 
} (lib, lib.exports));

var libExports$1 = lib.exports;

var util = {
  indexOf: function (arr, item) {
    var i, j;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      if (arr[i] === item) {
        return i;
      }
    }
    return -1;
  },
  forEach: function (arr, fn, scope) {
    var i, j;
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      fn.call(scope, arr[i], i, arr);
    }
  },
  trim: function (str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function (str) {
    var reg = /\s|\n|\t/;
    var match = reg.exec(str);
    return match ? match.index : -1;
  },
};

/**
 * default settings
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var FilterCSS$1 = libExports$1.FilterCSS;
var getDefaultCSSWhiteList = libExports$1.getDefaultWhiteList;
var _$2 = util;

function getDefaultWhiteList() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src",
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width",
    ],
  };
}

var defaultCSSFilter = new FilterCSS$1();

/**
 * default onTag function
 *
 * @param {String} tag
 * @param {String} html
 * @param {Object} options
 * @return {String}
 */
function onTag(tag, html, options) {
  // do nothing
}

/**
 * default onIgnoreTag function
 *
 * @param {String} tag
 * @param {String} html
 * @param {Object} options
 * @return {String}
 */
function onIgnoreTag(tag, html, options) {
  // do nothing
}

/**
 * default onTagAttr function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function onTagAttr(tag, name, value) {
  // do nothing
}

/**
 * default onIgnoreTagAttr function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function onIgnoreTagAttr(tag, name, value) {
  // do nothing
}

/**
 * default escapeHtml function
 *
 * @param {String} html
 */
function escapeHtml(html) {
  return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
}

/**
 * default safeAttrValue function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @param {Object} cssFilter
 * @return {String}
 */
function safeAttrValue(tag, name, value, cssFilter) {
  // unescape attribute value firstly
  value = friendlyAttrValue(value);

  if (name === "href" || name === "src") {
    // filter `href` and `src` attribute
    // only allow the value that starts with `http://` | `https://` | `mailto:` | `/` | `#`
    value = _$2.trim(value);
    if (value === "#") return "#";
    if (
      !(
        value.substr(0, 7) === "http://" ||
        value.substr(0, 8) === "https://" ||
        value.substr(0, 7) === "mailto:" ||
        value.substr(0, 4) === "tel:" ||
        value.substr(0, 11) === "data:image/" ||
        value.substr(0, 6) === "ftp://" ||
        value.substr(0, 2) === "./" ||
        value.substr(0, 3) === "../" ||
        value[0] === "#" ||
        value[0] === "/"
      )
    ) {
      return "";
    }
  } else if (name === "background") {
    // filter `background` attribute (maybe no use)
    // `javascript:`
    REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
      return "";
    }
  } else if (name === "style") {
    // `expression()`
    REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
      return "";
    }
    // `url()`
    REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return "";
      }
    }
    if (cssFilter !== false) {
      cssFilter = cssFilter || defaultCSSFilter;
      value = cssFilter.process(value);
    }
  }

  // escape `<>"` before returns
  value = escapeAttrValue(value);
  return value;
}

// RegExp list
var REGEXP_LT = /</g;
var REGEXP_GT = />/g;
var REGEXP_QUOTE = /"/g;
var REGEXP_QUOTE_2 = /&quot;/g;
var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
// var REGEXP_DEFAULT_ON_TAG_ATTR_3 = /\/\*|\*\//gm;
var REGEXP_DEFAULT_ON_TAG_ATTR_4 =
  /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
// var REGEXP_DEFAULT_ON_TAG_ATTR_5 = /^[\s"'`]*(d\s*a\s*t\s*a\s*)\:/gi;
// var REGEXP_DEFAULT_ON_TAG_ATTR_6 = /^[\s"'`]*(d\s*a\s*t\s*a\s*)\:\s*image\//gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_7 =
  /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;

/**
 * escape double quote
 *
 * @param {String} str
 * @return {String} str
 */
function escapeQuote(str) {
  return str.replace(REGEXP_QUOTE, "&quot;");
}

/**
 * unescape double quote
 *
 * @param {String} str
 * @return {String} str
 */
function unescapeQuote(str) {
  return str.replace(REGEXP_QUOTE_2, '"');
}

/**
 * escape html entities
 *
 * @param {String} str
 * @return {String}
 */
function escapeHtmlEntities(str) {
  return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str, code) {
    return code[0] === "x" || code[0] === "X"
      ? String.fromCharCode(parseInt(code.substr(1), 16))
      : String.fromCharCode(parseInt(code, 10));
  });
}

/**
 * escape html5 new danger entities
 *
 * @param {String} str
 * @return {String}
 */
function escapeDangerHtml5Entities(str) {
  return str
    .replace(REGEXP_ATTR_VALUE_COLON, ":")
    .replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
}

/**
 * clear nonprintable characters
 *
 * @param {String} str
 * @return {String}
 */
function clearNonPrintableCharacter(str) {
  var str2 = "";
  for (var i = 0, len = str.length; i < len; i++) {
    str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
  }
  return _$2.trim(str2);
}

/**
 * get friendly attribute value
 *
 * @param {String} str
 * @return {String}
 */
function friendlyAttrValue(str) {
  str = unescapeQuote(str);
  str = escapeHtmlEntities(str);
  str = escapeDangerHtml5Entities(str);
  str = clearNonPrintableCharacter(str);
  return str;
}

/**
 * unescape attribute value
 *
 * @param {String} str
 * @return {String}
 */
function escapeAttrValue(str) {
  str = escapeQuote(str);
  str = escapeHtml(str);
  return str;
}

/**
 * `onIgnoreTag` function for removing all the tags that are not in whitelist
 */
function onIgnoreTagStripAll() {
  return "";
}

/**
 * remove tag body
 * specify a `tags` list, if the tag is not in the `tags` list then process by the specify function (optional)
 *
 * @param {array} tags
 * @param {function} next
 */
function StripTagBody(tags, next) {
  if (typeof next !== "function") {
    next = function () {};
  }

  var isRemoveAllTag = !Array.isArray(tags);
  function isRemoveTag(tag) {
    if (isRemoveAllTag) return true;
    return _$2.indexOf(tags, tag) !== -1;
  }

  var removeList = [];
  var posStart = false;

  return {
    onIgnoreTag: function (tag, html, options) {
      if (isRemoveTag(tag)) {
        if (options.isClosing) {
          var ret = "[/removed]";
          var end = options.position + ret.length;
          removeList.push([
            posStart !== false ? posStart : options.position,
            end,
          ]);
          posStart = false;
          return ret;
        } else {
          if (!posStart) {
            posStart = options.position;
          }
          return "[removed]";
        }
      } else {
        return next(tag, html, options);
      }
    },
    remove: function (html) {
      var rethtml = "";
      var lastPos = 0;
      _$2.forEach(removeList, function (pos) {
        rethtml += html.slice(lastPos, pos[0]);
        lastPos = pos[1];
      });
      rethtml += html.slice(lastPos);
      return rethtml;
    },
  };
}

/**
 * remove html comments
 *
 * @param {String} html
 * @return {String}
 */
function stripCommentTag(html) {
  var retHtml = "";
  var lastPos = 0;
  while (lastPos < html.length) {
    var i = html.indexOf("<!--", lastPos);
    if (i === -1) {
      retHtml += html.slice(lastPos);
      break;
    }
    retHtml += html.slice(lastPos, i);
    var j = html.indexOf("-->", i);
    if (j === -1) {
      break;
    }
    lastPos = j + 3;
  }
  return retHtml;
}

/**
 * remove invisible characters
 *
 * @param {String} html
 * @return {String}
 */
function stripBlankChar(html) {
  var chars = html.split("");
  chars = chars.filter(function (char) {
    var c = char.charCodeAt(0);
    if (c === 127) return false;
    if (c <= 31) {
      if (c === 10 || c === 13) return true;
      return false;
    }
    return true;
  });
  return chars.join("");
}

_default$1.whiteList = getDefaultWhiteList();
_default$1.getDefaultWhiteList = getDefaultWhiteList;
_default$1.onTag = onTag;
_default$1.onIgnoreTag = onIgnoreTag;
_default$1.onTagAttr = onTagAttr;
_default$1.onIgnoreTagAttr = onIgnoreTagAttr;
_default$1.safeAttrValue = safeAttrValue;
_default$1.escapeHtml = escapeHtml;
_default$1.escapeQuote = escapeQuote;
_default$1.unescapeQuote = unescapeQuote;
_default$1.escapeHtmlEntities = escapeHtmlEntities;
_default$1.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
_default$1.clearNonPrintableCharacter = clearNonPrintableCharacter;
_default$1.friendlyAttrValue = friendlyAttrValue;
_default$1.escapeAttrValue = escapeAttrValue;
_default$1.onIgnoreTagStripAll = onIgnoreTagStripAll;
_default$1.StripTagBody = StripTagBody;
_default$1.stripCommentTag = stripCommentTag;
_default$1.stripBlankChar = stripBlankChar;
_default$1.cssFilter = defaultCSSFilter;
_default$1.getDefaultCSSWhiteList = getDefaultCSSWhiteList;

var parser$1 = {};

/**
 * Simple HTML Parser
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var _$1 = util;

/**
 * get tag name
 *
 * @param {String} html e.g. '<a hef="#">'
 * @return {String}
 */
function getTagName(html) {
  var i = _$1.spaceIndex(html);
  var tagName;
  if (i === -1) {
    tagName = html.slice(1, -1);
  } else {
    tagName = html.slice(1, i + 1);
  }
  tagName = _$1.trim(tagName).toLowerCase();
  if (tagName.slice(0, 1) === "/") tagName = tagName.slice(1);
  if (tagName.slice(-1) === "/") tagName = tagName.slice(0, -1);
  return tagName;
}

/**
 * is close tag?
 *
 * @param {String} html 如：'<a hef="#">'
 * @return {Boolean}
 */
function isClosing(html) {
  return html.slice(0, 2) === "</";
}

/**
 * parse input html and returns processed html
 *
 * @param {String} html
 * @param {Function} onTag e.g. function (sourcePosition, position, tag, html, isClosing)
 * @param {Function} escapeHtml
 * @return {String}
 */
function parseTag$1(html, onTag, escapeHtml) {

  var rethtml = "";
  var lastPos = 0;
  var tagStart = false;
  var quoteStart = false;
  var currentPos = 0;
  var len = html.length;
  var currentTagName = "";
  var currentHtml = "";

  chariterator: for (currentPos = 0; currentPos < len; currentPos++) {
    var c = html.charAt(currentPos);
    if (tagStart === false) {
      if (c === "<") {
        tagStart = currentPos;
        continue;
      }
    } else {
      if (quoteStart === false) {
        if (c === "<") {
          rethtml += escapeHtml(html.slice(lastPos, currentPos));
          tagStart = currentPos;
          lastPos = currentPos;
          continue;
        }
        if (c === ">" || currentPos === len - 1) {
          rethtml += escapeHtml(html.slice(lastPos, tagStart));
          currentHtml = html.slice(tagStart, currentPos + 1);
          currentTagName = getTagName(currentHtml);
          rethtml += onTag(
            tagStart,
            rethtml.length,
            currentTagName,
            currentHtml,
            isClosing(currentHtml)
          );
          lastPos = currentPos + 1;
          tagStart = false;
          continue;
        }
        if (c === '"' || c === "'") {
          var i = 1;
          var ic = html.charAt(currentPos - i);

          while (ic.trim() === "" || ic === "=") {
            if (ic === "=") {
              quoteStart = c;
              continue chariterator;
            }
            ic = html.charAt(currentPos - ++i);
          }
        }
      } else {
        if (c === quoteStart) {
          quoteStart = false;
          continue;
        }
      }
    }
  }
  if (lastPos < len) {
    rethtml += escapeHtml(html.substr(lastPos));
  }

  return rethtml;
}

var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;

/**
 * parse input attributes and returns processed attributes
 *
 * @param {String} html e.g. `href="#" target="_blank"`
 * @param {Function} onAttr e.g. `function (name, value)`
 * @return {String}
 */
function parseAttr$1(html, onAttr) {

  var lastPos = 0;
  var lastMarkPos = 0;
  var retAttrs = [];
  var tmpName = false;
  var len = html.length;

  function addAttr(name, value) {
    name = _$1.trim(name);
    name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
    if (name.length < 1) return;
    var ret = onAttr(name, value || "");
    if (ret) retAttrs.push(ret);
  }

  // 逐个分析字符
  for (var i = 0; i < len; i++) {
    var c = html.charAt(i);
    var v, j;
    if (tmpName === false && c === "=") {
      tmpName = html.slice(lastPos, i);
      lastPos = i + 1;
      lastMarkPos = html.charAt(lastPos) === '"' || html.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html, i + 1);
      continue;
    }
    if (tmpName !== false) {
      if (
        i === lastMarkPos
      ) {
        j = html.indexOf(c, i + 1);
        if (j === -1) {
          break;
        } else {
          v = _$1.trim(html.slice(lastMarkPos + 1, j));
          addAttr(tmpName, v);
          tmpName = false;
          i = j;
          lastPos = i + 1;
          continue;
        }
      }
    }
    if (/\s|\n|\t/.test(c)) {
      html = html.replace(/\s|\n|\t/g, " ");
      if (tmpName === false) {
        j = findNextEqual(html, i);
        if (j === -1) {
          v = _$1.trim(html.slice(lastPos, i));
          addAttr(v);
          tmpName = false;
          lastPos = i + 1;
          continue;
        } else {
          i = j - 1;
          continue;
        }
      } else {
        j = findBeforeEqual(html, i - 1);
        if (j === -1) {
          v = _$1.trim(html.slice(lastPos, i));
          v = stripQuoteWrap(v);
          addAttr(tmpName, v);
          tmpName = false;
          lastPos = i + 1;
          continue;
        } else {
          continue;
        }
      }
    }
  }

  if (lastPos < html.length) {
    if (tmpName === false) {
      addAttr(html.slice(lastPos));
    } else {
      addAttr(tmpName, stripQuoteWrap(_$1.trim(html.slice(lastPos))));
    }
  }

  return _$1.trim(retAttrs.join(" "));
}

function findNextEqual(str, i) {
  for (; i < str.length; i++) {
    var c = str[i];
    if (c === " ") continue;
    if (c === "=") return i;
    return -1;
  }
}

function findNextQuotationMark(str, i) {
  for (; i < str.length; i++) {
    var c = str[i];
    if (c === " ") continue;
    if (c === "'" || c === '"') return i;
    return -1;
  }
}

function findBeforeEqual(str, i) {
  for (; i > 0; i--) {
    var c = str[i];
    if (c === " ") continue;
    if (c === "=") return i;
    return -1;
  }
}

function isQuoteWrapString(text) {
  if (
    (text[0] === '"' && text[text.length - 1] === '"') ||
    (text[0] === "'" && text[text.length - 1] === "'")
  ) {
    return true;
  } else {
    return false;
  }
}

function stripQuoteWrap(text) {
  if (isQuoteWrapString(text)) {
    return text.substr(1, text.length - 2);
  } else {
    return text;
  }
}

parser$1.parseTag = parseTag$1;
parser$1.parseAttr = parseAttr$1;

/**
 * filter xss
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var FilterCSS = libExports$1.FilterCSS;
var DEFAULT = _default$1;
var parser = parser$1;
var parseTag = parser.parseTag;
var parseAttr = parser.parseAttr;
var _ = util;

/**
 * returns `true` if the input value is `undefined` or `null`
 *
 * @param {Object} obj
 * @return {Boolean}
 */
function isNull(obj) {
  return obj === undefined || obj === null;
}

/**
 * get attributes for a tag
 *
 * @param {String} html
 * @return {Object}
 *   - {String} html
 *   - {Boolean} closing
 */
function getAttrs(html) {
  var i = _.spaceIndex(html);
  if (i === -1) {
    return {
      html: "",
      closing: html[html.length - 2] === "/",
    };
  }
  html = _.trim(html.slice(i + 1, -1));
  var isClosing = html[html.length - 1] === "/";
  if (isClosing) html = _.trim(html.slice(0, -1));
  return {
    html: html,
    closing: isClosing,
  };
}

/**
 * shallow copy
 *
 * @param {Object} obj
 * @return {Object}
 */
function shallowCopyObject(obj) {
  var ret = {};
  for (var i in obj) {
    ret[i] = obj[i];
  }
  return ret;
}

function keysToLowerCase(obj) {
  var ret = {};
  for (var i in obj) {
    if (Array.isArray(obj[i])) {
      ret[i.toLowerCase()] = obj[i].map(function (item) {
        return item.toLowerCase();
      });
    } else {
      ret[i.toLowerCase()] = obj[i];
    }
  }
  return ret;
}

/**
 * FilterXSS class
 *
 * @param {Object} options
 *        whiteList (or allowList), onTag, onTagAttr, onIgnoreTag,
 *        onIgnoreTagAttr, safeAttrValue, escapeHtml
 *        stripIgnoreTagBody, allowCommentTag, stripBlankChar
 *        css{whiteList, onAttr, onIgnoreAttr} `css=false` means don't use `cssfilter`
 */
function FilterXSS(options) {
  options = shallowCopyObject(options || {});

  if (options.stripIgnoreTag) {
    if (options.onIgnoreTag) {
      console.error(
        'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
      );
    }
    options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
  }
  if (options.whiteList || options.allowList) {
    options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
  } else {
    options.whiteList = DEFAULT.whiteList;
  }

  options.onTag = options.onTag || DEFAULT.onTag;
  options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
  options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
  options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
  options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
  this.options = options;

  if (options.css === false) {
    this.cssFilter = false;
  } else {
    options.css = options.css || {};
    this.cssFilter = new FilterCSS(options.css);
  }
}

/**
 * start process and returns result
 *
 * @param {String} html
 * @return {String}
 */
FilterXSS.prototype.process = function (html) {
  // compatible with the input
  html = html || "";
  html = html.toString();
  if (!html) return "";

  var me = this;
  var options = me.options;
  var whiteList = options.whiteList;
  var onTag = options.onTag;
  var onIgnoreTag = options.onIgnoreTag;
  var onTagAttr = options.onTagAttr;
  var onIgnoreTagAttr = options.onIgnoreTagAttr;
  var safeAttrValue = options.safeAttrValue;
  var escapeHtml = options.escapeHtml;
  var cssFilter = me.cssFilter;

  // remove invisible characters
  if (options.stripBlankChar) {
    html = DEFAULT.stripBlankChar(html);
  }

  // remove html comments
  if (!options.allowCommentTag) {
    html = DEFAULT.stripCommentTag(html);
  }

  // if enable stripIgnoreTagBody
  var stripIgnoreTagBody = false;
  if (options.stripIgnoreTagBody) {
    stripIgnoreTagBody = DEFAULT.StripTagBody(
      options.stripIgnoreTagBody,
      onIgnoreTag
    );
    onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
  }

  var retHtml = parseTag(
    html,
    function (sourcePosition, position, tag, html, isClosing) {
      var info = {
        sourcePosition: sourcePosition,
        position: position,
        isClosing: isClosing,
        isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag),
      };

      // call `onTag()`
      var ret = onTag(tag, html, info);
      if (!isNull(ret)) return ret;

      if (info.isWhite) {
        if (info.isClosing) {
          return "</" + tag + ">";
        }

        var attrs = getAttrs(html);
        var whiteAttrList = whiteList[tag];
        var attrsHtml = parseAttr(attrs.html, function (name, value) {
          // call `onTagAttr()`
          var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
          var ret = onTagAttr(tag, name, value, isWhiteAttr);
          if (!isNull(ret)) return ret;

          if (isWhiteAttr) {
            // call `safeAttrValue()`
            value = safeAttrValue(tag, name, value, cssFilter);
            if (value) {
              return name + '="' + value + '"';
            } else {
              return name;
            }
          } else {
            // call `onIgnoreTagAttr()`
            ret = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
            if (!isNull(ret)) return ret;
            return;
          }
        });

        // build new tag html
        html = "<" + tag;
        if (attrsHtml) html += " " + attrsHtml;
        if (attrs.closing) html += " /";
        html += ">";
        return html;
      } else {
        // call `onIgnoreTag()`
        ret = onIgnoreTag(tag, html, info);
        if (!isNull(ret)) return ret;
        return escapeHtml(html);
      }
    },
    escapeHtml
  );

  // if enable stripIgnoreTagBody
  if (stripIgnoreTagBody) {
    retHtml = stripIgnoreTagBody.remove(retHtml);
  }

  return retHtml;
};

var xss = FilterXSS;

/**
 * xss
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

(function (module, exports) {
	var DEFAULT = _default$1;
	var parser = parser$1;
	var FilterXSS = xss;

	/**
	 * filter xss function
	 *
	 * @param {String} html
	 * @param {Object} options { whiteList, onTag, onTagAttr, onIgnoreTag, onIgnoreTagAttr, safeAttrValue, escapeHtml }
	 * @return {String}
	 */
	function filterXSS(html, options) {
	  var xss = new FilterXSS(options);
	  return xss.process(html);
	}

	exports = module.exports = filterXSS;
	exports.filterXSS = filterXSS;
	exports.FilterXSS = FilterXSS;

	(function () {
	  for (var i in DEFAULT) {
	    exports[i] = DEFAULT[i];
	  }
	  for (var j in parser) {
	    exports[j] = parser[j];
	  }
	})();

	// using `xss` on the browser, output `filterXSS` to the globals
	if (typeof window !== "undefined") {
	  window.filterXSS = module.exports;
	}

	// using `xss` on the WebWorker, output `filterXSS` to the globals
	function isWorkerEnv() {
	  return (
	    typeof self !== "undefined" &&
	    typeof DedicatedWorkerGlobalScope !== "undefined" &&
	    self instanceof DedicatedWorkerGlobalScope
	  );
	}
	if (isWorkerEnv()) {
	  self.filterXSS = module.exports;
	} 
} (lib$1, lib$1.exports));

var libExports = lib$1.exports;
var sanitize = /*@__PURE__*/getDefaultExportFromCjs(libExports);

var alreadyHaveAnAccount = "Already have an account? <a href='?journey'>Sign in here!</a>";
var backToDefault = "Back to Sign In";
var backToLogin = "Back to Sign In";
var closeModal = "Close";
var charactersCannotRepeatMoreThan = "Character cannot repeat more than {max} times";
var charactersCannotRepeatMoreThanCaseInsensitive = "Character cannot repeat more than {max} times (case insensitive)";
var checkYourEmail = "Check your email";
var chooseDifferentUsername = "Please choose a different username.";
var chooseYourDeviceForIdentityVerification = "Choose your device for identity verification.";
var confirmPassword = "Confirm password";
var constraintViolationForPassword = "Password does not meet the requirements.";
var constraintViolationForValue = "Value does not meet the requirements.";
var continueWith = "Continue with ";
var copyAndPasteUrlBelow = "Or, copy and paste the URL below into your authentictor app.";
var copyUrl = "Copy URL";
var customSecurityQuestion = "Custom security question";
var deviceName = "Device name";
var doesNotMeetMinimumCharacterLength = "At least {min} character(s)";
var dontGetLockedOut = "Don't get locked out of your account!";
var dontHaveAnAccount = "No account? <a href='?journey=Registration'>Register here!</a>";
var ensurePasswordIsMoreThan = "Password must contain at least {minPasswordLength} character(s).";
var ensurePasswordHasOne = "Password must contain at least 1 capital letter, 1 number, and 1 special character.";
var enterVerificationCode = "Enter verification code";
var exceedsMaximumCharacterLength = "Exceeds maximum of {max} characters";
var fieldCanNotContainFollowingCharacters = "Cannot contain these character(s): {chars}";
var fieldCanNotContainFollowingValues = "Cannot contain these value(s): {fields}";
var forgotPassword = "Forgot password?";
var forgotUsername = "Forgot username?";
var givenName = "First name";
var inputRequiredError = "Value is required";
var loading = "Loading ...";
var loginButton = "Sign in";
var loginFailure = "Sign in failed";
var loginHeader = "Sign in";
var loginSuccess = "Sign in successful!";
var mail = "Email address";
var minimumNumberOfNumbers = "At least {num} number(s)";
var minimumNumberOfLowercase = "At least {num} lowercase letter(s)";
var minimumNumberOfUppercase = "At least {num} uppercase letter(s)";
var minimumNumberOfSymbols = "At least {num} symbol(s)";
var nameCallback = "Username";
var nameYourDevice = "Name your device";
var next = "Next";
var nextButton = "Next";
var notToExceedMaximumCharacterLength = "No more than {max} characters";
var noLessThanMinimumCharacterLength = "At least {min} character(s)";
var onMobileOpenInAuthenticator = "On mobile? Open link in Authenticator.";
var optionallyNameDevice = "Optionally name your device";
var passwordCallback = "Password";
var passwordCannotContainCommonPasswords = "Password cannot contain common passwords";
var passwordCannotContainCommonPasswordsOrBeReversible = "Password cannot contain common passwords or reversible text";
var passwordCannotContainCommonPasswordsOrBeReversibleStringsLessThan = "Password cannot contain common passwords or reversible text less than {min} characters";
var passwordRequirements = "Password requirements:";
var pleaseCheckValue = "Please check this value";
var pleaseConfirm = "Please confirm";
var preferencesMarketing = "Send me special offers and services";
var preferencesUpdates = "Send me news and updates";
var provideCustomQuestion = "Provide custom security question";
var qrCodeNotWorking = "Not working or need an alternative method?";
var qrCodeFailedToRender = "QR Code failed to render. Please notify your support administrator. You are welcome to use the alternative methods below.";
var qrCodeImportFailure = "We are unable to render your QR Code. Please use one of the alternative methods below.";
var redirectingTo = "Redirecting you to";
var registerButton = "Register";
var registerHeader = "Register";
var registerSuccess = "Registration successful!";
var requiredField = "Value is required";
var registerYourDevice = "Register {name}";
var scanQrCodeWithAuthenticator = "Scan the QR code image below with the ForgeRock Authenticator app to register your device with your login.";
var securityAnswer = "Security answer";
var securityQuestions = "Security question(s)";
var securityQuestionsPrompt = "Provide security question(s) and answer(s):";
var shouldContainANumber = "Should contain a number";
var shouldContainAnUppercase = "Should contain an uppercase letter";
var shouldContainALowercase = "Should contain a lowercase letter";
var shouldContainASymbol = "Should contain a symbol";
var showPassword = "Show password";
var signalsEvaluation = "Evaluating...";
var skipButton = "Skip";
var sn = "Last name";
var submit = "Submit";
var submitButton = "Submit";
var successMessage = "Success!";
var termsAndConditions = "Please accept our Terms & Conditions";
var termsAndConditionsLinkText = "View full Terms & Conditions";
var tryAgain = "Please try again";
var twoFactorAuthentication = "Two factor authentication";
var useThisNewMfaToHelpVerifyYourIdentity = "Use this new device or Multi-Factor Authentication method to help verify your identity.";
var useValidEmail = "Please use a valid email address.";
var unrecoverableError = "There was an error in the form submission.";
var unknownLoginError = "Unknown login failure has occurred.";
var unknownNetworkError = "Unknown network request failure has occurred.";
var url = "URL:";
var useDeviceForIdentityVerification = "Use your device for identity verification.";
var useOneOfTheseCodes = "Use one of these codes to authenticate if you lose your device, which has been named: <em>{name}</em>";
var userName = "Username";
var usernameRequirements = "Username requirements:";
var useTheAuthenticatorAppOnYourPhone = "Find the verification code using the authenticator app on your phone.";
var validatedCreatePasswordCallback = "Password";
var validatedCreateUsernameCallback = "Username";
var valueRequirements = "Value requirements:";
var verifyYourIdentity = "Verify your identity";
var yourDevice = "Your device";
var yourMultiFactorAuthIsEnabled = "Your new device or MFA is enabled";
var yourRecoveryCodesToAccessAccountForLostDevice = "If you lose your device, or don’t have it with you, a recovery code is the only way to sign in to your account with 2-step verification enabled. It’s strongly recommended that you print and store these codes in a safe place. <b>Each code can only be used once</b>.";
var fallback = {
	alreadyHaveAnAccount: alreadyHaveAnAccount,
	backToDefault: backToDefault,
	backToLogin: backToLogin,
	closeModal: closeModal,
	charactersCannotRepeatMoreThan: charactersCannotRepeatMoreThan,
	charactersCannotRepeatMoreThanCaseInsensitive: charactersCannotRepeatMoreThanCaseInsensitive,
	checkYourEmail: checkYourEmail,
	chooseDifferentUsername: chooseDifferentUsername,
	chooseYourDeviceForIdentityVerification: chooseYourDeviceForIdentityVerification,
	confirmPassword: confirmPassword,
	constraintViolationForPassword: constraintViolationForPassword,
	constraintViolationForValue: constraintViolationForValue,
	continueWith: continueWith,
	copyAndPasteUrlBelow: copyAndPasteUrlBelow,
	copyUrl: copyUrl,
	customSecurityQuestion: customSecurityQuestion,
	deviceName: deviceName,
	doesNotMeetMinimumCharacterLength: doesNotMeetMinimumCharacterLength,
	dontGetLockedOut: dontGetLockedOut,
	dontHaveAnAccount: dontHaveAnAccount,
	ensurePasswordIsMoreThan: ensurePasswordIsMoreThan,
	ensurePasswordHasOne: ensurePasswordHasOne,
	enterVerificationCode: enterVerificationCode,
	exceedsMaximumCharacterLength: exceedsMaximumCharacterLength,
	fieldCanNotContainFollowingCharacters: fieldCanNotContainFollowingCharacters,
	fieldCanNotContainFollowingValues: fieldCanNotContainFollowingValues,
	forgotPassword: forgotPassword,
	forgotUsername: forgotUsername,
	givenName: givenName,
	inputRequiredError: inputRequiredError,
	loading: loading,
	loginButton: loginButton,
	loginFailure: loginFailure,
	loginHeader: loginHeader,
	loginSuccess: loginSuccess,
	mail: mail,
	minimumNumberOfNumbers: minimumNumberOfNumbers,
	minimumNumberOfLowercase: minimumNumberOfLowercase,
	minimumNumberOfUppercase: minimumNumberOfUppercase,
	minimumNumberOfSymbols: minimumNumberOfSymbols,
	nameCallback: nameCallback,
	nameYourDevice: nameYourDevice,
	next: next,
	nextButton: nextButton,
	notToExceedMaximumCharacterLength: notToExceedMaximumCharacterLength,
	noLessThanMinimumCharacterLength: noLessThanMinimumCharacterLength,
	onMobileOpenInAuthenticator: onMobileOpenInAuthenticator,
	optionallyNameDevice: optionallyNameDevice,
	passwordCallback: passwordCallback,
	passwordCannotContainCommonPasswords: passwordCannotContainCommonPasswords,
	passwordCannotContainCommonPasswordsOrBeReversible: passwordCannotContainCommonPasswordsOrBeReversible,
	passwordCannotContainCommonPasswordsOrBeReversibleStringsLessThan: passwordCannotContainCommonPasswordsOrBeReversibleStringsLessThan,
	passwordRequirements: passwordRequirements,
	pleaseCheckValue: pleaseCheckValue,
	pleaseConfirm: pleaseConfirm,
	preferencesMarketing: preferencesMarketing,
	preferencesUpdates: preferencesUpdates,
	provideCustomQuestion: provideCustomQuestion,
	qrCodeNotWorking: qrCodeNotWorking,
	qrCodeFailedToRender: qrCodeFailedToRender,
	qrCodeImportFailure: qrCodeImportFailure,
	redirectingTo: redirectingTo,
	registerButton: registerButton,
	registerHeader: registerHeader,
	registerSuccess: registerSuccess,
	requiredField: requiredField,
	registerYourDevice: registerYourDevice,
	scanQrCodeWithAuthenticator: scanQrCodeWithAuthenticator,
	securityAnswer: securityAnswer,
	securityQuestions: securityQuestions,
	securityQuestionsPrompt: securityQuestionsPrompt,
	shouldContainANumber: shouldContainANumber,
	shouldContainAnUppercase: shouldContainAnUppercase,
	shouldContainALowercase: shouldContainALowercase,
	shouldContainASymbol: shouldContainASymbol,
	showPassword: showPassword,
	signalsEvaluation: signalsEvaluation,
	skipButton: skipButton,
	sn: sn,
	submit: submit,
	submitButton: submitButton,
	successMessage: successMessage,
	termsAndConditions: termsAndConditions,
	termsAndConditionsLinkText: termsAndConditionsLinkText,
	tryAgain: tryAgain,
	twoFactorAuthentication: twoFactorAuthentication,
	useThisNewMfaToHelpVerifyYourIdentity: useThisNewMfaToHelpVerifyYourIdentity,
	useValidEmail: useValidEmail,
	unrecoverableError: unrecoverableError,
	unknownLoginError: unknownLoginError,
	unknownNetworkError: unknownNetworkError,
	url: url,
	useDeviceForIdentityVerification: useDeviceForIdentityVerification,
	useOneOfTheseCodes: useOneOfTheseCodes,
	userName: userName,
	usernameRequirements: usernameRequirements,
	useTheAuthenticatorAppOnYourPhone: useTheAuthenticatorAppOnYourPhone,
	validatedCreatePasswordCallback: validatedCreatePasswordCallback,
	validatedCreateUsernameCallback: validatedCreateUsernameCallback,
	valueRequirements: valueRequirements,
	verifyYourIdentity: verifyYourIdentity,
	yourDevice: yourDevice,
	yourMultiFactorAuthIsEnabled: yourMultiFactorAuthIsEnabled,
	yourRecoveryCodesToAccessAccountForLostDevice: yourRecoveryCodesToAccessAccountForLostDevice
};

const stringsSchema = z
    .object({
    alreadyHaveAnAccount: z.string(),
    backToDefault: z.string(),
    backToLogin: z.string(),
    dontHaveAnAccount: z.string(),
    closeModal: z.string(),
    charactersCannotRepeatMoreThan: z.string(),
    charactersCannotRepeatMoreThanCaseInsensitive: z.string(),
    checkYourEmail: z.string(),
    chooseDifferentUsername: z.string(),
    chooseYourDeviceForIdentityVerification: z.string(),
    confirmPassword: z.string(),
    constraintViolationForPassword: z.string(),
    constraintViolationForValue: z.string(),
    continueWith: z.string(),
    copyUrl: z.string(),
    copyAndPasteUrlBelow: z.string(),
    customSecurityQuestion: z.string(),
    dontGetLockedOut: z.string(),
    doesNotMeetMinimumCharacterLength: z.string(),
    deviceName: z.string(),
    ensurePasswordIsMoreThan: z.string(),
    ensurePasswordHasOne: z.string(),
    enterVerificationCode: z.string(),
    exceedsMaximumCharacterLength: z.string(),
    fieldCanNotContainFollowingCharacters: z.string(),
    fieldCanNotContainFollowingValues: z.string(),
    forgotPassword: z.string(),
    forgotUsername: z.string(),
    givenName: z.string(),
    inputRequiredError: z.string(),
    loading: z.string(),
    loginButton: z.string(),
    loginFailure: z.string(),
    loginHeader: z.string(),
    loginSuccess: z.string(),
    mail: z.string(),
    minimumNumberOfNumbers: z.string(),
    minimumNumberOfLowercase: z.string(),
    minimumNumberOfUppercase: z.string(),
    minimumNumberOfSymbols: z.string(),
    nameCallback: z.string(),
    nameYourDevice: z.string(),
    next: z.string(),
    nextButton: z.string(),
    notToExceedMaximumCharacterLength: z.string(),
    noLessThanMinimumCharacterLength: z.string(),
    useOneOfTheseCodes: z.string(),
    onMobileOpenInAuthenticator: z.string(),
    optionallyNameDevice: z.string(),
    passwordCallback: z.string(),
    passwordCannotContainCommonPasswords: z.string(),
    passwordCannotContainCommonPasswordsOrBeReversible: z.string(),
    passwordCannotContainCommonPasswordsOrBeReversibleStringsLessThan: z.string(),
    passwordRequirements: z.string(),
    pleaseCheckValue: z.string(),
    pleaseConfirm: z.string(),
    preferencesMarketing: z.string(),
    preferencesUpdates: z.string(),
    provideCustomQuestion: z.string(),
    qrCodeNotWorking: z.string(),
    qrCodeFailedToRender: z.string(),
    qrCodeImportFailure: z.string(),
    redirectingTo: z.string(),
    registerButton: z.string(),
    registerHeader: z.string(),
    registerSuccess: z.string(),
    registerYourDevice: z.string(),
    requiredField: z.string(),
    securityAnswer: z.string(),
    scanQrCodeWithAuthenticator: z.string(),
    securityQuestions: z.string(),
    securityQuestionsPrompt: z.string(),
    shouldContainANumber: z.string(),
    shouldContainAnUppercase: z.string(),
    shouldContainALowercase: z.string(),
    shouldContainASymbol: z.string(),
    showPassword: z.string(),
    signalsEvaluation: z.string(),
    skipButton: z.string(),
    sn: z.string(),
    submit: z.string(),
    submitButton: z.string(),
    successMessage: z.string(),
    termsAndConditions: z.string(),
    termsAndConditionsLinkText: z.string(),
    tryAgain: z.string(),
    twoFactorAuthentication: z.string(),
    useThisNewMfaToHelpVerifyYourIdentity: z.string(),
    useValidEmail: z.string(),
    unrecoverableError: z.string(),
    unknownLoginError: z.string(),
    unknownNetworkError: z.string(),
    url: z.string(),
    useDeviceForIdentityVerification: z.string(),
    userName: z.string(),
    usernameRequirements: z.string(),
    useTheAuthenticatorAppOnYourPhone: z.string(),
    validatedCreatePasswordCallback: z.string(),
    validatedCreateUsernameCallback: z.string(),
    valueRequirements: z.string(),
    verifyYourIdentity: z.string(),
    yourDevice: z.string(),
    yourMultiFactorAuthIsEnabled: z.string(),
    yourRecoveryCodesToAccessAccountForLostDevice: z.string(),
})
    .strict();
stringsSchema.partial();
// Ensure fallback follows schema
stringsSchema.parse(fallback);
const stringsStore = writable(null);
/**
 * @function initialize - Initialize the locale store
 * @param {object} userLocale - An object of custom locale strings to merge with the default
 * @returns {object} - The locale store
 * @example initialize({ loginHeader: 'Welcome to the login page' });
 */
function initialize$5(userLocale) {
    if (userLocale) {
        /**
         * Allow widgets to overwrite select portions of the content
         */
        stringsStore.set({ ...fallback, ...userLocale });
    }
    else {
        stringsStore.set(fallback);
    }
    return stringsSchema;
}

/**
 * Do not allow strings with angle brackets, just to be extra safe
 *
 * Demo: https://regex101.com/r/Mw9vTB/1
 */
const valueSchema = z.record(z.string().regex(/^[^<>]*$/)).optional();
/**
 * @function interpolate - Get a translation string
 * Interpolate a string that contains variables
 *
 * @param {string} key - The key to lookup in the translation strings
 * @param {object} values - An object of values to interpolate into the string
 * @param {string} externalText - A string to use if no translation is found
 */
function interpolate(key, values, externalText) {
    // Let's throw some errors if we're trying to use keys/locales that don't exist.
    // We could improve this by using Typescript and/or fallback values.
    if (!key)
        throw new Error('No key provided to t()');
    // Grab the text from the translations store.
    const contentObj = get_store_value(stringsStore);
    const string = (contentObj && contentObj[key]) || '';
    let messageDirty = '';
    if (values) {
        // Validate value before interpolation, if any value looks questionable throw error
        valueSchema.parse(values);
        /**
         * Replace any passed in variables in the translation string.
         *
         * Example:
         *
         * string = "{greeting}, World!"
         * values = {
         *    greeting: "Hello"
         * }
         */
        Object.keys(values).map((k) => {
            /**
             * k = greeting
             * regex = /{greeting}/g
             */
            const regex = new RegExp(`{${k}}`, 'g');
            /**
             * values[k] = "Hello"
             * messageDirty = "Hello, World!"
             */
            messageDirty = string.replace(regex, values[k]);
        });
    }
    else {
        messageDirty = string;
    }
    /**
     * If there's no message, then convert the key itself into the message
     */
    if (!messageDirty && !externalText) {
        /**
         * If the key is NOT external, then split at the capital letter
         */
        const textFromKey = key.replace(/([A-Z])/g, ' $1');
        messageDirty = textFromKey.charAt(0).toUpperCase() + textFromKey.slice(1);
    }
    else if (!messageDirty && externalText) {
        /**
         * If no internal message is found, but external content is provided,
         * just return the external text
         */
        messageDirty = externalText;
    }
    const messageClean = sanitize(messageDirty, {
        /**
         * Allow `?` as first char in `href` value for anchor tags.
         * To preserve original behavior in addition to this one exception,
         * return `undefined` for all other cases.
         */
        onTagAttr: function (tag, name, value) {
            if (tag == 'a' && name == 'href') {
                if (value.substr(0, 1) === '?') {
                    return `${name}="${value}"`;
                }
            }
        },
    });
    return messageClean;
}
/**
 * @function textToKey - Takes a human readable string and returns a key from it.
 * This key is used to look up the string in the translation files.
 *
 * If the item is a number, it will be converted to a string and then
 * processed as if it were a string.
 *
 * If the item is a string that contains word characters (`\w`) mixed with
 * non-word characters (`\W`), the non-word characters will be removed and
 * the resulting string will be converted to camelCase.
 *
 * @param {string} text - The text that will be converted to a key.
 * @returns {string} A key that is unique to the given text.
 *
 * Examples:
 * textToKey('hello world') => 'helloWorld'
 * textToKey('HELLO WORLD') => 'helloWorld'
 * textToKey('HELLO WORLD!!!') => 'helloWorld'
 * textToKey('HELLO WORLD!!!') => 'helloWorld'
 * textToKey('helloWorld') => 'helloWorld'
 * textToKey('helloWorld123') => 'helloWorld123'
 * textToKey('hello_world') => 'helloWorld'
 * textToKey('hello-world') => 'helloWorld'
 * textToKey('hello.world') => 'helloWorld'
 */
function textToKey(text) {
    if (typeof text !== 'string' && typeof text !== 'number') {
        throw new Error('Parameter for textToKey function needs to be of type string or number');
    }
    if (typeof text === 'number') {
        text = String(text);
    }
    // If text is entirely uppercase, just lowercase it all
    if (text.match(/^([A-Z]+)$/)) {
        return text.toLowerCase();
    }
    /**
     * If text is entirely uppercase with trailing non-word chars,
     * strip the non-word chars and lowercase the rest
     */
    if (text.match(/^([A-Z]+[\W]*)$/)) {
        return text.replace(/\W/g, '').toLowerCase();
    }
    /**
     * If we have reached here, the text has word chars (`\w`) mixed with
     * non-word chars (`\W`), so we have to do more for proper transform
     */
    const transformedString = text
        // Matches any non-word character followed up by a word or number character
        .replace(/(\W)([\w\d])/g, (_, p1, p2) => {
        if (p1.match(/['’"”]/) && p2.match(/[a-z]/)) {
            return p2;
        }
        if (p1.match(/\W/) && p2.match(/[a-z]/)) {
            return p2.toUpperCase();
        }
        if (p1.match(/\W/) && p2.match(/\d/)) {
            return p2;
        }
        return p2;
    })
        .replace(/(\W)/g, '');
    return transformedString.charAt(0).toLowerCase() + transformedString.slice(1);
}

const authIdTimeoutErrorCode = '110';
const constrainedViolationMessage = 'constraint violation';
/**
 * @function convertStringToKey -
 * @param {string} string
 * @returns {string}
 */
function convertStringToKey(string) {
    if (!string) {
        return '';
    }
    if (string.toLocaleLowerCase().includes('constraint violation')) {
        console.error('Delta Sierra error has occurred. Please communicate this to your system administrator.');
        if (string.toLocaleLowerCase().includes('password')) {
            return 'constraintViolationForPassword';
        }
        return 'constraintViolationForValue';
    }
    const replaceFunction = (_, char) => `${char.toLowerCase()}`;
    const normalizedString = string
        .replace(/^([A-Z])/g, replaceFunction)
        .replace(/\s([a-z])/g, (_, char) => `${char.toUpperCase()}`);
    const key = normalizedString.replace(/\W/g, '');
    return key;
}
/**
 * @function initCheckValidation -
 * @returns {boolean}
 */
function initCheckValidation() {
    let hasPrevError = false;
    return function checkValidation(callback) {
        const failedPolices = callback.getOutputByName('failedPolicies', []);
        if (failedPolices.length && !hasPrevError) {
            hasPrevError = true;
            return true;
        }
        return false;
    };
}
/**
 * @function shouldRedirectFromStep -
 * @returns {boolean}
 */
function shouldRedirectFromStep(step) {
    return step.getCallbacksOfType(l.RedirectCallback).length > 0;
}
/**
 * @function shouldPopulateWithPreviousCallbacks -
 * @param {object} nextStep
 * @param {array} previousCallbacks
 * @param {object} restartedStep
 * @param {number} stepNumber
 * @returns {boolean}
 */
function shouldPopulateWithPreviousCallbacks(nextStep, previousCallbacks, restartedStep, stepNumber) {
    if (!Array.isArray(previousCallbacks)) {
        return false;
    }
    if (restartedStep.type !== r$a.Step) {
        return false;
    }
    if (stepNumber !== 1) {
        return false;
    }
    const details = nextStep.payload.detail;
    const message = nextStep.payload.message?.toLowerCase();
    /**
     * Now that we know we have previous callbacks, this is of type "Step",
     * it has payload detail or payload message, and it's just the first step,
     * we can populate the new step with old callbacks.
     */
    if (details?.errorCode === authIdTimeoutErrorCode ||
        message?.includes(constrainedViolationMessage)) {
        return true;
    }
    // Fallback to false
    return false;
}

const selfSubmittingCallbacks = [
    l.ConfirmationCallback,
    l.DeviceProfileCallback,
    l.PollingWaitCallback,
    l.SelectIdPCallback,
    l.PingOneProtectInitializeCallback,
    l.PingOneProtectEvaluationCallback,
];
const userInputCallbacks = [
    l.BooleanAttributeInputCallback,
    l.ChoiceCallback,
    l.ConfirmationCallback,
    l.KbaCreateCallback,
    l.NameCallback,
    l.NumberAttributeInputCallback,
    l.PasswordCallback,
    l.ReCaptchaCallback,
    l.SelectIdPCallback,
    l.StringAttributeInputCallback,
    l.TermsAndConditionsCallback,
    l.ValidatedCreatePasswordCallback,
    l.ValidatedCreateUsernameCallback,
];
/**
 * @function forceUserInputOptionalityCallbacks - Determines if a callback should be forced to be optional
 */
const forceUserInputOptionalityCallbacks = {
    SelectIdPCallback: (callback) => {
        const selectIdpCb = callback;
        return !!selectIdpCb
            .getProviders()
            .find((provider) => provider.provider === 'localAuthentication');
    },
};
/**
 * @function isCbReadyByDefault - Determines if a callback is ready to be submitted by default
 * @param {object} callback - Generic FRCallback from JavaScript SDK
 * @returns {boolean}
 */
function isCbReadyByDefault(callback) {
    if (callback.getType() === l.ConfirmationCallback) {
        const cb = callback;
        if (cb.getOptions().length === 1) {
            return true;
        }
    }
    return false;
}
/**
 * @function canForceUserInputOptionality
 * @param {object} callback - generic FRCallback from JavaScript SDK
 * @returns
 */
function canForceUserInputOptionality(callback) {
    // See if a callback function exists within this collection
    const fn = forceUserInputOptionalityCallbacks[callback.getType()];
    // If there is a function, run it and it will return a boolean
    return fn ? fn(callback) : false;
}
/**
 * @function isSelfSubmitting -
 * @param {object} callback - generic FRCallback from JavaScript SDK
 * @returns
 */
function isSelfSubmitting(callback) {
    return selfSubmittingCallbacks.includes(callback.getType());
}
/**
 * @function isStepSelfSubmittable -
 * @param {array} callbacks - CallbackMetadata
 * @returns
 */
function isStepSelfSubmittable(callbacks, userInputOptional) {
    if (userInputOptional) {
        return true;
    }
    const unsubmittableCallbacks = callbacks.filter((callback) => callback.derived.isUserInputRequired && !callback.derived.isSelfSubmitting);
    return !unsubmittableCallbacks.length;
}
/**
 * @function requiresUserInput - Determines if a callback requires user input
 * @param  {object} callback - Generic callback provided by JavaScript SDK
 * @returns {boolean}
 */
function requiresUserInput(callback) {
    if (callback.getType() === l.SelectIdPCallback) {
        return false;
    }
    if (callback.getType() === l.ConfirmationCallback) {
        const cb = callback;
        if (cb.getOptions().length === 1) {
            return false;
        }
    }
    return userInputCallbacks.includes(callback.getType());
}
// Notice this function can take a user provided argument function to
// override behavior (this doesn't have to be well defined)
/**
 * @function isUserInputOptional - Determines if user input is optional
 * Notice this function can take a user provided argument function to
 * override behavior (this doesn't have to be well defined)
 * @param {array} callbackMetadataArray - array of callback metadata
 * @param  {number} numOfUserInputCbs - number of user input requiring callbacks
 * @param {function} fn - optional function to override default behavior
 * @returns {boolean} - true if user input is optional
 * @example isUserInputOptional(callbackMetadataArray, numOfUserInputCbs, (prev, curr) => {
 *   if (curr.derived.canForceUserInputOptionality && numOfUserInputCbs > 0) {
 *     prev = true;
 *   }
 *   return prev;
 * })
 * @example isUserInputOptional(callbackMetadataArray, numOfUserInputCbs);
 */
function isUserInputOptional(callbackMetadataArray, numOfUserInputCbs, fn) {
    // default reducer function to check if both overriding callback exists
    // along with user input required callbacks
    const fallbackFn = (prev, curr) => {
        if (curr.derived.canForceUserInputOptionality && numOfUserInputCbs > 0) {
            prev = true;
        }
        return prev;
    };
    // Call reduce function with either fallback or user provided function
    return callbackMetadataArray.reduce(fn || fallbackFn, false);
}

/**
 * @function buildCallbackMetadata - Constructs an array of callback metadata that matches to original callback array
 * @param {object} step - The modified Widget step object
 * @param {function} checkValidation - function that checks if current callback is the first invalid callback
 * @returns {array}
 */
function buildCallbackMetadata(step, checkValidation, stageJson) {
    const callbackCount = {};
    return step?.callbacks.map((callback, idx) => {
        const cb = callback;
        const callbackType = cb.getType();
        let stageCbMetadata;
        if (callbackCount[callbackType]) {
            callbackCount[callbackType] = callbackCount[callbackType] + 1;
        }
        else {
            callbackCount[callbackType] = 1;
        }
        if (stageJson && stageJson[callbackType]) {
            const stageCbArray = stageJson[callbackType];
            stageCbMetadata = stageCbArray[callbackCount[callbackType] - 1];
        }
        return {
            derived: {
                canForceUserInputOptionality: canForceUserInputOptionality(callback),
                isFirstInvalidInput: checkValidation(callback),
                isReadyForSubmission: isCbReadyByDefault(callback),
                isSelfSubmitting: isSelfSubmitting(callback),
                isUserInputRequired: requiresUserInput(callback),
            },
            idx,
            // Only use the `platform` prop if there's metadata to add
            ...(stageCbMetadata && {
                platform: {
                    ...stageCbMetadata,
                },
            }),
        };
    });
}
/**
 * @function buildStepMetadata - Constructs a metadata object that summarizes the step from AM
 * @param {array} callbackMetadataArray - The array returned from buildCallbackMetadata
 * @returns {object}
 */
function buildStepMetadata(callbackMetadataArray, stageJson, stageName) {
    const numOfUserInputCbs = callbackMetadataArray.filter((cb) => !!cb.derived.isUserInputRequired).length;
    const userInputOptional = isUserInputOptional(callbackMetadataArray, numOfUserInputCbs);
    let stageMetadata;
    if (stageJson) {
        stageMetadata = Object.keys(stageJson).reduce((prev, curr) => {
            // Filter out objects or arrays as those are for the callbacks
            if (typeof stageJson[curr] !== 'object') {
                prev[curr] = stageJson[curr];
            }
            return prev;
        }, {});
    }
    return {
        derived: {
            isStepSelfSubmittable: () => isStepSelfSubmittable(callbackMetadataArray, userInputOptional),
            isUserInputOptional: userInputOptional,
            numOfCallbacks: callbackMetadataArray.length,
            numOfSelfSubmittableCbs: callbackMetadataArray.filter((cb) => !!cb.derived.isSelfSubmitting)
                .length,
            numOfUserInputCbs: numOfUserInputCbs,
        },
        // Only use the `platform` prop if there's metadata to add
        ...(stageMetadata && {
            platform: {
                ...stageMetadata,
            },
        }),
        // stageName and stateMetadata are mutually exclusive
        ...(stageName && {
            platform: {
                stageName,
            },
        }),
    };
}

/**
 * @function initializeJourney - Initializes the journey stack for tracking journey switches
 * @param {object} initOptions - The initial options to set
 * @returns {object} - The journey stack store with stack methods
 */
function initializeStack(initOptions) {
    const initialValue = initOptions ? [initOptions] : [];
    const { update, set, subscribe } = writable(initialValue);
    // Assign to exported variable (see bottom of file)
    stack = {
        latest: async () => {
            return new Promise((resolve) => {
                // subscribe, grab the current value and unsubscribe
                subscribe((current) => {
                    const lastItem = current[current.length - 1];
                    resolve(lastItem);
                })();
            });
        },
        pop: async () => {
            return new Promise((resolve) => {
                update((current) => {
                    let state;
                    if (current.length) {
                        state = current.slice(0, -1);
                    }
                    else {
                        state = current;
                    }
                    resolve([...state]);
                    return state;
                });
            });
        },
        push: async (options) => {
            return new Promise((resolve) => {
                update((current) => {
                    let state;
                    if (!current.length) {
                        state = [{ ...options }];
                    }
                    else if (options && options?.tree !== current[current.length - 1]?.tree) {
                        state = [...current, options];
                    }
                    else {
                        state = current;
                    }
                    resolve([...state]);
                    return state;
                });
            });
        },
        reset: () => {
            set([]);
        },
        subscribe,
    };
    return stack;
}
const journeyStore = writable({
    completed: false,
    error: null,
    loading: false,
    metadata: null,
    step: null,
    successful: false,
    response: null,
    recaptchaAction: null,
});
/**
 * @function initialize - Initializes the journey store
 * @param {object} initOptions - The initial options to set
 * @returns {object} - The journey store
 */
function initialize$4(initOptions) {
    const stack = initializeStack();
    let stepNumber = 0;
    async function next(prevStep, nextOptions, resumeUrl) {
        if (!c$3.get().serverConfig?.baseUrl) {
            logErrorAndThrow('missingBaseUrl');
        }
        /**
         * Create an options object with nextOptions overriding anything from initOptions
         * TODO: Does this object merge need to be more granular?
         */
        const options = {
            ...initOptions,
            ...nextOptions,
        };
        /**
         * Save previous step information just in case we have a total
         * form failure due to 400 response from ForgeRock.
         */
        let previousCallbacks;
        if (prevStep && prevStep.type === r$a.Step) {
            previousCallbacks = prevStep?.callbacks;
        }
        const previousPayload = prevStep?.payload;
        let nextStep;
        journeyStore.set({
            completed: false,
            error: null,
            loading: true,
            metadata: get_store_value(journeyStore).metadata,
            step: prevStep,
            successful: false,
            response: null,
            recaptchaAction: nextOptions?.recaptchaAction,
        });
        try {
            if (resumeUrl) {
                // If resuming an unknown journey remove the tree from the options
                options.tree = undefined;
                /**
                 * Attempt to resume journey
                 */
                nextStep = await f$1.resume(resumeUrl, options);
            }
            else if (prevStep) {
                // If continuing on a tree remove it from the options
                options.tree = undefined;
                /**
                 * Initial attempt to retrieve next step
                 */
                nextStep = await f$1.next(prevStep, options);
            }
            else {
                nextStep = await f$1.start(options);
            }
        }
        catch (err) {
            console.error(`Next step request | ${err}`);
            /**
             * Setup an object to display failure message
             */
            nextStep = new i$9({
                message: interpolate('unknownNetworkError'),
            });
        }
        if (nextStep.type === r$a.Step) {
            const stageAttribute = nextStep.getStage();
            let stageJson = null;
            let stageName = null;
            // Check if stage attribute is serialized JSON
            if (stageAttribute && stageAttribute.includes('{')) {
                try {
                    stageJson = JSON.parse(stageAttribute);
                }
                catch (err) {
                    console.warn('Stage attribute value was not parsable');
                }
            }
            else if (stageAttribute) {
                stageName = stageAttribute;
            }
            const callbackMetadata = buildCallbackMetadata(nextStep, initCheckValidation(), stageJson);
            const stepMetadata = buildStepMetadata(callbackMetadata, stageJson, stageName);
            // Iterate on a successful progression
            stepNumber = stepNumber + 1;
            journeyStore.set({
                completed: false,
                error: null,
                loading: false,
                metadata: {
                    callbacks: callbackMetadata,
                    step: stepMetadata,
                },
                step: nextStep,
                successful: false,
                response: null,
                recaptchaAction: nextOptions?.recaptchaAction,
            });
        }
        else if (nextStep.type === r$a.LoginSuccess) {
            /**
             * SUCCESSFUL COMPLETION BLOCK
             */
            stack.reset();
            // Set final state
            journeyStore.set({
                completed: true,
                error: null,
                loading: false,
                metadata: null,
                step: null,
                successful: true,
                response: nextStep.payload,
                recaptchaAction: nextOptions?.recaptchaAction,
            });
        }
        else if (nextStep.type === r$a.LoginFailure) {
            /**
             * FAILURE COMPLETION BLOCK
             *
             * Grab failure message, which may contain encoded HTML
             */
            const failureMessageStr = htmlDecode(nextStep.payload.message || 'Unknown login error');
            let restartedStep = null;
            try {
                /**
                 * Restart tree to get fresh step
                 */
                const restartOptions = await stack.latest();
                restartedStep = await f$1.next(undefined, restartOptions);
            }
            catch (err) {
                console.error(`Restart failed step request | ${err}`);
                /**
                 * Setup an object to display failure message
                 */
                restartedStep = new i$9({
                    message: interpolate('unknownNetworkError'),
                });
            }
            /**
             * Now that we have a new authId (the identification of the
             * fresh step) let's populate this new step with old callback data if
             * this is step one and meets a few criteria.
             *
             * If error code is 110 or error message includes "Constrained Violation",
             * then the issue needs special handling.
             *
             * If this is the first step in the journey, replace the callbacks with
             * existing callbacks to resubmit with a fresh authId.
             ******************************************************************* */
            if (shouldPopulateWithPreviousCallbacks(nextStep, previousCallbacks, restartedStep, stepNumber)) {
                /**
                 * TypeScript notes:
                 *
                 * Assert that restartedStep is FRStep as that is required for the above condition to be true.
                 * Also, assert that previousCallbacks is FRCallback[] as that too is required for above to be true.
                 *
                 * Attempt a refactor using Ryan's suggestion found here: https://www.typescriptlang.org/play?#code/PTAEHUFMBsGMHsC2lQBd5oBYoCoE8AHSAZVgCcBLA1UABWgEM8BzM+AVwDsATAGiwoBnUENANQAd0gAjQRVSQAUCEmYKsTKGYUAbpGF4OY0BoadYKdJMoL+gzAzIoz3UNEiPOofEVKVqAHSKymAAmkYI7NCuqGqcANag8ABmIjQUXrFOKBJMggBcISGgoAC0oACCbvCwDKgU8JkY7p7ehCTkVDQS2E6gnPCxGcwmZqDSTgzxxWWVoASMFmgYkAAeRJTInN3ymj4d-jSCeNsMq-wuoPaOltigAKoASgAywhK7SbGQZIIz5VWCFzSeCrZagNYbChbHaxUDcCjJZLfSDbExIAgUdxkUBIursJzCFJtXydajBZJcWD1RqgJyofGcABqDGg7EgAB4cAA+AAUq3y3nBqwUPGEglQlE4IwA-FcJcNQALOOxENJvgBKUAAb0UJT1CNAPNQ7SJoIAvBbQAAiZWq75WzV0hmgUG6vXg6CCFBOsheVZukoB0CKAC+incNCGUtAZtpkHpvuZrI54slzF5VoAjA6ANzkynUrxCYjyqV8gWphUAH36KrVZHVAuB8BaXh17oNRpNqXNloA5JWpX3Ne33XqfZkyGy8+6w0GJziWV683PO8XS8wjXFmOqR0Go8wAhlYKzuPoeVbsNBoPBc6HgiocM0PL7QIh4H0GMD2JG7owpewDDMJA-AnuoiRfvAegiF4VoAKKrAwiALPoVpJNiVrgA4qADqAABykASFaQQqAA8l8ZDvF6-DAUcqCOAorjSHgcbvjoCpfF6aKINCwiXF8kgftEIgGBw2ILEwrAcDwQQlEAA
                 */
                restartedStep = restartedStep;
                // Rebuild callbacks onto restartedStep
                restartedStep.callbacks = previousCallbacks;
                // Rebuild payload onto restartedStep ensuring the use of the NEW authId
                restartedStep.payload = {
                    ...previousPayload,
                    authId: restartedStep.payload.authId,
                };
                const details = nextStep.payload.detail;
                /**
                 * Only if the authId expires do we resubmit with same callback values
                 */
                if (details?.errorCode === authIdTimeoutErrorCode) {
                    restartedStep = await f$1.next(restartedStep, options);
                }
            }
            /**
             * SET RESULT OF SUBSEQUENT REQUEST
             *
             * After the above attempts to salvage the form submission, let's return
             * the final result to the user.
             */
            if (restartedStep.type === r$a.Step) {
                const stageAttribute = restartedStep.getStage();
                let stageJson = null;
                let stageName = null;
                // Check if stage attribute is serialized JSON
                if (stageAttribute && stageAttribute.includes('{')) {
                    try {
                        stageJson = JSON.parse(stageAttribute);
                    }
                    catch (err) {
                        console.warn('Stage attribute value was not parsable');
                    }
                }
                else if (stageAttribute) {
                    stageName = stageAttribute;
                }
                const callbackMetadata = buildCallbackMetadata(restartedStep, initCheckValidation(), stageJson);
                const stepMetadata = buildStepMetadata(callbackMetadata, stageJson, stageName);
                journeyStore.set({
                    completed: false,
                    error: {
                        code: nextStep.getCode(),
                        message: failureMessageStr,
                        stage: prevStep?.payload?.stage,
                        troubleshoot: null,
                    },
                    loading: false,
                    metadata: {
                        callbacks: callbackMetadata,
                        step: stepMetadata,
                    },
                    step: restartedStep,
                    successful: false,
                    response: null,
                    recaptchaAction: null,
                });
            }
            else if (restartedStep.type === r$a.LoginSuccess) {
                journeyStore.set({
                    completed: true,
                    error: null,
                    loading: false,
                    metadata: null,
                    step: null,
                    successful: true,
                    response: restartedStep.payload,
                    recaptchaAction: null,
                });
            }
            else {
                journeyStore.set({
                    completed: true,
                    error: {
                        code: nextStep.getCode(),
                        message: failureMessageStr,
                        stage: prevStep?.payload?.stage,
                        troubleshoot: null,
                    },
                    loading: false,
                    metadata: null,
                    step: null,
                    successful: false,
                    response: restartedStep.payload,
                    recaptchaAction: null,
                });
            }
        }
    }
    async function pop() {
        reset();
        const updatedStack = await stack.pop();
        const currentJourney = updatedStack[updatedStack.length - 1];
        await start(currentJourney);
    }
    async function push(newOptions) {
        reset();
        await stack.push(newOptions);
        await start(newOptions);
    }
    async function resume(url, resumeOptions) {
        await next(undefined, resumeOptions, url);
    }
    async function start(startOptions) {
        const configTree = c$3.get().tree;
        // If no tree is passed in, but there's a configured default tree, use that
        if (!startOptions?.tree && configTree) {
            if (startOptions) {
                startOptions.tree = configTree;
            }
            else {
                startOptions = {
                    tree: configTree,
                };
            }
        }
        if (!startOptions?.recaptchaAction && startOptions?.tree) {
            startOptions.recaptchaAction = startOptions.tree;
        }
        await stack.push(startOptions);
        await next(undefined, startOptions);
    }
    function reset() {
        journeyStore.set({
            completed: false,
            error: null,
            loading: false,
            metadata: null,
            step: null,
            successful: false,
            response: null,
            recaptchaAction: null,
        });
    }
    return {
        next,
        pop,
        push,
        reset,
        resume,
        start,
        subscribe: journeyStore.subscribe,
    };
}
let stack;

const linksSchema = z
    .object({
    termsAndConditions: z.string(),
})
    .strict();
linksSchema.partial();
const linksStore = writable();
/**
 * @function initialize - Initialize the links store
 * @param {object} customLinks - An object of custom links to merge with the default
 * @returns {object} - The links store
 * @example initialize({ termsAndConditions: 'https://example.com/terms' });
 */
function initialize$3(customLinks) {
    // If customLinks is provided, provide feedback for object
    if (customLinks) {
        // Provide developer feedback for custom links
        linksSchema.parse(customLinks);
        linksStore.set(customLinks);
    }
    else {
        linksStore.set(undefined);
    }
    return linksStore;
}

const authorizationTimedOut = 'Authorization timed out';
const interactionNeeded = 'The request requires some interaction that is not allowed.';
const timeoutErrorMessage = 'Timeouts are likely an issue with OAuth client misconfiguration. If you are getting a 4xx error in the network tab, copy the full `/authorize` URL and paste it directly into your browsers URL field to directly visit the page. The error should be displayed on the page.';
const sessionCookieConsentMessage = `The user either doesn't have a valid session, the cookie is not being sent due to third-party cookies being disabled, or the user is needing to provide consent as the OAuth client setting does not have "implied consent" enabled.`;
const oauthStore = writable({
    completed: false,
    error: null,
    loading: false,
    successful: false,
    response: null,
});
function getTroubleshootingMessage(message) {
    switch (message) {
        case interactionNeeded:
            return sessionCookieConsentMessage;
        case authorizationTimedOut:
            return timeoutErrorMessage;
        default:
            return '';
    }
}
/**
 * @function initialize - Initializes the OAuth store with a get function and a reset function
 * @param {object} initOptions - The options to pass to the TokenManager.getTokens function
 * @returns {object} - The OAuth store
 * @example initialize({ query: { prompt: 'none' } });
 */
function initialize$2(initOptions) {
    /**
     * Get tokens from the server
     * new tokens are available in the subscribe method
     * @params: getOptions?: GetTokensOptions
     * @returns: Promise<void>
     */
    async function get(getOptions) {
        /**
         * Create an options object with getOptions overriding anything from initOptions
         * TODO: Does this object merge need to be more granular?
         */
        const options = {
            ...{ query: { prompt: 'none' } },
            ...initOptions,
            ...getOptions,
        };
        let tokens;
        oauthStore.set({
            completed: false,
            error: null,
            loading: true,
            successful: false,
            response: null,
        });
        try {
            tokens = await T$2.getTokens(options);
        }
        catch (err) {
            if (err instanceof Error) {
                oauthStore.set({
                    completed: true,
                    error: {
                        message: err.message,
                        troubleshoot: getTroubleshootingMessage(err.message),
                    },
                    loading: false,
                    successful: false,
                    response: null,
                });
            }
            return;
        }
        oauthStore.set({
            completed: true,
            error: null,
            loading: false,
            successful: true,
            response: tokens,
        });
    }
    function reset() {
        oauthStore.set({
            completed: false,
            error: null,
            loading: false,
            successful: false,
            response: null,
        });
    }
    return {
        get,
        reset,
        subscribe: oauthStore.subscribe,
    };
}

const userStore = writable({
    completed: false,
    error: null,
    loading: false,
    successful: false,
    response: null,
});
/**
 * @function initialize - Initializes the user store with a get function and a reset function
 * @param {object} initOptions - The options to pass to the UserManager.getCurrentUser function
 * @returns {object} - The user store
 */
function initialize$1(initOptions) {
    /**
     * Get user info from the server
     * New state is returned in your `userEvents.subscribe` callback function
     * @params: getOptions?: ConfigOptions
     * @returns: Promise<void>
     */
    async function get(getOptions) {
        /**
         * Create an options object with getOptions overriding anything from initOptions
         * TODO: Does this object merge need to be more granular?
         */
        const options = {
            ...initOptions,
            ...getOptions,
        };
        userStore.set({
            completed: false,
            error: null,
            loading: true,
            successful: false,
            response: null,
        });
        try {
            const user = await a.getCurrentUser(options);
            userStore.set({
                completed: true,
                error: null,
                loading: false,
                successful: true,
                response: user,
            });
        }
        catch (err) {
            if (err instanceof Error) {
                userStore.set({
                    completed: true,
                    error: {
                        message: err.message,
                        troubleshoot: null,
                    },
                    loading: false,
                    successful: false,
                    response: null,
                });
            }
        }
    }
    function reset() {
        userStore.set({
            completed: false,
            error: null,
            loading: false,
            successful: false,
            response: null,
        });
    }
    return {
        get,
        reset,
        subscribe: userStore.subscribe,
    };
}

const logoSchema = z
    .object({
    dark: z.string().optional(),
    height: z.number().optional(),
    light: z.string().optional(),
    width: z.number().optional(),
})
    .strict();
const styleSchema = z
    .object({
    checksAndRadios: z.union([z.literal('animated'), z.literal('standard')]).optional(),
    labels: z.union([z.literal('floating').optional(), z.literal('stacked')]).optional(),
    showPassword: z
        .union([z.literal('none'), z.literal('button'), z.literal('checkbox')])
        .optional(),
    logo: logoSchema.optional(),
    sections: z
        .object({
        header: z.boolean().optional(),
    })
        .strict()
        .optional(),
    stage: z
        .object({
        icon: z.boolean().optional(),
    })
        .strict()
        .optional(),
})
    .strict();
styleSchema.partial();
const fallbackStyles = {
    checksAndRadios: 'animated',
    labels: 'floating',
    showPassword: 'button',
    logo: undefined,
    sections: undefined,
    stage: undefined,
};
const styleStore = writable(fallbackStyles);
/**
 * @function initialize - Initialize the style store
 * @param {object} customStyle - An object of custom styles to merge with the default
 * @returns {object} - The style store
 * @example initialize({ checksAndRadios: 'standard' });
 */
function initialize(customStyle) {
    if (customStyle) {
        /*
          Helper function to safely assign keys to strict object
         */
        const accessStrictType = (str) => {
            return customStyle[str];
        };
        const newStyleConfig = Object.keys(customStyle).reduce((acc, key) => {
            if (accessStrictType(key) === undefined ||
                accessStrictType(key) === null) {
                return acc;
            }
            return { ...acc, [key]: accessStrictType(key) };
        }, fallbackStyles);
        styleStore.set(newStyleConfig);
    }
    else {
        styleStore.set(fallbackStyles);
    }
    return styleStore;
}

/**
 * @function widgetApiFactory - Creates the widget API
 * @param {object} componentApi - The component API
 * @returns {object} - The widget API
 * @property {object} componentApi - The component API for either inline or modal
 * @property {object} configuration - Sets the configuration for the widget
 * @property {function} getStores - Returns the stores: journeyStore, oauthStore, userStore
 * @property {object} journey - the journey API
 * @property {function} request - The HttpClient.request function from the SDK
 * @property {object} user - the user API
 */
function widgetApiFactory(componentApi) {
    let journeyStore;
    let oauthStore;
    let userStore;
    function getStores() {
        return {
            journeyStore,
            oauthStore,
            userStore,
        };
    }
    function resetAndRestartStores() {
        // Reset stores
        journeyStore.reset();
        oauthStore.reset();
        userStore.reset();
    }
    const configuration = (options) => {
        if (options?.forgerock) {
            configure({
                // Set some basics by default
                ...{
                    // TODO: Could this be a default OAuth client provided by Platform UI OOTB?
                    clientId: 'WebLoginWidgetClient',
                    // TODO: If a realmPath is not provided, should we call the realm endpoint and detect a likely default?
                    // https://backstage.forgerock.com/docs/am/7/setup-guide/sec-rest-realm-rest.html#rest-api-list-realm
                    realmPath: 'alpha',
                    // TODO: Once we move to SSR, this default should be more intelligent
                    redirectUri: typeof window === 'object'
                        ? // Construct URL with origin and path only, stripping off hash and query params
                            `${window.location.origin}${window.location.pathname}`
                        : 'https://localhost:3000/callback',
                    scope: 'openid email',
                },
                // Let user provided config override defaults
                ...options?.forgerock,
                // Force 'legacy' to remove confusion
                ...{ support: 'legacy' },
            });
        }
        /**
         * Initialize all the stores.
         */
        journeyStore = initialize$4(options?.forgerock);
        oauthStore = initialize$2(options?.forgerock);
        userStore = initialize$1(options?.forgerock);
        initialize$5(options?.content);
        initialize$6(options?.journeys);
        initialize$3(options?.links);
        initialize(options?.style);
        return {
            /** Set the Login Widget's Configuration
             * @param {WidgetConfigOptions} options - The configuration options for the Login Widget
             * @returns {void}
             **/
            set(setOptions) {
                if (setOptions?.forgerock) {
                    configure({
                        // Set some basics by default
                        ...{
                            // TODO: Could this be a default OAuth client provided by Platform UI OOTB?
                            clientId: 'WebLoginWidgetClient',
                            // TODO: If a realmPath is not provided, should we call the realm endpoint and detect a likely default?
                            // https://backstage.forgerock.com/docs/am/7/setup-guide/sec-rest-realm-rest.html#rest-api-list-realm
                            realmPath: 'alpha',
                            // TODO: Once we move to SSR, this default should be more intelligent
                            redirectUri: typeof window === 'object'
                                ? window.location.href
                                : 'https://localhost:3000/callback',
                            scope: 'openid email',
                        },
                        // Let user provided config override defaults
                        ...setOptions?.forgerock,
                        // Force 'legacy' to remove confusion
                        ...{ support: 'legacy' },
                    });
                }
                /**
                 * Initialize the stores and ensure both variables point to the same reference.
                 * Variables with _ are the reactive version of the original variable from above.
                 */
                journeyStore = initialize$4(setOptions?.forgerock);
                oauthStore = initialize$2(setOptions?.forgerock);
                userStore = initialize$1(setOptions?.forgerock);
                initialize$5(setOptions?.content);
                initialize$6(setOptions?.journeys);
                initialize$3(setOptions?.links);
                initialize(setOptions?.style);
            },
        };
    };
    const journey = (options) => {
        if (!journeyStore || !oauthStore || !userStore) {
            logErrorAndThrow('missingStores');
        }
        const requestsOauth = options?.oauth ?? true;
        const requestsUser = options?.user ?? true;
        const { subscribe, } = derived([journeyStore, oauthStore, userStore], ([$journeyStore, $oauthStore, $userStore], set) => {
            set({
                journey: $journeyStore,
                oauth: $oauthStore,
                user: $userStore,
            });
            if ($oauthStore.error || $userStore.error) {
                // If we get any errors from the stores, close the modal
                formFactor === 'modal' && componentApi.close({ reason: 'auto' });
            }
            if ($journeyStore.successful && $oauthStore.successful && $userStore.completed) {
                formFactor === 'modal' && componentApi.close({ reason: 'auto' });
            }
            else if ($journeyStore.successful && $oauthStore.successful) {
                if (requestsUser && $userStore.loading === false && $userStore.completed === false) {
                    userStore.get();
                }
                else if (!requestsUser) {
                    formFactor === 'modal' && componentApi.close({ reason: 'auto' });
                }
            }
            else if ($journeyStore.successful) {
                if (requestsOauth && $oauthStore.loading === false && $oauthStore.completed === false) {
                    oauthStore.get();
                }
                else if (!requestsOauth) {
                    formFactor === 'modal' && componentApi.close({ reason: 'auto' });
                }
            }
        });
        // Create a simple reference to prevent repeated subscribing and unsubscribing
        let formFactor = null;
        function change(changeOptions) {
            return start(changeOptions);
        }
        function start(startOptions) {
            // If starting a journey, let's reset the stores in case they had previous state
            oauthStore.reset();
            userStore.reset();
            // Grab the form factor and cache it
            formFactor = get_store_value(componentStore).type;
            if (startOptions?.resumeUrl) {
                journeyStore.resume(startOptions.resumeUrl);
            }
            else {
                journeyStore.start({
                    recaptchaAction: startOptions?.recaptchaAction,
                    ...startOptions?.forgerock,
                    // Only include a `tree` property if the `journey` options prop is truthy
                    ...(startOptions?.journey && { tree: startOptions?.journey }),
                });
            }
            return new Promise((resolve, reject) => {
                const unsubscribe = subscribe((event) => {
                    if (event.oauth.error || event.user.error) {
                        reject(event);
                        unsubscribe();
                    }
                    if (event.journey.successful && event.oauth.successful && event.user.completed) {
                        resolve(event);
                        unsubscribe();
                    }
                    else if (event.journey.successful && event.oauth.successful) {
                        if (!requestsUser) {
                            resolve(event);
                            unsubscribe();
                        }
                    }
                    else if (event.journey.successful) {
                        if (!requestsOauth) {
                            resolve(event);
                            unsubscribe();
                        }
                    }
                });
            });
        }
        return { change, start, subscribe };
    };
    const user = {
        /**
         * User Info
         * @param: void
         * @returns: UserStore
         */
        info() {
            if (!journeyStore || !oauthStore || !userStore) {
                logErrorAndThrow('missingStores');
            }
            const { get, subscribe } = userStore;
            function wrappedGet(options) {
                get(options);
                return new Promise((resolve, reject) => {
                    const unsubscribe = userStore.subscribe((event) => {
                        if (event.successful) {
                            resolve(event);
                            unsubscribe();
                        }
                        else if (event.error) {
                            reject(event);
                            unsubscribe();
                        }
                    });
                });
            }
            return { get: wrappedGet, subscribe };
        },
        /**
         * Logout a user from an AM Session
         * @async
         * @param: void
         * @returns: Promise<void>
         **/
        async logout() {
            if (!journeyStore || !oauthStore || !userStore) {
                logErrorAndThrow('missingStores');
            }
            const { clientId } = c$3.get();
            let obj;
            /**
             * If configuration has a clientId, then use FRUser to logout to ensure
             * token revoking and removal; else, just end the session.
             */
            if (clientId) {
                obj = k;
            }
            else {
                obj = M$1;
            }
            try {
                await obj.logout();
                resetAndRestartStores();
            }
            catch (err) {
                // Regardless of errors, reset all stores and restart journey
                resetAndRestartStores();
                throw err;
            }
            // Return undefined as there's no response information to share
            return;
        },
        /**
         * Returns the widget's Tokens object
         * @param void;
         * @returns OAuthStore
         */
        tokens() {
            if (!journeyStore || !oauthStore || !userStore) {
                logErrorAndThrow('missingStores');
            }
            const { get, subscribe } = oauthStore;
            function wrappedGet(options) {
                get(options);
                return new Promise((resolve, reject) => {
                    const unsubscribe = oauthStore.subscribe((event) => {
                        if (event.successful) {
                            resolve(event);
                            unsubscribe();
                        }
                        else if (event.error) {
                            reject(event);
                            unsubscribe();
                        }
                    });
                });
            }
            return { get: wrappedGet, subscribe };
        },
    };
    const protect = {
        async start(options) {
            try {
                await e.start(options);
            }
            catch (err) {
                console.error('[SignalsSDK] failed to start.', err);
            }
        },
        pauseBehavioralData() {
            try {
                return e.pauseBehavioralData();
            }
            catch (err) {
                console.error('[SignalsSDK] failed to pause behavioral data collection.', err);
            }
        },
        resumeBehavioralData() {
            try {
                return e.resumeBehavioralData();
            }
            catch (err) {
                console.error('[SignalsSDK] failed to resume behavioral data collection.', err);
            }
        },
        async getData() {
            try {
                const token = await e.getData();
                return token;
            }
            catch (err) {
                console.error('[SignalsSDK] failed to get data.', err);
            }
        },
    };
    return {
        component: componentApi,
        configuration,
        getStores,
        journey,
        protect,
        request: D.request.bind(D),
        user,
    };
}

/* src/lib/components/_utilities/locale-strings.svelte generated by Svelte v3.55.1 */

function create_else_block$d(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	const default_slot_or_fallback = default_slot || fallback_block_1$1(ctx);

	return {
		c() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*message*/ 2)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (11:0) {#if html}
function create_if_block$x(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

	return {
		c() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*message*/ 2)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (14:8) {message}
function fallback_block_1$1(ctx) {
	let t;

	return {
		c() {
			t = text(/*message*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*message*/ 2) set_data(t, /*message*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (12:8) {@html message}
function fallback_block$2(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*message*/ ctx[1], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*message*/ 2) html_tag.p(/*message*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

function create_fragment$1a(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$x, create_else_block$d];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*html*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1c($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { html = false } = $$props;
	let { key } = $$props;
	let { values = undefined } = $$props;
	let message;

	$$self.$$set = $$props => {
		if ('html' in $$props) $$invalidate(0, html = $$props.html);
		if ('key' in $$props) $$invalidate(2, key = $$props.key);
		if ('values' in $$props) $$invalidate(3, values = $$props.values);
		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*key, values*/ 12) {
			{
				$$invalidate(1, message = interpolate(key, values));
			}
		}
	};

	return [html, message, key, values, $$scope, slots];
}

class Locale_strings extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1c, create_fragment$1a, safe_not_equal, { html: 0, key: 2, values: 3 });
	}
}

/* src/lib/components/icons/x-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$19(ctx) {
	let svg;
	let path;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path, "d", "M 7 4 C 6.744125 4 6.4879687 4.0974687 6.2929688 4.2929688 L 4.2929688 6.2929688 C 3.9019687 6.6839688 3.9019687 7.3170313 4.2929688 7.7070312 L 11.585938 15 L 4.2929688 22.292969 C 3.9019687 22.683969 3.9019687 23.317031 4.2929688 23.707031 L 6.2929688 25.707031 C 6.6839688 26.098031 7.3170313 26.098031 7.7070312 25.707031 L 15 18.414062 L 22.292969 25.707031 C 22.682969 26.098031 23.317031 26.098031 23.707031 25.707031 L 25.707031 23.707031 C 26.098031 23.316031 26.098031 22.682969 25.707031 22.292969 L 18.414062 15 L 25.707031 7.7070312 C 26.098031 7.3170312 26.098031 6.6829688 25.707031 6.2929688 L 23.707031 4.2929688 C 23.316031 3.9019687 22.682969 3.9019687 22.292969 4.2929688 L 15 11.585938 L 7.7070312 4.2929688 C 7.5115312 4.0974687 7.255875 4 7 4 z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 30 30");
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class X_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1b, create_fragment$19, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/components/compositions/dialog/dialog.svelte generated by Svelte v3.55.1 */

function create_else_block$c(ctx) {
	let div;
	let button;
	let xicon;
	let t;
	let div_class_value;
	let current;
	let mounted;
	let dispose;

	xicon = new X_icon({
			props: {
				classes: "tw_inline-block tw_fill-current tw_text-secondary-dark dark:tw_text-secondary-light",
				$$slots: { default: [create_default_slot_1$i] },
				$$scope: { ctx }
			}
		});

	let if_block = /*$styleStore*/ ctx[5]?.logo && create_if_block_1$h(ctx);

	return {
		c() {
			div = element("div");
			button = element("button");
			create_component(xicon.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr(button, "class", "tw_dialog-x md:tw_dialog-x_medium tw_focusable-element dark:tw_focusable-element_dark");
			attr(button, "aria-controls", /*dialogId*/ ctx[1]);

			attr(div, "class", div_class_value = `tw_pt-10 md:tw_pt-10 tw_text-right ${(/*$styleStore*/ ctx[5]?.logo)
			? 'tw_h-32 md:tw_h-36 tw_pb-6'
			: ''}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button);
			mount_component(xicon, button, null);
			append(div, t);
			if (if_block) if_block.m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_1*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const xicon_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				xicon_changes.$$scope = { dirty, ctx };
			}

			xicon.$set(xicon_changes);

			if (!current || dirty & /*dialogId*/ 2) {
				attr(button, "aria-controls", /*dialogId*/ ctx[1]);
			}

			if (/*$styleStore*/ ctx[5]?.logo) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$h(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*$styleStore*/ 32 && div_class_value !== (div_class_value = `tw_pt-10 md:tw_pt-10 tw_text-right ${(/*$styleStore*/ ctx[5]?.logo)
			? 'tw_h-32 md:tw_h-36 tw_pb-6'
			: ''}`)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(xicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(xicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(xicon);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (39:2) {#if withHeader}
function create_if_block$w(ctx) {
	let div1;
	let div0;
	let div0_style_value;
	let t;
	let button;
	let xicon;
	let current;
	let mounted;
	let dispose;

	xicon = new X_icon({
			props: {
				classes: "tw_inline-block tw_fill-current tw_text-secondary-dark dark:tw_text-secondary-light",
				$$slots: { default: [create_default_slot$w] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			button = element("button");
			create_component(xicon.$$.fragment);
			attr(div0, "class", "tw_dialog-logo dark:tw_dialog-logo_dark");

			attr(div0, "style", div0_style_value = `--logo-dark: url("${/*$styleStore*/ ctx[5]?.logo?.dark}"); --logo-light: url("${/*$styleStore*/ ctx[5]?.logo?.light}"); ${(/*$styleStore*/ ctx[5]?.logo?.height)
			? `height: ${/*$styleStore*/ ctx[5]?.logo.height}px;`
			: ''} ${(/*$styleStore*/ ctx[5]?.logo?.width)
			? `width: ${/*$styleStore*/ ctx[5]?.logo.width}px;`
			: ''}`);

			attr(button, "class", "tw_dialog-x md:tw_dialog-x_medium tw_focusable-element dark:tw_focusable-element_dark");
			attr(button, "aria-controls", /*dialogId*/ ctx[1]);
			attr(button, "aria-label", "Close");
			attr(div1, "class", "tw_dialog-header dark:tw_dialog-header_dark");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div1, t);
			append(div1, button);
			mount_component(xicon, button, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty & /*$styleStore*/ 32 && div0_style_value !== (div0_style_value = `--logo-dark: url("${/*$styleStore*/ ctx[5]?.logo?.dark}"); --logo-light: url("${/*$styleStore*/ ctx[5]?.logo?.light}"); ${(/*$styleStore*/ ctx[5]?.logo?.height)
			? `height: ${/*$styleStore*/ ctx[5]?.logo.height}px;`
			: ''} ${(/*$styleStore*/ ctx[5]?.logo?.width)
			? `width: ${/*$styleStore*/ ctx[5]?.logo.width}px;`
			: ''}`)) {
				attr(div0, "style", div0_style_value);
			}

			const xicon_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				xicon_changes.$$scope = { dirty, ctx };
			}

			xicon.$set(xicon_changes);

			if (!current || dirty & /*dialogId*/ 2) {
				attr(button, "aria-controls", /*dialogId*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(xicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(xicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(xicon);
			mounted = false;
			dispose();
		}
	};
}

// (72:8) <XIcon           classes="tw_inline-block tw_fill-current tw_text-secondary-dark dark:tw_text-secondary-light"           >
function create_default_slot_1$i(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "closeModal" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (77:6) {#if $styleStore?.logo}
function create_if_block_1$h(ctx) {
	let div;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", "tw_dialog-logo dark:tw_dialog-logo_dark");
			attr(div, "style", div_style_value = `--logo-dark: url("${/*$styleStore*/ ctx[5]?.logo?.dark}"); --logo-light: url("${/*$styleStore*/ ctx[5]?.logo?.light}")`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$styleStore*/ 32 && div_style_value !== (div_style_value = `--logo-dark: url("${/*$styleStore*/ ctx[5]?.logo?.dark}"); --logo-light: url("${/*$styleStore*/ ctx[5]?.logo?.light}")`)) {
				attr(div, "style", div_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (55:8) <XIcon           classes="tw_inline-block tw_fill-current tw_text-secondary-dark dark:tw_text-secondary-light"           >
function create_default_slot$w(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "closeModal" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

function create_fragment$18(ctx) {
	let dialog;
	let current_block_type_index;
	let if_block;
	let t;
	let div;
	let dialog_class_value;
	let current;
	const if_block_creators = [create_if_block$w, create_else_block$c];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*withHeader*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	return {
		c() {
			dialog = element("dialog");
			if_block.c();
			t = space();
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "tw_dialog-body");
			attr(dialog, "id", /*dialogId*/ ctx[1]);
			attr(dialog, "class", dialog_class_value = `tw_dialog-box dark:tw_dialog-box_dark md:tw_dialog-box_medium ${/*forceOpen*/ ctx[2] ? '' : 'tw_dialog-box_animate'}`);
			dialog.open = /*forceOpen*/ ctx[2];
		},
		m(target, anchor) {
			insert(target, dialog, anchor);
			if_blocks[current_block_type_index].m(dialog, null);
			append(dialog, t);
			append(dialog, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*dialog_binding*/ ctx[9](dialog);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(dialog, t);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*dialogId*/ 2) {
				attr(dialog, "id", /*dialogId*/ ctx[1]);
			}

			if (!current || dirty & /*forceOpen*/ 4 && dialog_class_value !== (dialog_class_value = `tw_dialog-box dark:tw_dialog-box_dark md:tw_dialog-box_medium ${/*forceOpen*/ ctx[2] ? '' : 'tw_dialog-box_animate'}`)) {
				attr(dialog, "class", dialog_class_value);
			}

			if (!current || dirty & /*forceOpen*/ 4) {
				dialog.open = /*forceOpen*/ ctx[2];
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(dialog);
			if_blocks[current_block_type_index].d();
			if (default_slot) default_slot.d(detaching);
			/*dialog_binding*/ ctx[9](null);
		}
	};
}

function instance$1a($$self, $$props, $$invalidate) {
	let $styleStore;
	component_subscribe($$self, styleStore, $$value => $$invalidate(5, $styleStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let { dialogEl = null } = $$props;
	let { dialogId } = $$props;
	let { forceOpen = false } = $$props;
	let { withHeader = false } = $$props;

	function closeDialog(reason) {
		function completeClose() {
			dialogEl?.close();
			dialogEl?.classList.remove('tw_dialog-closing');

			// Ensure we have a store and it has an update method on it
			closeComponent({ reason });
		}

		// Create timer in case the CSS is not loaded
		const fallbackTimer = setTimeout(completeClose, 500);

		// If animation starts, then CSS is loaded and timer can be removed
		dialogEl?.addEventListener(
			'animationstart',
			() => {
				// Animation started, so we can rely on CSS, rather than timer
				clearTimeout(fallbackTimer);
			},
			{ once: true }
		);

		// Clean up the DOM and complete dialog closing
		dialogEl?.addEventListener('animationend', completeClose, { once: true });

		dialogEl?.classList.add('tw_dialog-closing');
	}

	const click_handler = () => closeDialog('user');
	const click_handler_1 = () => closeDialog('user');

	function dialog_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dialogEl = $$value;
			$$invalidate(0, dialogEl);
		});
	}

	$$self.$$set = $$props => {
		if ('dialogEl' in $$props) $$invalidate(0, dialogEl = $$props.dialogEl);
		if ('dialogId' in $$props) $$invalidate(1, dialogId = $$props.dialogId);
		if ('forceOpen' in $$props) $$invalidate(2, forceOpen = $$props.forceOpen);
		if ('withHeader' in $$props) $$invalidate(3, withHeader = $$props.withHeader);
		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	return [
		dialogEl,
		dialogId,
		forceOpen,
		withHeader,
		closeDialog,
		$styleStore,
		slots,
		click_handler,
		click_handler_1,
		dialog_binding,
		$$scope
	];
}

class Dialog extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1a, create_fragment$18, safe_not_equal, {
			dialogEl: 0,
			dialogId: 1,
			forceOpen: 2,
			withHeader: 3,
			closeDialog: 4
		});
	}

	get closeDialog() {
		return this.$$.ctx[4];
	}
}

/* src/lib/components/icons/alert-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$17(ctx) {
	let svg;
	let path;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path, "d", "M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 16 16");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$19($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class Alert_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$19, create_fragment$17, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/components/icons/info-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$16(ctx) {
	let svg;
	let path;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path, "d", "M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 16 16");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$18($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class Info_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$18, create_fragment$16, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/components/icons/warning-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$15(ctx) {
	let svg;
	let path;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path, "d", "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8 4a.905.905 0 0 0-.9.995l.35 3.507a.552.552 0 0 0 1.1 0l.35-3.507A.905.905 0 0 0 8 4zm.002 6a1 1 0 1 0 0 2 1 1 0 0 0 0-2z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 16 16");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$17($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class Warning_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$17, create_fragment$15, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/components/primitives/alert/alert.svelte generated by Svelte v3.55.1 */

function create_else_block$b(ctx) {
	let infoicon;
	let current;
	infoicon = new Info_icon({});

	return {
		c() {
			create_component(infoicon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(infoicon, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(infoicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(infoicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(infoicon, detaching);
		}
	};
}

// (44:33) 
function create_if_block_1$g(ctx) {
	let warningicon;
	let current;
	warningicon = new Warning_icon({});

	return {
		c() {
			create_component(warningicon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(warningicon, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(warningicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(warningicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(warningicon, detaching);
		}
	};
}

// (42:4) {#if type === 'error'}
function create_if_block$v(ctx) {
	let alerticon;
	let current;
	alerticon = new Alert_icon({});

	return {
		c() {
			create_component(alerticon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alerticon, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(alerticon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alerticon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alerticon, detaching);
		}
	};
}

function create_fragment$14(ctx) {
	let div;
	let p;
	let current_block_type_index;
	let if_block;
	let t;
	let span;
	let div_class_value;
	let div_role_value;
	let current;
	const if_block_creators = [create_if_block$v, create_if_block_1$g, create_else_block$b];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[1] === 'error') return 0;
		if (/*type*/ ctx[1] === 'warning') return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			div = element("div");
			p = element("p");
			if_block.c();
			t = space();
			span = element("span");
			if (default_slot) default_slot.c();
			attr(p, "class", "tw_grid tw_grid-cols-[2em_1fr]");
			attr(div, "class", div_class_value = `${generateClassString$3(/*type*/ ctx[1])} tw_alert dark:tw_alert_dark tw_input-spacing tw_outline-none`);
			attr(div, "id", /*id*/ ctx[0]);
			attr(div, "tabindex", "-1");
			attr(div, "role", div_role_value = /*type*/ ctx[1] === 'error' ? 'alert' : '');
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);
			if_blocks[current_block_type_index].m(p, null);
			append(p, t);
			append(p, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*div_binding*/ ctx[6](div);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(p, t);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*type*/ 2 && div_class_value !== (div_class_value = `${generateClassString$3(/*type*/ ctx[1])} tw_alert dark:tw_alert_dark tw_input-spacing tw_outline-none`)) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*type*/ 2 && div_role_value !== (div_role_value = /*type*/ ctx[1] === 'error' ? 'alert' : '')) {
				attr(div, "role", div_role_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[6](null);
		}
	};
}

function generateClassString$3(...args) {
	return args.reduce(
		(prev, curr) => {
			switch (curr) {
				case 'error':
					return `${prev} tw_alert-error dark:tw_alert-error_dark`;
				case 'info':
					return `${prev} tw_alert-info dark:tw_alert-info_dark`;
				case 'success':
					return `${prev} tw_alert-success dark:tw_alert-success_dark`;
				case 'warning':
					return `${prev} tw_alert-warning dark:tw_alert-warning_dark`;
				default:
					return prev;
			}
		},
		''
	);
}

function instance$16($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id } = $$props;
	let { needsFocus = false } = $$props;
	let { type = '' } = $$props;
	let divEl;

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			divEl = $$value;
			$$invalidate(2, divEl);
		});
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('needsFocus' in $$props) $$invalidate(3, needsFocus = $$props.needsFocus);
		if ('type' in $$props) $$invalidate(1, type = $$props.type);
		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*needsFocus, divEl*/ 12) {
			{
				if (needsFocus) {
					divEl && divEl.focus();
				}
			}
		}
	};

	return [id, type, divEl, needsFocus, $$scope, slots, div_binding];
}

class Alert extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$16, create_fragment$14, safe_not_equal, { id: 0, needsFocus: 3, type: 1 });
	}
}

/* src/lib/components/primitives/spinner/spinner.svelte generated by Svelte v3.55.1 */

function create_fragment$13(ctx) {
	let div;
	let span;
	let t;
	let div_class_value;
	let current;
	t = new Locale_strings({ props: { key: "loading" } });

	return {
		c() {
			div = element("div");
			span = element("span");
			create_component(t.$$.fragment);
			attr(span, "class", "tw_sr-only");
			attr(div, "class", div_class_value = `tw_spinner tw_animate-spin tw_border-4 tw_inline-block tw_rounded-full ${/*colorClass*/ ctx[0]} ${/*layoutClasses*/ ctx[1]}`);
			attr(div, "role", "status");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			mount_component(t, span, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*colorClass, layoutClasses*/ 3 && div_class_value !== (div_class_value = `tw_spinner tw_animate-spin tw_border-4 tw_inline-block tw_rounded-full ${/*colorClass*/ ctx[0]} ${/*layoutClasses*/ ctx[1]}`)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(t);
		}
	};
}

function instance$15($$self, $$props, $$invalidate) {
	let { colorClass } = $$props;
	let { layoutClasses } = $$props;

	$$self.$$set = $$props => {
		if ('colorClass' in $$props) $$invalidate(0, colorClass = $$props.colorClass);
		if ('layoutClasses' in $$props) $$invalidate(1, layoutClasses = $$props.layoutClasses);
	};

	return [colorClass, layoutClasses];
}

class Spinner extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$15, create_fragment$13, safe_not_equal, { colorClass: 0, layoutClasses: 1 });
	}
}

/* src/lib/components/primitives/button/button.svelte generated by Svelte v3.55.1 */

function create_if_block$u(ctx) {
	let spinner;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "white",
				layoutClasses: "tw_h-4 tw_w-4 tw_mr-2"
			}
		});

	return {
		c() {
			create_component(spinner.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
		}
	};
}

// (44:8) Submit
function fallback_block$1(ctx) {
	let t;

	return {
		c() {
			t = text("Submit");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$12(ctx) {
	let button;
	let t;
	let button_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*busy*/ ctx[0] && create_if_block$u();
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block$1();

	return {
		c() {
			button = element("button");
			if (if_block) if_block.c();
			t = space();
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(button, "class", button_class_value = `${generateClassString$2(/*style*/ ctx[3], /*width*/ ctx[5])} tw_button-base tw_focusable-element dark:tw_focusable-element_dark width-${/*width*/ ctx[5]} ${/*classes*/ ctx[1]}`);
			attr(button, "type", /*type*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if (if_block) if_block.m(button, null);
			append(button, t);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*onClick*/ ctx[2])) /*onClick*/ ctx[2].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (/*busy*/ ctx[0]) {
				if (if_block) {
					if (dirty & /*busy*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$u();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(button, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*style, width, classes*/ 42 && button_class_value !== (button_class_value = `${generateClassString$2(/*style*/ ctx[3], /*width*/ ctx[5])} tw_button-base tw_focusable-element dark:tw_focusable-element_dark width-${/*width*/ ctx[5]} ${/*classes*/ ctx[1]}`)) {
				attr(button, "class", button_class_value);
			}

			if (!current || dirty & /*type*/ 16) {
				attr(button, "type", /*type*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (if_block) if_block.d();
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function generateClassString$2(...args) {
	return args.reduce(
		(prev, curr) => {
			switch (curr) {
				case 'primary':
					return `${prev} tw_button-primary dark:tw_button-primary_dark`;
				case 'secondary':
					return `${prev} tw_button-secondary dark:tw_button-secondary_dark`;
				case 'outline':
					return `${prev} tw_button-outline dark:tw_button-outline_dark`;
				case 'auto':
					return `${prev} tw_w-auto`;
				case 'full':
					return `${prev} tw_w-full`;
				default:
					return prev;
			}
		},
		''
	);
}

function instance$14($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { busy = false } = $$props;
	let { classes = '' } = $$props;

	let { onClick = () => {
		
	} } = $$props;

	let { style = 'outline' } = $$props;
	let { type = null } = $$props;
	let { width = 'auto' } = $$props;

	$$self.$$set = $$props => {
		if ('busy' in $$props) $$invalidate(0, busy = $$props.busy);
		if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
		if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('type' in $$props) $$invalidate(4, type = $$props.type);
		if ('width' in $$props) $$invalidate(5, width = $$props.width);
		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [busy, classes, onClick, style, type, width, $$scope, slots];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$14, create_fragment$12, safe_not_equal, {
			busy: 0,
			classes: 1,
			onClick: 2,
			style: 3,
			type: 4,
			width: 5
		});
	}
}

/* src/lib/components/primitives/form/form.svelte generated by Svelte v3.55.1 */

function create_fragment$11(ctx) {
	let form;
	let form_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			form = element("form");
			if (default_slot) default_slot.c();
			attr(form, "aria-describedby", /*ariaDescribedBy*/ ctx[1]);
			attr(form, "id", /*id*/ ctx[2]);

			attr(form, "class", form_class_value = `tw_form-base ${/*isFormValid*/ ctx[3]
			? 'tw_form-valid'
			: 'tw_form-invalid'} tw_outline-none`);

			form.noValidate = true;
			attr(form, "tabindex", "-1");
		},
		m(target, anchor) {
			insert(target, form, anchor);

			if (default_slot) {
				default_slot.m(form, null);
			}

			/*form_binding*/ ctx[9](form);
			current = true;

			if (!mounted) {
				dispose = listen(form, "submit", prevent_default(/*formSubmit*/ ctx[4]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*ariaDescribedBy*/ 2) {
				attr(form, "aria-describedby", /*ariaDescribedBy*/ ctx[1]);
			}

			if (!current || dirty & /*id*/ 4) {
				attr(form, "id", /*id*/ ctx[2]);
			}

			if (!current || dirty & /*isFormValid*/ 8 && form_class_value !== (form_class_value = `tw_form-base ${/*isFormValid*/ ctx[3]
			? 'tw_form-valid'
			: 'tw_form-invalid'} tw_outline-none`)) {
				attr(form, "class", form_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form);
			if (default_slot) default_slot.d(detaching);
			/*form_binding*/ ctx[9](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$13($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { ariaDescribedBy } = $$props;
	let { formEl = null } = $$props;
	let { id = 'formId' } = $$props;
	let { needsFocus = false } = $$props;
	let { onSubmitWhenValid = undefined } = $$props;
	let isFormValid = false;

	/**
 * @function formSubmit - responsible for form validation prior to calling provided submit function
 * @param {Object} event - HTML form event
 * @return {undefined}
 */
	function formSubmit(event) {
		/**
 * Reference for validation: https://www.aleksandrhovhannisyan.com/blog/html-input-validation-without-a-form/
 */
		const form = event.target;

		let isFirstInvalidInput = null;
		$$invalidate(3, isFormValid = false); // Restart with `false`

		// Iterate over all children of the form, and pluck out the inputs
		Array.from(form.children).forEach((el, idx) => {
			// First child will be a `div`, so query the actual form elements
			// eslint-disable-next-line no-undef
			const inputs = el.querySelectorAll('input, select, textarea');

			// If element has no form input, return early
			if (!inputs?.length) {
				return;
			}

			// Reports input's value validity and triggers native error handling
			// const isValid = input.reportValidity();
			/**
 * Not the most efficient thing to do, but fieldsets contain more than one input
 * The vast majority of these will be a list of one
 */
			Array.from(inputs).forEach(input => {
				/**
 * Just check validity, but don't "report" it
 * The data attribute is a string of 'true', 'false', OR the value undefined
 */
				const isValid = input.checkValidity() && input.dataset.forceValidityFailure !== 'true';

				// debugger;
				// Grab the associated elements to this input
				const messageKey = input.getAttribute('aria-describedby') || '';

				const messageContainer = document.getElementById(messageKey);
				const messageEl = messageContainer?.querySelector('.__input-message');

				// If input is invalid, mark it with error and message
				if (!isValid) {
					input.setAttribute('aria-invalid', 'true');

					if (messageKey) {
						messageEl?.classList.add('tw_isInvalid');
						messageEl?.classList.remove('tw_hidden');
					}

					// If there is no previous invalid input, this input is first and receives focus
					if (isFirstInvalidInput === null) {
						input.focus();
						isFirstInvalidInput = idx;
					}
				} else {
					input.setAttribute('aria-invalid', 'false');
					messageEl?.classList.remove('tw_isInvalid');
					messageEl?.classList.add('tw_hidden');
				}
			});
		});

		// If there's no invalid input, submit form.
		if (isFirstInvalidInput === null) {
			$$invalidate(3, isFormValid = true);
			onSubmitWhenValid && onSubmitWhenValid(event, isFormValid);
		}
	}

	function form_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			formEl = $$value;
			$$invalidate(0, formEl);
		});
	}

	$$self.$$set = $$props => {
		if ('ariaDescribedBy' in $$props) $$invalidate(1, ariaDescribedBy = $$props.ariaDescribedBy);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('needsFocus' in $$props) $$invalidate(5, needsFocus = $$props.needsFocus);
		if ('onSubmitWhenValid' in $$props) $$invalidate(6, onSubmitWhenValid = $$props.onSubmitWhenValid);
		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*needsFocus, formEl*/ 33) {
			{
				if (needsFocus) {
					formEl && formEl.focus();
				}
			}
		}
	};

	return [
		formEl,
		ariaDescribedBy,
		id,
		isFormValid,
		formSubmit,
		needsFocus,
		onSubmitWhenValid,
		$$scope,
		slots,
		form_binding
	];
}

class Form extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$13, create_fragment$11, safe_not_equal, {
			ariaDescribedBy: 1,
			formEl: 0,
			id: 2,
			needsFocus: 5,
			onSubmitWhenValid: 6
		});
	}
}

/* src/lib/components/_utilities/server-strings.svelte generated by Svelte v3.55.1 */

function create_else_block$a(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

	return {
		c() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*message*/ 2)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (10:0) {#if html}
function create_if_block$t(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	return {
		c() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*message*/ 2)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (13:8) {message}
function fallback_block_1(ctx) {
	let t;

	return {
		c() {
			t = text(/*message*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*message*/ 2) set_data(t, /*message*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (11:8) {@html message}
function fallback_block(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*message*/ ctx[1], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*message*/ 2) html_tag.p(/*message*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

function create_fragment$10(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$t, create_else_block$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*html*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$12($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { html = false } = $$props;
	let { string } = $$props;
	let message;

	$$self.$$set = $$props => {
		if ('html' in $$props) $$invalidate(0, html = $$props.html);
		if ('string' in $$props) $$invalidate(2, string = $$props.string);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*string*/ 4) {
			{
				$$invalidate(1, message = sanitize(string));
			}
		}
	};

	return [html, message, string, $$scope, slots];
}

class Server_strings extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$12, create_fragment$10, safe_not_equal, { html: 0, string: 2 });
	}
}

/* src/lib/components/icons/shield-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$$(ctx) {
	let svg;
	let path;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path, "d", "M8 0c-.69 0-1.843.265-2.928.56-1.11.3-2.229.655-2.887.87a1.54 1.54 0 0 0-1.044 1.262c-.596 4.477.787 7.795 2.465 9.99a11.777 11.777 0 0 0 2.517 2.453c.386.273.744.482 1.048.625.28.132.581.24.829.24s.548-.108.829-.24a7.159 7.159 0 0 0 1.048-.625 11.775 11.775 0 0 0 2.517-2.453c1.678-2.195 3.061-5.513 2.465-9.99a1.541 1.541 0 0 0-1.044-1.263 62.467 62.467 0 0 0-2.887-.87C9.843.266 8.69 0 8 0zm0 5a1.5 1.5 0 0 1 .5 2.915l.385 1.99a.5.5 0 0 1-.491.595h-.788a.5.5 0 0 1-.49-.595l.384-1.99A1.5 1.5 0 0 1 8 5z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "-2 0 20 20");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$11($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class Shield_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$11, create_fragment$$, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/stages/_utilities/back-to.svelte generated by Svelte v3.55.1 */

function create_if_block$s(ctx) {
	let p;
	let button;
	let t_value = interpolate(/*string*/ ctx[1]) + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			p = element("p");
			button = element("button");
			t = text(t_value);
			attr(p, "class", "tw_my-4 tw_text-base tw_text-center tw_text-link-dark dark:tw_text-link-light");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, button);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", prevent_default(/*click_handler*/ ctx[4]));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*string*/ 2 && t_value !== (t_value = interpolate(/*string*/ ctx[1]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(p);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$_(ctx) {
	let if_block_anchor;
	let if_block = /*$stack*/ ctx[2].length > 1 && create_if_block$s(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*$stack*/ ctx[2].length > 1) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$s(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$10($$self, $$props, $$invalidate) {
	let $stack;
	let $configuredJourneysStore;
	component_subscribe($$self, configuredJourneysStore, $$value => $$invalidate(5, $configuredJourneysStore = $$value));
	let { journey } = $$props;
	let stack = journey.stack;
	component_subscribe($$self, stack, value => $$invalidate(2, $stack = value));
	let string = '';

	function constructString() {
		const currentJourney = $configuredJourneysStore.find(journey => {
			return journey.journey === $stack[$stack.length - 2]?.tree;
		});

		const key = currentJourney?.key;

		const capitalizedKey = typeof key === 'string'
		? key.replace(/([a-z])/, (_, char) => `${char.toUpperCase()}`)
		: key;

		return `backTo${capitalizedKey || 'Default'}`;
	}

	const click_handler = () => {
		journey?.pop();
	};

	$$self.$$set = $$props => {
		if ('journey' in $$props) $$invalidate(0, journey = $$props.journey);
	};

	{
		$$invalidate(1, string = constructString());
	}

	return [journey, string, $stack, stack, click_handler];
}

class Back_to extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$10, create_fragment$_, safe_not_equal, { journey: 0 });
	}
}

/**
 * @function captureLinks - This is a callback for onMount that internally handled links and prevents navigation
 * @param {object} linkWrapper - The object return from `bind:this` attribute on an native element
 * @param {object} currentJourney - The current stage's journey object
 */
function captureLinks(linkWrapper, currentJourney) {
    const journeys = get_store_value(configuredJourneysStore);
    const stack = get_store_value(currentJourney.stack);
    linkWrapper.addEventListener('click', (event) => {
        const target = event.target;
        const href = target.hasAttribute('href') && target.getAttribute('href');
        const { action, journey } = matchJourneyAndDecideAction(href, journeys, stack);
        if (!action) {
            // If no action is required, return early and allow default behavior
            return;
        }
        // Action is required, so prevent default behavior
        event.preventDefault();
        // Now, push or pop accordingly
        if (action === 'push') {
            currentJourney.push({ tree: journey });
        }
        else if (action === 'pop') {
            currentJourney.pop();
        }
    });
}
/**
 * Exporting this solely to unit test the logic. It is not intended for external use.
 * @private - compares requested and current journey, then pops or pushes accordingly
 * @param href
 * @param journeys
 * @param stack
 */
function matchJourneyAndDecideAction(href, journeys, stack) {
    if (href) {
        /**
         * Does this href match an item configured in the journeys?
         */
        const match = journeys.find((item) => {
            return item.match.find((string) => {
                return href === string;
            });
        });
        if (match) {
            const previousJourney = stack[stack.length - 2];
            if (!previousJourney || previousJourney.tree !== match.journey) {
                return { action: 'push', journey: match.journey };
            }
            else {
                return { action: 'pop' };
            }
        }
        else {
            return { action: null };
        }
    }
    else {
        return { action: null };
    }
}

/** *********************************************
 * NEW "NORMALIZED" METHODS
 */
/**
 * @function getInputTypeFromPolicies - Determines the type of input to use based on the policies object
 * @param {object} policies - The policies object from the callback
 * @returns {string} - The type of input to use
 */
function getInputTypeFromPolicies(policies) {
    const value = policies?.value;
    if (typeof value !== 'object') {
        return 'text';
    }
    const reqs = value?.policyRequirements;
    if (!Array.isArray(reqs)) {
        return 'text';
    }
    if (reqs.includes('VALID_EMAIL_ADDRESS_FORMAT')) {
        return 'email';
    }
    if (reqs.includes('VALID_USERNAME')) {
        return 'text';
    }
    return 'text';
}
/**
 * @function getValidationFailureParams - Gets the validation failure params from the failed policy object
 * @param {object} failedPolicy - The failed policy object from the callback
 * @returns {array} - An array of objects containing the length, message, and rule
 */
function getValidationFailureParams(failedPolicy) {
    if (failedPolicy?.policyRequirement === 'DICTIONARY') {
        const params = failedPolicy.params;
        const min = params?.['min-substring-length'] || 0;
        const arr = [];
        if (params?.['check-substrings'] && params?.['test-reversed-password']) {
            arr.push({
                length: min,
                message: interpolate('passwordCannotContainCommonPasswordsOrBeReversibleStringsLessThan', {
                    min: String(min),
                }),
                rule: 'reversibleSubstrings',
            });
        }
        else if (params?.['test-reversed-password']) {
            arr.push({
                length: null,
                message: interpolate('passwordCannotContainCommonPasswordsOrBeReversible'),
                rule: 'reversibleSubstrings',
            });
        }
        else {
            arr.push({
                length: null,
                message: interpolate('passwordCannotContainCommonPasswords'),
                rule: 'reversibleSubstrings',
            });
        }
        return arr;
    }
    else if (failedPolicy?.policyRequirement === 'CHARACTER_SET') {
        const params = failedPolicy.params;
        return params?.['character-sets'].map(convertCharacterSetToRuleObj);
    }
    else if (failedPolicy?.policyRequirement === 'LENGTH_BASED') {
        const params = failedPolicy.params;
        const min = params?.['min-password-length'] || 0;
        const max = params?.['max-password-length'] || null;
        const arr = [];
        if (max) {
            arr.push({
                length: max,
                message: interpolate('exceedsMaximumCharacterLength', { max: String(max) }),
                rule: 'maximumLength',
            });
        }
        if (min) {
            arr.push({
                length: min,
                message: interpolate('doesNotMeetMinimumCharacterLength', { min: String(min) }),
                rule: 'minimumLength',
            });
        }
        return arr;
    }
    else if (failedPolicy?.policyRequirement === 'REPEATED_CHARACTERS') {
        const params = failedPolicy.params;
        const max = params['max-consecutive-length'] || 0;
        const arr = [];
        if (!params['case-sensitive-validation']) {
            arr.push({
                length: max,
                message: interpolate('charactersCannotRepeatMoreThanCaseInsensitive', { max: String(max) }),
                rule: 'repeatedCharactersCaseInsensitive',
            });
        }
        else {
            arr.push({
                length: max,
                message: interpolate('charactersCannotRepeatMoreThan', { max: String(max) }),
                rule: 'repeatedCharacters',
            });
        }
        return arr;
    }
    else if (failedPolicy?.policyRequirement === 'VALID_USERNAME') {
        return [
            {
                length: null,
                message: interpolate('chooseDifferentUsername'),
                rule: 'validUsername',
            },
        ];
    }
    else if (failedPolicy?.policyRequirement === 'VALID_EMAIL_ADDRESS_FORMAT') {
        return [
            {
                length: null,
                message: interpolate('invalidEmailAddress'),
                rule: 'validEmailAddress',
            },
        ];
    }
    else {
        return [
            {
                length: null,
                message: interpolate('pleaseCheckValue'),
                rule: 'unknown',
            },
        ];
    }
}
/**
 * @function getValidationMessageString - Gets the validation message string from the policy object
 * @param {object} policy - The policy object from the callback
 * @returns {string} - The validation message string
 */
function getValidationMessageString(policy) {
    switch (policy?.policyId) {
        case 'at-least-X-capitals': {
            const params = policy?.params;
            const length = params?.numCaps;
            return interpolate('minimumNumberOfUppercase', { num: String(length) });
        }
        case 'at-least-X-numbers': {
            const params = policy?.params;
            const length = params?.numNums;
            return interpolate('minimumNumberOfNumbers', { num: String(length) });
        }
        case 'cannot-contain-characters': {
            const params = policy?.params;
            let chars = '';
            if (typeof params !== 'object') {
                return '';
            }
            if (Array.isArray(params.forbiddenChars)) {
                chars = params.forbiddenChars.reduce((prev, curr) => {
                    prev = `${prev ? `${prev}, ` : `${prev}`} ${curr}`;
                    return prev;
                }, '');
            }
            else if (typeof params.forbiddenChars === 'string') {
                chars = params.forbiddenChars;
            }
            return interpolate('fieldCanNotContainFollowingCharacters', { chars });
        }
        case 'cannot-contain-others': {
            const params = policy?.params;
            let fields = '';
            if (typeof params !== 'object') {
                return '';
            }
            if (Array.isArray(params.disallowedFields)) {
                fields = params.disallowedFields?.reduce((prev, curr) => {
                    prev = `${prev ? `${prev}, ` : `${prev}`} ${interpolate(curr)}`;
                    return prev;
                }, '');
            }
            else if (typeof params.disallowedFields === 'string') {
                fields = params.disallowedFields;
            }
            return interpolate('fieldCanNotContainFollowingValues', { fields });
        }
        case 'maximum-length': {
            const params = policy?.params;
            const length = params?.maxLength;
            if (length > 100) {
                return '';
            }
            return interpolate('notToExceedMaximumCharacterLength', { max: String(length) });
        }
        case 'minimum-length': {
            const params = policy?.params;
            const length = params?.minLength;
            if (length === 1) {
                return '';
            }
            return interpolate('noLessThanMinimumCharacterLength', { min: String(length) });
        }
        /**
         * The below cases can be handled, but I think they create more noise than value to the user
         */
        case 'not-empty':
            // return interpolate('fieldCanNotBeEmpty');
            return '';
        case 'required':
            // return interpolate('requiredField');
            return '';
        case 'valid-username':
            // return interpolate('chooseDifferentUsername');
            return '';
        case 'valid-email-address-format':
            // return interpolate('useValidEmail');
            return '';
        case 'valid-type':
            return '';
        default:
            return '';
    }
}
/**
 * @function getValidationFailures - Gets the validation failures from the callback object
 * @param {object} callback - The callback object from the server
 * @param {string} label - The label of the field
 * @returns {array} - An array of failed policies
 */
function getValidationFailures(callback, label) {
    const failedPolicies = callback.getFailedPolicies && callback.getFailedPolicies();
    const parsedPolicies = parseFailedPolicies(failedPolicies, label);
    return parsedPolicies.map((policy) => {
        return {
            params: policy?.params,
            policyRequirement: policy?.policyRequirement || '',
            restructured: getValidationFailureParams(policy),
        };
    });
}
/**
 * @function getValidationPolicies - Gets the validation policies from the callback object
 * @param {object} policies - The policies object from the callback
 * @returns {array} - An array of policies
 */
function getValidationPolicies(policies) {
    if (typeof policies !== 'object' && !policies) {
        return [];
    }
    const reqs = policies?.policies;
    if (!Array.isArray(reqs)) {
        return [];
    }
    return reqs
        .map((policy) => {
        return {
            message: getValidationMessageString(policy),
            ...(policy?.params && { params: policy?.params }),
            ...(policy?.policyId && { policyId: policy?.policyId }),
        };
    })
        .filter((policy) => !!policy.message);
}
/**
 * @function isInputRequired - Checks if the input is required
 * @param {object} callback - The callback object from the server
 * @returns {boolean} - Whether the input is required
 */
function isInputRequired(callback) {
    const policies = callback.getPolicies && callback.getPolicies();
    let isRequired = false;
    if (policies?.policyRequirements) {
        isRequired = policies.policyRequirements.includes('REQUIRED');
    }
    else if (callback.isRequired) {
        isRequired = callback.isRequired();
    }
    return isRequired;
}
/**
 * @function convertCharacterSetToRuleObj - Converts a character set to a rule object
 * @param {string} set - The character set to convert
 * @returns {object} - The rule object
 */
function convertCharacterSetToRuleObj(set) {
    const arr = set.split(':');
    const num = arr[0];
    const type = arr[1];
    if (type === '0123456789') {
        if (num === '0') {
            return {
                length: null,
                message: interpolate('shouldContainANumber'),
                rule: 'numbers',
            };
        }
        else {
            return {
                length: Number(num),
                message: interpolate('minimumNumberOfNumbers', { num: String(num) }),
                rule: 'numbers',
            };
        }
    }
    else if (type === 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') {
        if (num === '0') {
            return {
                length: null,
                message: interpolate('shouldContainAnUppercase'),
                rule: 'uppercase',
            };
        }
        else {
            return {
                length: Number(num),
                message: interpolate('minimumNumberOfUppercase', { num: String(num) }),
                rule: 'uppercase',
            };
        }
    }
    else if (type === 'abcdefghijklmnopqrstuvwxyz') {
        if (num === '0') {
            return {
                length: null,
                message: interpolate('shouldContainALowercase'),
                rule: 'lowercase',
            };
        }
        else {
            return {
                length: Number(num),
                message: interpolate('minimumNumberOfLowercase', { num: String(num) }),
                rule: 'lowercase',
            };
        }
    }
    else if (type.includes('@') || type.includes('!') || type.includes('*') || type.includes('#')) {
        if (num === '0') {
            return {
                length: null,
                message: interpolate('shouldContainASymbol'),
                rule: 'symbols',
            };
        }
        else {
            return {
                length: Number(num),
                message: interpolate('minimumNumberOfSymbols', { num: String(num) }),
                rule: 'symbols',
            };
        }
    }
    else {
        return {
            length: null,
            message: interpolate('pleaseCheckValue'),
            rule: 'unknown',
        };
    }
}
/**
 * @function parseFailedPolicies - Parses the failed policies from the callback object
 * @param {array} policies - The policies array from the callback
 * @param {string} label - The label of the field
 * @returns {array} - An array of failed policies
 */
function parseFailedPolicies(policies, label) {
    return policies.map((policy) => {
        if (typeof policy === 'string') {
            try {
                return JSON.parse(policy);
            }
            catch (err) {
                console.error(`Parsing failure for ${label}`);
            }
        }
        else {
            return policy;
        }
    });
}
/**
 * @function getAttributeValidationFailureText - Gets the validation failure text from the callback object
 * @param {object} callback - The callback object from the server
 * @returns {string} - The validation failure text
 */
function getAttributeValidationFailureText(callback) {
    // TODO: Mature this utility for better parsing and display
    const failedPolicies = callback.getFailedPolicies && callback.getFailedPolicies();
    return failedPolicies.reduce((prev, curr) => {
        switch (curr.policyRequirement) {
            default:
                prev = `${prev}${interpolate('pleaseCheckValue')}`;
        }
        return prev;
    }, '');
}

/* src/lib/components/primitives/message/input-message.svelte generated by Svelte v3.55.1 */

function create_if_block$r(ctx) {
	let p;
	let p_class_value;
	let p_id_value;

	return {
		c() {
			p = element("p");
			attr(p, "class", p_class_value = `${/*classes*/ ctx[0]} __input-message ${!/*showMessage*/ ctx[3] ? 'tw_hidden' : ''} ${generateClassString$1(/*type*/ ctx[4])}`);
			attr(p, "id", p_id_value = `${/*key*/ ctx[2] ? `${/*key*/ ctx[2]}-message` : ''}`);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			p.innerHTML = /*cleanMessage*/ ctx[5];
		},
		p(ctx, dirty) {
			if (dirty & /*cleanMessage*/ 32) p.innerHTML = /*cleanMessage*/ ctx[5];
			if (dirty & /*classes, showMessage, type*/ 25 && p_class_value !== (p_class_value = `${/*classes*/ ctx[0]} __input-message ${!/*showMessage*/ ctx[3] ? 'tw_hidden' : ''} ${generateClassString$1(/*type*/ ctx[4])}`)) {
				attr(p, "class", p_class_value);
			}

			if (dirty & /*key*/ 4 && p_id_value !== (p_id_value = `${/*key*/ ctx[2] ? `${/*key*/ ctx[2]}-message` : ''}`)) {
				attr(p, "id", p_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

function create_fragment$Z(ctx) {
	let if_block_anchor;
	let if_block = /*dirtyMessage*/ ctx[1] && create_if_block$r(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*dirtyMessage*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$r(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function generateClassString$1(...args) {
	return args.reduce(
		(prev, curr) => {
			switch (curr) {
				case 'error':
					return `${prev} tw_input-error-message dark:tw_input-error-message_dark`;
				default:
					return `${prev} tw_input-info-message dark:tw_input-info-message_dark`;
			}
		},
		''
	);
}

function instance$$($$self, $$props, $$invalidate) {
	let { classes = '' } = $$props;
	let { dirtyMessage } = $$props;
	let { key = undefined } = $$props;
	let { showMessage = true } = $$props;
	let { type = 'info' } = $$props;
	let cleanMessage = sanitize(dirtyMessage);

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('dirtyMessage' in $$props) $$invalidate(1, dirtyMessage = $$props.dirtyMessage);
		if ('key' in $$props) $$invalidate(2, key = $$props.key);
		if ('showMessage' in $$props) $$invalidate(3, showMessage = $$props.showMessage);
		if ('type' in $$props) $$invalidate(4, type = $$props.type);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dirtyMessage*/ 2) {
			{
				$$invalidate(5, cleanMessage = sanitize(dirtyMessage));
			}
		}
	};

	return [classes, dirtyMessage, key, showMessage, type, cleanMessage];
}

class Input_message extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$$, create_fragment$Z, safe_not_equal, {
			classes: 0,
			dirtyMessage: 1,
			key: 2,
			showMessage: 3,
			type: 4
		});
	}
}

/* src/lib/components/primitives/label/label.svelte generated by Svelte v3.55.1 */

function create_fragment$Y(ctx) {
	let label;
	let label_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			label = element("label");
			if (default_slot) default_slot.c();
			attr(label, "for", /*key*/ ctx[0]);
			attr(label, "class", label_class_value = `${/*classes*/ ctx[1]} tw_input-label dark:tw_input-label_dark`);
		},
		m(target, anchor) {
			insert(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*key*/ 1) {
				attr(label, "for", /*key*/ ctx[0]);
			}

			if (!current || dirty & /*classes*/ 2 && label_class_value !== (label_class_value = `${/*classes*/ ctx[1]} tw_input-label dark:tw_input-label_dark`)) {
				attr(label, "class", label_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$_($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { key } = $$props;
	let { classes = '' } = $$props;

	$$self.$$set = $$props => {
		if ('key' in $$props) $$invalidate(0, key = $$props.key);
		if ('classes' in $$props) $$invalidate(1, classes = $$props.classes);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [key, classes, $$scope, slots];
}

class Label extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$_, create_fragment$Y, safe_not_equal, { key: 0, classes: 1 });
	}
}

/* src/lib/components/compositions/checkbox/animated.svelte generated by Svelte v3.55.1 */

function create_default_slot$v(ctx) {
	let span;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			span = element("span");
			t = space();
			if (default_slot) default_slot.c();
			attr(span, "class", "tw_animated-check dark:tw_animated-check_dark");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$X(ctx) {
	let div1;
	let input;
	let input_data_message_value;
	let t0;
	let label;
	let t1;
	let div0;
	let message_1;
	let current;
	let mounted;
	let dispose;

	label = new Label({
			props: {
				key: /*key*/ ctx[3],
				classes: "tw_grid tw_grid-cols-[2.5em_1fr] tw_relative",
				$$slots: { default: [create_default_slot$v] },
				$$scope: { ctx }
			}
		});

	message_1 = new Input_message({
			props: {
				key: /*key*/ ctx[3],
				dirtyMessage: /*message*/ ctx[1],
				showMessage: /*showMessage*/ ctx[4],
				type: /*isInvalid*/ ctx[0] ? 'error' : 'info'
			}
		});

	return {
		c() {
			div1 = element("div");
			input = element("input");
			t0 = space();
			create_component(label.$$.fragment);
			t1 = space();
			div0 = element("div");
			create_component(message_1.$$.fragment);
			attr(input, "aria-invalid", /*isInvalid*/ ctx[0]);
			attr(input, "class", "tw_checkbox-input_animated dark:tw_checkbox-input_animated_dark tw_sr-only");
			input.checked = /*value*/ ctx[5];
			attr(input, "data-message", input_data_message_value = `${/*key*/ ctx[3]}-message`);
			attr(input, "id", /*key*/ ctx[3]);
			input.required = /*isRequired*/ ctx[2];
			attr(input, "type", "checkbox");
			attr(div0, "class", "tw_ml-10");
			attr(div1, "class", "tw_input-spacing");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, input);
			/*input_binding*/ ctx[12](input);
			append(div1, t0);
			mount_component(label, div1, null);
			append(div1, t1);
			append(div1, div0);
			mount_component(message_1, div0, null);
			current = true;

			if (!mounted) {
				dispose = listen(input, "change", /*onChangeWrapper*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*isInvalid*/ 1) {
				attr(input, "aria-invalid", /*isInvalid*/ ctx[0]);
			}

			if (!current || dirty & /*value*/ 32) {
				input.checked = /*value*/ ctx[5];
			}

			if (!current || dirty & /*key*/ 8 && input_data_message_value !== (input_data_message_value = `${/*key*/ ctx[3]}-message`)) {
				attr(input, "data-message", input_data_message_value);
			}

			if (!current || dirty & /*key*/ 8) {
				attr(input, "id", /*key*/ ctx[3]);
			}

			if (!current || dirty & /*isRequired*/ 4) {
				input.required = /*isRequired*/ ctx[2];
			}

			const label_changes = {};
			if (dirty & /*key*/ 8) label_changes.key = /*key*/ ctx[3];

			if (dirty & /*$$scope*/ 8192) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const message_1_changes = {};
			if (dirty & /*key*/ 8) message_1_changes.key = /*key*/ ctx[3];
			if (dirty & /*message*/ 2) message_1_changes.dirtyMessage = /*message*/ ctx[1];
			if (dirty & /*showMessage*/ 16) message_1_changes.showMessage = /*showMessage*/ ctx[4];
			if (dirty & /*isInvalid*/ 1) message_1_changes.type = /*isInvalid*/ ctx[0] ? 'error' : 'info';
			message_1.$set(message_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(message_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label.$$.fragment, local);
			transition_out(message_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			/*input_binding*/ ctx[12](null);
			destroy_component(label);
			destroy_component(message_1);
			mounted = false;
			dispose();
		}
	};
}

function instance$Z($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { checkValidity = null } = $$props;
	let { message = '' } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { onChange } = $$props;
	let { showMessage = undefined } = $$props;
	let { value } = $$props;
	let inputEl;

	function onChangeWrapper(event) {
		if (checkValidity) {
			$$invalidate(0, isInvalid = !checkValidity(event));
		}

		onChange(event);
	}

	afterUpdate(() => {
		if (isFirstInvalidInput) {
			inputEl.focus();
		}
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(6, inputEl);
		});
	}

	$$self.$$set = $$props => {
		if ('checkValidity' in $$props) $$invalidate(8, checkValidity = $$props.checkValidity);
		if ('message' in $$props) $$invalidate(1, message = $$props.message);
		if ('isFirstInvalidInput' in $$props) $$invalidate(9, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(2, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(0, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(3, key = $$props.key);
		if ('onChange' in $$props) $$invalidate(10, onChange = $$props.onChange);
		if ('showMessage' in $$props) $$invalidate(4, showMessage = $$props.showMessage);
		if ('value' in $$props) $$invalidate(5, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	return [
		isInvalid,
		message,
		isRequired,
		key,
		showMessage,
		value,
		inputEl,
		onChangeWrapper,
		checkValidity,
		isFirstInvalidInput,
		onChange,
		slots,
		input_binding,
		$$scope
	];
}

let Animated$1 = class Animated extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$Z, create_fragment$X, safe_not_equal, {
			checkValidity: 8,
			message: 1,
			isFirstInvalidInput: 9,
			isRequired: 2,
			isInvalid: 0,
			key: 3,
			onChange: 10,
			showMessage: 4,
			value: 5
		});
	}
};

/* src/lib/components/primitives/checkbox/checkbox.svelte generated by Svelte v3.55.1 */

function create_default_slot$u(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$W(ctx) {
	let input;
	let input_aria_describedby_value;
	let t;
	let label;
	let current;
	let mounted;
	let dispose;

	label = new Label({
			props: {
				key: /*key*/ ctx[2],
				$$slots: { default: [create_default_slot$u] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			input = element("input");
			t = space();
			create_component(label.$$.fragment);
			attr(input, "aria-describedby", input_aria_describedby_value = `${/*key*/ ctx[2]}-message`);
			attr(input, "aria-invalid", /*isInvalid*/ ctx[1]);
			attr(input, "class", "tw_checkbox-input dark:tw_checkbox-input_dark tw_focusable-element dark:tw_focusable-element_dark");
			input.checked = /*value*/ ctx[4];
			attr(input, "id", /*key*/ ctx[2]);
			input.required = /*isRequired*/ ctx[0];
			attr(input, "type", "checkbox");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[8](input);
			insert(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(input, "change", function () {
					if (is_function(/*onChange*/ ctx[3])) /*onChange*/ ctx[3].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (!current || dirty & /*key*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = `${/*key*/ ctx[2]}-message`)) {
				attr(input, "aria-describedby", input_aria_describedby_value);
			}

			if (!current || dirty & /*isInvalid*/ 2) {
				attr(input, "aria-invalid", /*isInvalid*/ ctx[1]);
			}

			if (!current || dirty & /*value*/ 16) {
				input.checked = /*value*/ ctx[4];
			}

			if (!current || dirty & /*key*/ 4) {
				attr(input, "id", /*key*/ ctx[2]);
			}

			if (!current || dirty & /*isRequired*/ 1) {
				input.required = /*isRequired*/ ctx[0];
			}

			const label_changes = {};
			if (dirty & /*key*/ 4) label_changes.key = /*key*/ ctx[2];

			if (dirty & /*$$scope*/ 512) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding*/ ctx[8](null);
			if (detaching) detach(t);
			destroy_component(label, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$Y($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { onChange } = $$props;
	let { value } = $$props;
	let inputEl;

	afterUpdate(() => {
		if (isFirstInvalidInput) {
			inputEl.focus();
		}
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(5, inputEl);
		});
	}

	$$self.$$set = $$props => {
		if ('isFirstInvalidInput' in $$props) $$invalidate(6, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(0, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(1, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(2, key = $$props.key);
		if ('onChange' in $$props) $$invalidate(3, onChange = $$props.onChange);
		if ('value' in $$props) $$invalidate(4, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	return [
		isRequired,
		isInvalid,
		key,
		onChange,
		value,
		inputEl,
		isFirstInvalidInput,
		slots,
		input_binding,
		$$scope
	];
}

class Checkbox extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$Y, create_fragment$W, safe_not_equal, {
			isFirstInvalidInput: 6,
			isRequired: 0,
			isInvalid: 1,
			key: 2,
			onChange: 3,
			value: 4
		});
	}
}

/* src/lib/components/compositions/checkbox/standard.svelte generated by Svelte v3.55.1 */

function create_default_slot$t(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$V(ctx) {
	let div;
	let checkbox;
	let t;
	let span;
	let message_1;
	let current;

	checkbox = new Checkbox({
			props: {
				isFirstInvalidInput: /*isFirstInvalidInput*/ ctx[2],
				isRequired: /*isRequired*/ ctx[3],
				isInvalid: /*isInvalid*/ ctx[0],
				key: /*key*/ ctx[4],
				onChange: /*onChangeWrapper*/ ctx[7],
				value: /*value*/ ctx[6],
				$$slots: { default: [create_default_slot$t] },
				$$scope: { ctx }
			}
		});

	message_1 = new Input_message({
			props: {
				dirtyMessage: /*message*/ ctx[1],
				key: /*key*/ ctx[4],
				showMessage: /*showMessage*/ ctx[5],
				type: /*isInvalid*/ ctx[0] ? 'error' : 'info'
			}
		});

	return {
		c() {
			div = element("div");
			create_component(checkbox.$$.fragment);
			t = space();
			span = element("span");
			create_component(message_1.$$.fragment);
			attr(span, "class", "tw_col-start-2 tw_row-start-2");
			attr(div, "class", "tw_input-spacing tw_grid tw_grid-cols-[1.5em_1fr]");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(checkbox, div, null);
			append(div, t);
			append(div, span);
			mount_component(message_1, span, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const checkbox_changes = {};
			if (dirty & /*isFirstInvalidInput*/ 4) checkbox_changes.isFirstInvalidInput = /*isFirstInvalidInput*/ ctx[2];
			if (dirty & /*isRequired*/ 8) checkbox_changes.isRequired = /*isRequired*/ ctx[3];
			if (dirty & /*isInvalid*/ 1) checkbox_changes.isInvalid = /*isInvalid*/ ctx[0];
			if (dirty & /*key*/ 16) checkbox_changes.key = /*key*/ ctx[4];
			if (dirty & /*value*/ 64) checkbox_changes.value = /*value*/ ctx[6];

			if (dirty & /*$$scope*/ 2048) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
			const message_1_changes = {};
			if (dirty & /*message*/ 2) message_1_changes.dirtyMessage = /*message*/ ctx[1];
			if (dirty & /*key*/ 16) message_1_changes.key = /*key*/ ctx[4];
			if (dirty & /*showMessage*/ 32) message_1_changes.showMessage = /*showMessage*/ ctx[5];
			if (dirty & /*isInvalid*/ 1) message_1_changes.type = /*isInvalid*/ ctx[0] ? 'error' : 'info';
			message_1.$set(message_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			transition_in(message_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			transition_out(message_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(checkbox);
			destroy_component(message_1);
		}
	};
}

function instance$X($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { checkValidity = null } = $$props;
	let { message = '' } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { onChange } = $$props;
	let { showMessage = undefined } = $$props;
	let { value } = $$props;

	function onChangeWrapper(event) {
		if (checkValidity) {
			$$invalidate(0, isInvalid = !checkValidity(event));
		}

		onChange(event);
	}

	$$self.$$set = $$props => {
		if ('checkValidity' in $$props) $$invalidate(8, checkValidity = $$props.checkValidity);
		if ('message' in $$props) $$invalidate(1, message = $$props.message);
		if ('isFirstInvalidInput' in $$props) $$invalidate(2, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(3, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(0, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(4, key = $$props.key);
		if ('onChange' in $$props) $$invalidate(9, onChange = $$props.onChange);
		if ('showMessage' in $$props) $$invalidate(5, showMessage = $$props.showMessage);
		if ('value' in $$props) $$invalidate(6, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	return [
		isInvalid,
		message,
		isFirstInvalidInput,
		isRequired,
		key,
		showMessage,
		value,
		onChangeWrapper,
		checkValidity,
		onChange,
		slots,
		$$scope
	];
}

let Standard$1 = class Standard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$X, create_fragment$V, safe_not_equal, {
			checkValidity: 8,
			message: 1,
			isFirstInvalidInput: 2,
			isRequired: 3,
			isInvalid: 0,
			key: 4,
			onChange: 9,
			showMessage: 5,
			value: 6
		});
	}
};

/* src/lib/journey/callbacks/boolean/boolean.svelte generated by Svelte v3.55.1 */

function create_default_slot$s(ctx) {
	let t_value = interpolate(textToKey(/*outputName*/ ctx[3]), null, /*prompt*/ ctx[5]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*outputName, prompt*/ 40 && t_value !== (t_value = interpolate(textToKey(/*outputName*/ ctx[3]), null, /*prompt*/ ctx[5]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (32:0) {#key callback}
function create_key_block$5(ctx) {
	let checkbox;
	let current;

	checkbox = new /*Checkbox*/ ctx[7]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[1]?.derived.isFirstInvalidInput || false,
				isInvalid: !!/*validationFailure*/ ctx[6],
				key: /*inputName*/ ctx[2],
				message: /*validationFailure*/ ctx[6],
				onChange: /*setValue*/ ctx[8],
				value: /*previousValue*/ ctx[4],
				$$slots: { default: [create_default_slot$s] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*callbackMetadata*/ 2) checkbox_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[1]?.derived.isFirstInvalidInput || false;
			if (dirty & /*validationFailure*/ 64) checkbox_changes.isInvalid = !!/*validationFailure*/ ctx[6];
			if (dirty & /*inputName*/ 4) checkbox_changes.key = /*inputName*/ ctx[2];
			if (dirty & /*validationFailure*/ 64) checkbox_changes.message = /*validationFailure*/ ctx[6];
			if (dirty & /*previousValue*/ 16) checkbox_changes.value = /*previousValue*/ ctx[4];

			if (dirty & /*$$scope, outputName, prompt*/ 4136) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

function create_fragment$U(ctx) {
	let previous_key = /*callback*/ ctx[0];
	let key_block_anchor;
	let current;
	let key_block = create_key_block$5(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*callback*/ 1 && safe_not_equal(previous_key, previous_key = /*callback*/ ctx[0])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block$5(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(key_block_anchor);
			key_block.d(detaching);
		}
	};
}

function instance$W($$self, $$props, $$invalidate) {
	const stepMetadata = null;
	const selfSubmitFunction = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { style = {} } = $$props;

	const Checkbox = style.checksAndRadios === 'standard'
	? Standard$1
	: Animated$1;

	let inputName;

	// A boolean being required doesn't make much sense, so commenting it out for now
	// let isRequired = isInputRequired(callback);
	let outputName;

	let previousValue;
	let prompt;
	let validationFailure;

	function setValue(event) {
		callback.setInputValue(event.target.checked);
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(0, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(1, callbackMetadata = $$props.callbackMetadata);
		if ('style' in $$props) $$invalidate(11, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata*/ 3) {
			{
				$$invalidate(2, inputName = callback?.payload?.input?.[0].name || `boolean-attr-${callbackMetadata?.idx}`);

				// A boolean being required doesn't make much sense, so commenting it out for now
				// isRequired = isInputRequired(callback);
				$$invalidate(3, outputName = callback.getOutputByName('name', ''));

				$$invalidate(4, previousValue = callback.getInputValue());
				$$invalidate(5, prompt = callback.getPrompt());
				$$invalidate(6, validationFailure = getAttributeValidationFailureText(callback));
			}
		}
	};

	return [
		callback,
		callbackMetadata,
		inputName,
		outputName,
		previousValue,
		prompt,
		validationFailure,
		Checkbox,
		setValue,
		stepMetadata,
		selfSubmitFunction,
		style
	];
}

let Boolean$1 = class Boolean extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$W, create_fragment$U, safe_not_equal, {
			stepMetadata: 9,
			selfSubmitFunction: 10,
			callback: 0,
			callbackMetadata: 1,
			style: 11
		});
	}

	get stepMetadata() {
		return this.$$.ctx[9];
	}

	get selfSubmitFunction() {
		return this.$$.ctx[10];
	}
};

/* src/lib/components/compositions/radio/animated.svelte generated by Svelte v3.55.1 */

function get_each_context$c(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	return child_ctx;
}

// (40:8) <Label           key={`${key}-${option.value}`}           classes="tw_input-spacing tw_grid tw_grid-cols-[2.5em_1fr] tw_relative"         >
function create_default_slot$r(ctx) {
	let span;
	let t0;
	let t1_value = /*option*/ ctx[13].text + "";
	let t1;

	return {
		c() {
			span = element("span");
			t0 = space();
			t1 = text(t1_value);
			attr(span, "class", "tw_animated-radio dark:tw_animated-radio_dark");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*options*/ 256 && t1_value !== (t1_value = /*option*/ ctx[13].text + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (27:4) {#each options as option}
function create_each_block$c(ctx) {
	let div;
	let input;
	let input_checked_value;
	let input_id_value;
	let input_value_value;
	let t0;
	let label;
	let t1;
	let current;
	let mounted;
	let dispose;

	label = new Label({
			props: {
				key: `${/*key*/ ctx[5]}-${/*option*/ ctx[13].value}`,
				classes: "tw_input-spacing tw_grid tw_grid-cols-[2.5em_1fr] tw_relative",
				$$slots: { default: [create_default_slot$r] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			input = element("input");
			t0 = space();
			create_component(label.$$.fragment);
			t1 = space();
			attr(input, "class", "tw_radio-input_animated dark:tw_radio-input_animated_dark tw_sr-only");
			input.checked = input_checked_value = /*defaultOption*/ ctx[0] === /*option*/ ctx[13].value;
			attr(input, "id", input_id_value = `${/*key*/ ctx[5]}-${/*option*/ ctx[13].value}`);
			attr(input, "name", /*name*/ ctx[6]);
			input.required = /*isRequired*/ ctx[3];
			attr(input, "type", "radio");
			input.value = input_value_value = /*option*/ ctx[13].value;
			attr(div, "class", "tw_input-spacing");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			/*input_binding*/ ctx[12](input);
			append(div, t0);
			mount_component(label, div, null);
			append(div, t1);
			current = true;

			if (!mounted) {
				dispose = listen(input, "change", function () {
					if (is_function(/*onChange*/ ctx[7])) /*onChange*/ ctx[7].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty & /*defaultOption, options*/ 257 && input_checked_value !== (input_checked_value = /*defaultOption*/ ctx[0] === /*option*/ ctx[13].value)) {
				input.checked = input_checked_value;
			}

			if (!current || dirty & /*key, options*/ 288 && input_id_value !== (input_id_value = `${/*key*/ ctx[5]}-${/*option*/ ctx[13].value}`)) {
				attr(input, "id", input_id_value);
			}

			if (!current || dirty & /*name*/ 64) {
				attr(input, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty & /*isRequired*/ 8) {
				input.required = /*isRequired*/ ctx[3];
			}

			if (!current || dirty & /*options*/ 256 && input_value_value !== (input_value_value = /*option*/ ctx[13].value)) {
				input.value = input_value_value;
			}

			const label_changes = {};
			if (dirty & /*key, options*/ 288) label_changes.key = `${/*key*/ ctx[5]}-${/*option*/ ctx[13].value}`;

			if (dirty & /*$$scope, options*/ 65792) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*input_binding*/ ctx[12](null);
			destroy_component(label);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$T(ctx) {
	let fieldset;
	let legend;
	let t0;
	let t1;
	let div;
	let t2;
	let span;
	let message_1;
	let current;
	let each_value = /*options*/ ctx[8];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	message_1 = new Input_message({
			props: {
				dirtyMessage: /*message*/ ctx[1],
				key: /*key*/ ctx[5],
				showMessage: /*showMessage*/ ctx[9],
				type: /*isInvalid*/ ctx[4] ? 'error' : 'info'
			}
		});

	return {
		c() {
			fieldset = element("fieldset");
			legend = element("legend");
			t0 = text(/*groupLabel*/ ctx[2]);
			t1 = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			span = element("span");
			create_component(message_1.$$.fragment);
			attr(legend, "class", "tw_input-label dark:tw_input-label_dark tw_font-bold tw_mb-4");
			attr(span, "class", "tw_col-start-2 tw_row-start-2");
		},
		m(target, anchor) {
			insert(target, fieldset, anchor);
			append(fieldset, legend);
			append(legend, t0);
			append(fieldset, t1);
			append(fieldset, div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t2);
			append(div, span);
			mount_component(message_1, span, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*groupLabel*/ 4) set_data(t0, /*groupLabel*/ ctx[2]);

			if (dirty & /*key, options, defaultOption, name, isRequired, inputEl, onChange*/ 1513) {
				each_value = /*options*/ ctx[8];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$c(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$c(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t2);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const message_1_changes = {};
			if (dirty & /*message*/ 2) message_1_changes.dirtyMessage = /*message*/ ctx[1];
			if (dirty & /*key*/ 32) message_1_changes.key = /*key*/ ctx[5];
			if (dirty & /*showMessage*/ 512) message_1_changes.showMessage = /*showMessage*/ ctx[9];
			if (dirty & /*isInvalid*/ 16) message_1_changes.type = /*isInvalid*/ ctx[4] ? 'error' : 'info';
			message_1.$set(message_1_changes);
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(message_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(message_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(fieldset);
			destroy_each(each_blocks, detaching);
			destroy_component(message_1);
		}
	};
}

function instance$V($$self, $$props, $$invalidate) {
	let { defaultOption = null } = $$props;
	let { message = '' } = $$props;
	let { groupLabel = '' } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { name } = $$props;
	let { onChange } = $$props;
	let { options } = $$props;
	let { showMessage = undefined } = $$props;
	let inputEl;

	afterUpdate(() => {
		if (isFirstInvalidInput) {
			inputEl.focus();
		}
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(10, inputEl);
		});
	}

	$$self.$$set = $$props => {
		if ('defaultOption' in $$props) $$invalidate(0, defaultOption = $$props.defaultOption);
		if ('message' in $$props) $$invalidate(1, message = $$props.message);
		if ('groupLabel' in $$props) $$invalidate(2, groupLabel = $$props.groupLabel);
		if ('isFirstInvalidInput' in $$props) $$invalidate(11, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(3, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(4, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(5, key = $$props.key);
		if ('name' in $$props) $$invalidate(6, name = $$props.name);
		if ('onChange' in $$props) $$invalidate(7, onChange = $$props.onChange);
		if ('options' in $$props) $$invalidate(8, options = $$props.options);
		if ('showMessage' in $$props) $$invalidate(9, showMessage = $$props.showMessage);
	};

	return [
		defaultOption,
		message,
		groupLabel,
		isRequired,
		isInvalid,
		key,
		name,
		onChange,
		options,
		showMessage,
		inputEl,
		isFirstInvalidInput,
		input_binding
	];
}

class Animated extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$V, create_fragment$T, safe_not_equal, {
			defaultOption: 0,
			message: 1,
			groupLabel: 2,
			isFirstInvalidInput: 11,
			isRequired: 3,
			isInvalid: 4,
			key: 5,
			name: 6,
			onChange: 7,
			options: 8,
			showMessage: 9
		});
	}
}

/* src/lib/components/primitives/radio/radio.svelte generated by Svelte v3.55.1 */

function create_default_slot$q(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$S(ctx) {
	let input;
	let input_aria_describedby_value;
	let t;
	let label;
	let current;
	let mounted;
	let dispose;

	label = new Label({
			props: {
				key: /*key*/ ctx[2],
				$$slots: { default: [create_default_slot$q] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			input = element("input");
			t = space();
			create_component(label.$$.fragment);
			attr(input, "aria-describedby", input_aria_describedby_value = `${/*key*/ ctx[2]}-message`);
			attr(input, "class", "tw_checkbox-input dark:tw_checkbox-input_dark tw_focusable-element dark:tw_focusable-element_dark");
			input.checked = /*checked*/ ctx[0];
			attr(input, "id", /*key*/ ctx[2]);
			attr(input, "name", /*name*/ ctx[3]);
			input.required = /*isRequired*/ ctx[1];
			attr(input, "type", "radio");
			input.value = /*value*/ ctx[5];
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[9](input);
			insert(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(input, "change", function () {
					if (is_function(/*onChange*/ ctx[4])) /*onChange*/ ctx[4].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (!current || dirty & /*key*/ 4 && input_aria_describedby_value !== (input_aria_describedby_value = `${/*key*/ ctx[2]}-message`)) {
				attr(input, "aria-describedby", input_aria_describedby_value);
			}

			if (!current || dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (!current || dirty & /*key*/ 4) {
				attr(input, "id", /*key*/ ctx[2]);
			}

			if (!current || dirty & /*name*/ 8) {
				attr(input, "name", /*name*/ ctx[3]);
			}

			if (!current || dirty & /*isRequired*/ 2) {
				input.required = /*isRequired*/ ctx[1];
			}

			if (!current || dirty & /*value*/ 32) {
				input.value = /*value*/ ctx[5];
			}

			const label_changes = {};
			if (dirty & /*key*/ 4) label_changes.key = /*key*/ ctx[2];

			if (dirty & /*$$scope*/ 1024) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding*/ ctx[9](null);
			if (detaching) detach(t);
			destroy_component(label, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$U($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { checked = false } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { key } = $$props;
	let { name } = $$props;
	let { onChange } = $$props;
	let { value } = $$props;
	let inputEl;

	afterUpdate(() => {
		if (isFirstInvalidInput) {
			inputEl.focus();
		}
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(6, inputEl);
		});
	}

	$$self.$$set = $$props => {
		if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
		if ('isFirstInvalidInput' in $$props) $$invalidate(7, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(1, isRequired = $$props.isRequired);
		if ('key' in $$props) $$invalidate(2, key = $$props.key);
		if ('name' in $$props) $$invalidate(3, name = $$props.name);
		if ('onChange' in $$props) $$invalidate(4, onChange = $$props.onChange);
		if ('value' in $$props) $$invalidate(5, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	return [
		checked,
		isRequired,
		key,
		name,
		onChange,
		value,
		inputEl,
		isFirstInvalidInput,
		slots,
		input_binding,
		$$scope
	];
}

class Radio extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$U, create_fragment$S, safe_not_equal, {
			checked: 0,
			isFirstInvalidInput: 7,
			isRequired: 1,
			key: 2,
			name: 3,
			onChange: 4,
			value: 5
		});
	}
}

/* src/lib/components/compositions/radio/standard.svelte generated by Svelte v3.55.1 */

function get_each_context$b(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (21:6) <Radio         checked={defaultOption === option.value}         {isFirstInvalidInput}         {isRequired}         key={`${key}-${option.value}`}         {name}         {onChange}         value={option.value}       >
function create_default_slot$p(ctx) {
	let t_value = /*option*/ ctx[11].text + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*options*/ 512 && t_value !== (t_value = /*option*/ ctx[11].text + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (19:2) {#each options as option}
function create_each_block$b(ctx) {
	let div;
	let radio;
	let t;
	let current;

	radio = new Radio({
			props: {
				checked: /*defaultOption*/ ctx[0] === /*option*/ ctx[11].value,
				isFirstInvalidInput: /*isFirstInvalidInput*/ ctx[3],
				isRequired: /*isRequired*/ ctx[4],
				key: `${/*key*/ ctx[6]}-${/*option*/ ctx[11].value}`,
				name: /*name*/ ctx[7],
				onChange: /*onChange*/ ctx[8],
				value: /*option*/ ctx[11].value,
				$$slots: { default: [create_default_slot$p] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(radio.$$.fragment);
			t = space();
			attr(div, "class", "tw_input-spacing tw_grid tw_grid-cols-[1.5em_1fr]");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(radio, div, null);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			const radio_changes = {};
			if (dirty & /*defaultOption, options*/ 513) radio_changes.checked = /*defaultOption*/ ctx[0] === /*option*/ ctx[11].value;
			if (dirty & /*isFirstInvalidInput*/ 8) radio_changes.isFirstInvalidInput = /*isFirstInvalidInput*/ ctx[3];
			if (dirty & /*isRequired*/ 16) radio_changes.isRequired = /*isRequired*/ ctx[4];
			if (dirty & /*key, options*/ 576) radio_changes.key = `${/*key*/ ctx[6]}-${/*option*/ ctx[11].value}`;
			if (dirty & /*name*/ 128) radio_changes.name = /*name*/ ctx[7];
			if (dirty & /*onChange*/ 256) radio_changes.onChange = /*onChange*/ ctx[8];
			if (dirty & /*options*/ 512) radio_changes.value = /*option*/ ctx[11].value;

			if (dirty & /*$$scope, options*/ 16896) {
				radio_changes.$$scope = { dirty, ctx };
			}

			radio.$set(radio_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(radio);
		}
	};
}

function create_fragment$R(ctx) {
	let fieldset;
	let legend;
	let t0;
	let t1;
	let t2;
	let span;
	let message_1;
	let current;
	let each_value = /*options*/ ctx[9];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	message_1 = new Input_message({
			props: {
				dirtyMessage: /*message*/ ctx[1],
				key: /*key*/ ctx[6],
				showMessage: /*showMessage*/ ctx[10],
				type: /*isInvalid*/ ctx[5] ? 'error' : 'info'
			}
		});

	return {
		c() {
			fieldset = element("fieldset");
			legend = element("legend");
			t0 = text(/*groupLabel*/ ctx[2]);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			span = element("span");
			create_component(message_1.$$.fragment);
			attr(legend, "class", "tw_input-label dark:tw_input-label_dark tw_font-bold tw_mb-4");
			attr(span, "class", "tw_col-start-2 tw_row-start-2");
		},
		m(target, anchor) {
			insert(target, fieldset, anchor);
			append(fieldset, legend);
			append(legend, t0);
			append(fieldset, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(fieldset, null);
			}

			append(fieldset, t2);
			append(fieldset, span);
			mount_component(message_1, span, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*groupLabel*/ 4) set_data(t0, /*groupLabel*/ ctx[2]);

			if (dirty & /*defaultOption, options, isFirstInvalidInput, isRequired, key, name, onChange*/ 985) {
				each_value = /*options*/ ctx[9];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$b(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$b(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(fieldset, t2);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const message_1_changes = {};
			if (dirty & /*message*/ 2) message_1_changes.dirtyMessage = /*message*/ ctx[1];
			if (dirty & /*key*/ 64) message_1_changes.key = /*key*/ ctx[6];
			if (dirty & /*showMessage*/ 1024) message_1_changes.showMessage = /*showMessage*/ ctx[10];
			if (dirty & /*isInvalid*/ 32) message_1_changes.type = /*isInvalid*/ ctx[5] ? 'error' : 'info';
			message_1.$set(message_1_changes);
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(message_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(message_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(fieldset);
			destroy_each(each_blocks, detaching);
			destroy_component(message_1);
		}
	};
}

function instance$T($$self, $$props, $$invalidate) {
	let { defaultOption = null } = $$props;
	let { message = '' } = $$props;
	let { groupLabel = '' } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { name } = $$props;
	let { onChange } = $$props;
	let { options } = $$props;
	let { showMessage = undefined } = $$props;

	$$self.$$set = $$props => {
		if ('defaultOption' in $$props) $$invalidate(0, defaultOption = $$props.defaultOption);
		if ('message' in $$props) $$invalidate(1, message = $$props.message);
		if ('groupLabel' in $$props) $$invalidate(2, groupLabel = $$props.groupLabel);
		if ('isFirstInvalidInput' in $$props) $$invalidate(3, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(4, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(5, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(6, key = $$props.key);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('onChange' in $$props) $$invalidate(8, onChange = $$props.onChange);
		if ('options' in $$props) $$invalidate(9, options = $$props.options);
		if ('showMessage' in $$props) $$invalidate(10, showMessage = $$props.showMessage);
	};

	return [
		defaultOption,
		message,
		groupLabel,
		isFirstInvalidInput,
		isRequired,
		isInvalid,
		key,
		name,
		onChange,
		options,
		showMessage
	];
}

class Standard extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$T, create_fragment$R, safe_not_equal, {
			defaultOption: 0,
			message: 1,
			groupLabel: 2,
			isFirstInvalidInput: 3,
			isRequired: 4,
			isInvalid: 5,
			key: 6,
			name: 7,
			onChange: 8,
			options: 9,
			showMessage: 10
		});
	}
}

/* src/lib/components/primitives/select/select.svelte generated by Svelte v3.55.1 */

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	return child_ctx;
}

// (39:0) {#if labelOrder === 'first'}
function create_if_block_1$f(ctx) {
	let label_1;
	let current;

	label_1 = new Label({
			props: {
				key: /*key*/ ctx[4],
				classes: `${/*labelClasses*/ ctx[6]}`,
				$$slots: { default: [create_default_slot_1$h] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(label_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(label_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_1_changes = {};
			if (dirty & /*key*/ 16) label_1_changes.key = /*key*/ ctx[4];
			if (dirty & /*labelClasses*/ 64) label_1_changes.classes = `${/*labelClasses*/ ctx[6]}`;

			if (dirty & /*$$scope, label*/ 262176) {
				label_1_changes.$$scope = { dirty, ctx };
			}

			label_1.$set(label_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(label_1, detaching);
		}
	};
}

// (40:2) <Label {key} classes={`${labelClasses}`}>
function create_default_slot_1$h(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 32) set_data(t, /*label*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (54:2) {#each options as option}
function create_each_block$a(ctx) {
	let option;
	let t0_value = /*option*/ ctx[15].text + "";
	let t0;
	let t1;
	let option_value_value;
	let option_selected_value;

	return {
		c() {
			option = element("option");
			t0 = text(t0_value);
			t1 = space();
			option.__value = option_value_value = /*option*/ ctx[15].value;
			option.value = option.__value;
			option.selected = option_selected_value = /*option*/ ctx[15].value === /*defaultOption*/ ctx[1];
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t0);
			append(option, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*options*/ 256 && t0_value !== (t0_value = /*option*/ ctx[15].text + "")) set_data(t0, t0_value);

			if (dirty & /*options*/ 256 && option_value_value !== (option_value_value = /*option*/ ctx[15].value)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}

			if (dirty & /*options, defaultOption*/ 258 && option_selected_value !== (option_selected_value = /*option*/ ctx[15].value === /*defaultOption*/ ctx[1])) {
				option.selected = option_selected_value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (61:0) {#if labelOrder === 'last'}
function create_if_block$q(ctx) {
	let label_1;
	let current;

	label_1 = new Label({
			props: {
				key: /*key*/ ctx[4],
				classes: `${/*shouldDisplayOption*/ ctx[10]
				? /*labelClasses*/ ctx[6]
				: 'tw_sr-only'}`,
				$$slots: { default: [create_default_slot$o] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(label_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(label_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_1_changes = {};
			if (dirty & /*key*/ 16) label_1_changes.key = /*key*/ ctx[4];

			if (dirty & /*shouldDisplayOption, labelClasses*/ 1088) label_1_changes.classes = `${/*shouldDisplayOption*/ ctx[10]
			? /*labelClasses*/ ctx[6]
			: 'tw_sr-only'}`;

			if (dirty & /*$$scope, label*/ 262176) {
				label_1_changes.$$scope = { dirty, ctx };
			}

			label_1.$set(label_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(label_1, detaching);
		}
	};
}

// (62:2) <Label {key} classes={`${shouldDisplayOption ? labelClasses : 'tw_sr-only'}`}>
function create_default_slot$o(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 32) set_data(t, /*label*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$Q(ctx) {
	let t0;
	let select;
	let select_aria_describedby_value;
	let select_class_value;
	let t1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*labelOrder*/ ctx[7] === 'first' && create_if_block_1$f(ctx);
	let each_value = /*options*/ ctx[8];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	}

	let if_block1 = /*labelOrder*/ ctx[7] === 'last' && create_if_block$q(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(select, "aria-describedby", select_aria_describedby_value = `${/*key*/ ctx[4]}-message`);
			attr(select, "aria-invalid", /*isInvalid*/ ctx[3]);

			attr(select, "class", select_class_value = `${/*shouldDisplayOption*/ ctx[10]
			? /*selectClasses*/ ctx[0]
			: ''} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_select-base dark:tw_select-base_dark tw_w-full`);

			attr(select, "id", /*key*/ ctx[4]);
			select.required = /*isRequired*/ ctx[2];
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			/*select_binding*/ ctx[14](select);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(select, "change", /*onChangeWrapper*/ ctx[11]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*labelOrder*/ ctx[7] === 'first') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*labelOrder*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$f(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty & /*options, defaultOption*/ 258) {
				each_value = /*options*/ ctx[8];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$a(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$a(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*key*/ 16 && select_aria_describedby_value !== (select_aria_describedby_value = `${/*key*/ ctx[4]}-message`)) {
				attr(select, "aria-describedby", select_aria_describedby_value);
			}

			if (!current || dirty & /*isInvalid*/ 8) {
				attr(select, "aria-invalid", /*isInvalid*/ ctx[3]);
			}

			if (!current || dirty & /*shouldDisplayOption, selectClasses*/ 1025 && select_class_value !== (select_class_value = `${/*shouldDisplayOption*/ ctx[10]
			? /*selectClasses*/ ctx[0]
			: ''} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_select-base dark:tw_select-base_dark tw_w-full`)) {
				attr(select, "class", select_class_value);
			}

			if (!current || dirty & /*key*/ 16) {
				attr(select, "id", /*key*/ ctx[4]);
			}

			if (!current || dirty & /*isRequired*/ 4) {
				select.required = /*isRequired*/ ctx[2];
			}

			if (/*labelOrder*/ ctx[7] === 'last') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*labelOrder*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$q(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(select);
			destroy_each(each_blocks, detaching);
			/*select_binding*/ ctx[14](null);
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
			mounted = false;
			dispose();
		}
	};
}

function instance$S($$self, $$props, $$invalidate) {
	let { selectClasses = '' } = $$props;
	let { defaultOption = null } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { label } = $$props;
	let { labelClasses = '' } = $$props;
	let { labelOrder = 'first' } = $$props;
	let { onChange } = $$props;
	let { options } = $$props;
	let inputEl;
	let shouldDisplayOption = true;

	/**
 * If label and option share the same text, only display option
 */
	if (defaultOption === null && options[0].text === label) {
		shouldDisplayOption = false;
	}

	afterUpdate(() => {
		if (isFirstInvalidInput) {
			inputEl.focus();
		}
	});

	function onChangeWrapper(event) {
		const value = event.target.value;

		const selectedOption = options.find(option => {
			return String(option.value) === value;
		});

		// Check if text is same as label
		$$invalidate(10, shouldDisplayOption = !(label === selectedOption?.text));

		// Continue with calling onChange parameter
		onChange(event);
	}

	function select_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(9, inputEl);
			$$invalidate(8, options);
		});
	}

	$$self.$$set = $$props => {
		if ('selectClasses' in $$props) $$invalidate(0, selectClasses = $$props.selectClasses);
		if ('defaultOption' in $$props) $$invalidate(1, defaultOption = $$props.defaultOption);
		if ('isFirstInvalidInput' in $$props) $$invalidate(12, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(2, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(3, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(4, key = $$props.key);
		if ('label' in $$props) $$invalidate(5, label = $$props.label);
		if ('labelClasses' in $$props) $$invalidate(6, labelClasses = $$props.labelClasses);
		if ('labelOrder' in $$props) $$invalidate(7, labelOrder = $$props.labelOrder);
		if ('onChange' in $$props) $$invalidate(13, onChange = $$props.onChange);
		if ('options' in $$props) $$invalidate(8, options = $$props.options);
	};

	return [
		selectClasses,
		defaultOption,
		isRequired,
		isInvalid,
		key,
		label,
		labelClasses,
		labelOrder,
		options,
		inputEl,
		shouldDisplayOption,
		onChangeWrapper,
		isFirstInvalidInput,
		onChange,
		select_binding
	];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$S, create_fragment$Q, safe_not_equal, {
			selectClasses: 0,
			defaultOption: 1,
			isFirstInvalidInput: 12,
			isRequired: 2,
			isInvalid: 3,
			key: 4,
			label: 5,
			labelClasses: 6,
			labelOrder: 7,
			onChange: 13,
			options: 8
		});
	}
}

/* src/lib/components/compositions/select-floating/floating-label.svelte generated by Svelte v3.55.1 */

function create_fragment$P(ctx) {
	let div;
	let select;
	let t;
	let message_1;
	let current;

	select = new Select({
			props: {
				defaultOption: /*defaultOption*/ ctx[1],
				isFirstInvalidInput: /*isFirstInvalidInput*/ ctx[3],
				isRequired: /*isRequired*/ ctx[4],
				isInvalid: /*isInvalid*/ ctx[0],
				key: /*key*/ ctx[5],
				label: /*label*/ ctx[6],
				labelClasses: "tw_absolute tw_input-floating-label tw_select-floating-label",
				labelOrder: "last",
				onChange: /*onChangeWrapper*/ ctx[9],
				options: /*options*/ ctx[7],
				selectClasses: "tw_select-floating"
			}
		});

	message_1 = new Input_message({
			props: {
				dirtyMessage: /*message*/ ctx[2],
				key: /*key*/ ctx[5],
				showMessage: /*showMessage*/ ctx[8],
				type: /*isInvalid*/ ctx[0] ? 'error' : 'info'
			}
		});

	return {
		c() {
			div = element("div");
			create_component(select.$$.fragment);
			t = space();
			create_component(message_1.$$.fragment);
			attr(div, "class", `tw_input-spacing tw_relative`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(select, div, null);
			append(div, t);
			mount_component(message_1, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const select_changes = {};
			if (dirty & /*defaultOption*/ 2) select_changes.defaultOption = /*defaultOption*/ ctx[1];
			if (dirty & /*isFirstInvalidInput*/ 8) select_changes.isFirstInvalidInput = /*isFirstInvalidInput*/ ctx[3];
			if (dirty & /*isRequired*/ 16) select_changes.isRequired = /*isRequired*/ ctx[4];
			if (dirty & /*isInvalid*/ 1) select_changes.isInvalid = /*isInvalid*/ ctx[0];
			if (dirty & /*key*/ 32) select_changes.key = /*key*/ ctx[5];
			if (dirty & /*label*/ 64) select_changes.label = /*label*/ ctx[6];
			if (dirty & /*options*/ 128) select_changes.options = /*options*/ ctx[7];
			select.$set(select_changes);
			const message_1_changes = {};
			if (dirty & /*message*/ 4) message_1_changes.dirtyMessage = /*message*/ ctx[2];
			if (dirty & /*key*/ 32) message_1_changes.key = /*key*/ ctx[5];
			if (dirty & /*showMessage*/ 256) message_1_changes.showMessage = /*showMessage*/ ctx[8];
			if (dirty & /*isInvalid*/ 1) message_1_changes.type = /*isInvalid*/ ctx[0] ? 'error' : 'info';
			message_1.$set(message_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			transition_in(message_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			transition_out(message_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(select);
			destroy_component(message_1);
		}
	};
}

function instance$R($$self, $$props, $$invalidate) {
	let { checkValidity = null } = $$props;
	let { defaultOption = null } = $$props;
	let { message = '' } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { label } = $$props;
	let { onChange } = $$props;
	let { options } = $$props;
	let { showMessage = undefined } = $$props;

	function onChangeWrapper(event) {
		if (checkValidity) {
			$$invalidate(0, isInvalid = !checkValidity(event));
		}

		onChange(event);
	}

	$$self.$$set = $$props => {
		if ('checkValidity' in $$props) $$invalidate(10, checkValidity = $$props.checkValidity);
		if ('defaultOption' in $$props) $$invalidate(1, defaultOption = $$props.defaultOption);
		if ('message' in $$props) $$invalidate(2, message = $$props.message);
		if ('isFirstInvalidInput' in $$props) $$invalidate(3, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(4, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(0, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(5, key = $$props.key);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('onChange' in $$props) $$invalidate(11, onChange = $$props.onChange);
		if ('options' in $$props) $$invalidate(7, options = $$props.options);
		if ('showMessage' in $$props) $$invalidate(8, showMessage = $$props.showMessage);
	};

	return [
		isInvalid,
		defaultOption,
		message,
		isFirstInvalidInput,
		isRequired,
		key,
		label,
		options,
		showMessage,
		onChangeWrapper,
		checkValidity,
		onChange
	];
}

let Floating_label$1 = class Floating_label extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$R, create_fragment$P, safe_not_equal, {
			checkValidity: 10,
			defaultOption: 1,
			message: 2,
			isFirstInvalidInput: 3,
			isRequired: 4,
			isInvalid: 0,
			key: 5,
			label: 6,
			onChange: 11,
			options: 7,
			showMessage: 8
		});
	}
};

/* src/lib/components/compositions/select-stacked/stacked-label.svelte generated by Svelte v3.55.1 */

function create_fragment$O(ctx) {
	let div;
	let select;
	let t;
	let message_1;
	let current;

	select = new Select({
			props: {
				defaultOption: /*defaultOption*/ ctx[1],
				isFirstInvalidInput: /*isFirstInvalidInput*/ ctx[3],
				isRequired: /*isRequired*/ ctx[4],
				isInvalid: /*isInvalid*/ ctx[0],
				key: /*key*/ ctx[5],
				label: /*label*/ ctx[6],
				labelClasses: "tw_input-stacked-label",
				labelOrder: "first",
				onChange: /*onChangeWrapper*/ ctx[9],
				options: /*options*/ ctx[7]
			}
		});

	message_1 = new Input_message({
			props: {
				dirtyMessage: /*message*/ ctx[2],
				key: /*key*/ ctx[5],
				showMessage: /*showMessage*/ ctx[8],
				type: /*isInvalid*/ ctx[0] ? 'error' : 'info'
			}
		});

	return {
		c() {
			div = element("div");
			create_component(select.$$.fragment);
			t = space();
			create_component(message_1.$$.fragment);
			attr(div, "class", "tw_input-spacing");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(select, div, null);
			append(div, t);
			mount_component(message_1, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const select_changes = {};
			if (dirty & /*defaultOption*/ 2) select_changes.defaultOption = /*defaultOption*/ ctx[1];
			if (dirty & /*isFirstInvalidInput*/ 8) select_changes.isFirstInvalidInput = /*isFirstInvalidInput*/ ctx[3];
			if (dirty & /*isRequired*/ 16) select_changes.isRequired = /*isRequired*/ ctx[4];
			if (dirty & /*isInvalid*/ 1) select_changes.isInvalid = /*isInvalid*/ ctx[0];
			if (dirty & /*key*/ 32) select_changes.key = /*key*/ ctx[5];
			if (dirty & /*label*/ 64) select_changes.label = /*label*/ ctx[6];
			if (dirty & /*options*/ 128) select_changes.options = /*options*/ ctx[7];
			select.$set(select_changes);
			const message_1_changes = {};
			if (dirty & /*message*/ 4) message_1_changes.dirtyMessage = /*message*/ ctx[2];
			if (dirty & /*key*/ 32) message_1_changes.key = /*key*/ ctx[5];
			if (dirty & /*showMessage*/ 256) message_1_changes.showMessage = /*showMessage*/ ctx[8];
			if (dirty & /*isInvalid*/ 1) message_1_changes.type = /*isInvalid*/ ctx[0] ? 'error' : 'info';
			message_1.$set(message_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			transition_in(message_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			transition_out(message_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(select);
			destroy_component(message_1);
		}
	};
}

function instance$Q($$self, $$props, $$invalidate) {
	let { checkValidity = null } = $$props;
	let { defaultOption = null } = $$props;
	let { message = '' } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { label } = $$props;
	let { onChange } = $$props;
	let { options } = $$props;
	let { showMessage = undefined } = $$props;

	function onChangeWrapper(event) {
		if (checkValidity) {
			$$invalidate(0, isInvalid = !checkValidity(event));
		}

		onChange(event);
	}

	$$self.$$set = $$props => {
		if ('checkValidity' in $$props) $$invalidate(10, checkValidity = $$props.checkValidity);
		if ('defaultOption' in $$props) $$invalidate(1, defaultOption = $$props.defaultOption);
		if ('message' in $$props) $$invalidate(2, message = $$props.message);
		if ('isFirstInvalidInput' in $$props) $$invalidate(3, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('isRequired' in $$props) $$invalidate(4, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(0, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(5, key = $$props.key);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('onChange' in $$props) $$invalidate(11, onChange = $$props.onChange);
		if ('options' in $$props) $$invalidate(7, options = $$props.options);
		if ('showMessage' in $$props) $$invalidate(8, showMessage = $$props.showMessage);
	};

	return [
		isInvalid,
		defaultOption,
		message,
		isFirstInvalidInput,
		isRequired,
		key,
		label,
		options,
		showMessage,
		onChangeWrapper,
		checkValidity,
		onChange
	];
}

let Stacked_label$1 = class Stacked_label extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$Q, create_fragment$O, safe_not_equal, {
			checkValidity: 10,
			defaultOption: 1,
			message: 2,
			isFirstInvalidInput: 3,
			isRequired: 4,
			isInvalid: 0,
			key: 5,
			label: 6,
			onChange: 11,
			options: 7,
			showMessage: 8
		});
	}
};

/* src/lib/journey/callbacks/choice/choice.svelte generated by Svelte v3.55.1 */

function create_else_block$9(ctx) {
	let select;
	let current;

	select = new /*Select*/ ctx[7]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false,
				defaultOption: /*defaultChoice*/ ctx[5],
				isRequired: false,
				key: /*inputName*/ ctx[3],
				label: /*label*/ ctx[4],
				onChange: /*setValue*/ ctx[8],
				options: /*choiceOptions*/ ctx[2]
			}
		});

	return {
		c() {
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty & /*callbackMetadata*/ 1) select_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false;
			if (dirty & /*defaultChoice*/ 32) select_changes.defaultOption = /*defaultChoice*/ ctx[5];
			if (dirty & /*inputName*/ 8) select_changes.key = /*inputName*/ ctx[3];
			if (dirty & /*label*/ 16) select_changes.label = /*label*/ ctx[4];
			if (dirty & /*choiceOptions*/ 4) select_changes.options = /*choiceOptions*/ ctx[2];
			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
		}
	};
}

// (52:0) {#if callbackMetadata?.platform?.displayType === 'radio'}
function create_if_block$p(ctx) {
	let radio;
	let current;

	radio = new /*Radio*/ ctx[6]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false,
				defaultOption: /*defaultChoice*/ ctx[5],
				isRequired: false,
				key: /*inputName*/ ctx[3],
				groupLabel: /*prompt*/ ctx[1],
				onChange: /*setValue*/ ctx[8],
				name: /*inputName*/ ctx[3],
				options: /*choiceOptions*/ ctx[2]
			}
		});

	return {
		c() {
			create_component(radio.$$.fragment);
		},
		m(target, anchor) {
			mount_component(radio, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radio_changes = {};
			if (dirty & /*callbackMetadata*/ 1) radio_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false;
			if (dirty & /*defaultChoice*/ 32) radio_changes.defaultOption = /*defaultChoice*/ ctx[5];
			if (dirty & /*inputName*/ 8) radio_changes.key = /*inputName*/ ctx[3];
			if (dirty & /*prompt*/ 2) radio_changes.groupLabel = /*prompt*/ ctx[1];
			if (dirty & /*inputName*/ 8) radio_changes.name = /*inputName*/ ctx[3];
			if (dirty & /*choiceOptions*/ 4) radio_changes.options = /*choiceOptions*/ ctx[2];
			radio.$set(radio_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radio, detaching);
		}
	};
}

function create_fragment$N(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$p, create_else_block$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*callbackMetadata*/ ctx[0]?.platform?.displayType === 'radio') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$P($$self, $$props, $$invalidate) {
	const selfSubmitFunction = null;
	const stepMetadata = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { style = {} } = $$props;

	const Radio = style.checksAndRadios === 'standard'
	? Standard
	: Animated;

	const Select = style.labels === 'stacked'
	? Stacked_label$1
	: Floating_label$1;

	let choiceOptions;
	let inputName;

	/**
 * Since locale content keys for the choice component are built off of the
 * values, there will not be any existing key-value pairs in the provided
 * content. The third argument here, the original value, is what will be
 * displayed. If you want to localize it, you'll need to add content keys
 * in the locale file for that to override the original value.
 */
	let label;

	let prompt;
	let defaultChoice;

	/**
 * @function setValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setValue(event) {
		callback.setChoiceIndex(Number(event.target.value));
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(11, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(0, callbackMetadata = $$props.callbackMetadata);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata, prompt*/ 2051) {
			{
				$$invalidate(2, choiceOptions = callback.getChoices()?.map((text, idx) => ({
					/**
 * Since locale content keys for the choice component are built off of the
 * values, there will not be any existing key-value pairs in the provided
 * content. The third argument here, the original value, is what will be
 * displayed. If you want to localize it, you'll need to add content keys
 * in the locale file for that to override the original value.
 */
					text: interpolate(textToKey(text), null, text),
					value: `${idx}`
				})));

				$$invalidate(5, defaultChoice = `${callback.getDefaultChoice()}` || null);
				$$invalidate(3, inputName = callback?.payload?.input?.[0].name || `choice-${callbackMetadata?.idx}`);
				$$invalidate(1, prompt = callback.getPrompt());
				$$invalidate(4, label = interpolate(textToKey(prompt), null, prompt));
			}
		}
	};

	return [
		callbackMetadata,
		prompt,
		choiceOptions,
		inputName,
		label,
		defaultChoice,
		Radio,
		Select,
		setValue,
		selfSubmitFunction,
		stepMetadata,
		callback,
		style
	];
}

class Choice extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$P, create_fragment$N, safe_not_equal, {
			selfSubmitFunction: 9,
			stepMetadata: 10,
			callback: 11,
			callbackMetadata: 0,
			style: 12
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[9];
	}

	get stepMetadata() {
		return this.$$.ctx[10];
	}
}

/* src/lib/components/primitives/grid/grid.svelte generated by Svelte v3.55.1 */

function create_fragment$M(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", div_class_value = `${generateClassString(/*num*/ ctx[0])} tw_gap-4 tw_grid tw_grid-cols-1 tw_input-spacing`);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*num*/ 1 && div_class_value !== (div_class_value = `${generateClassString(/*num*/ ctx[0])} tw_gap-4 tw_grid tw_grid-cols-1 tw_input-spacing`)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function generateClassString(...args) {
	return args.reduce(
		(prev, curr) => {
			switch (curr) {
				case 4:
					return `${prev} md:tw_grid-cols-4`;
				case 3:
					return `${prev} md:tw_grid-cols-3`;
				case 2:
					return `${prev} md:tw_grid-cols-2`;
				default:
					return `${prev} md:tw_grid-cols-1`;
			}
		},
		''
	);
}

function instance$O($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { num = 2 } = $$props;

	$$self.$$set = $$props => {
		if ('num' in $$props) $$invalidate(0, num = $$props.num);
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [num, $$scope, slots];
}

class Grid extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$O, create_fragment$M, safe_not_equal, { num: 0 });
	}
}

/* src/lib/journey/callbacks/confirmation/confirmation.svelte generated by Svelte v3.55.1 */

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	return child_ctx;
}

// (101:0) {:else}
function create_else_block_1$1(ctx) {
	let grid;
	let current;

	grid = new Grid({
			props: {
				num: /*options*/ ctx[3].length >= 2 ? 2 : 1,
				$$slots: { default: [create_default_slot_1$g] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(grid.$$.fragment);
		},
		m(target, anchor) {
			mount_component(grid, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const grid_changes = {};
			if (dirty & /*options*/ 8) grid_changes.num = /*options*/ ctx[3].length >= 2 ? 2 : 1;

			if (dirty & /*$$scope, options, defaultChoice, buttonStyle*/ 262200) {
				grid_changes.$$scope = { dirty, ctx };
			}

			grid.$set(grid_changes);
		},
		i(local) {
			if (current) return;
			transition_in(grid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(grid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(grid, detaching);
		}
	};
}

// (80:0) {#if !stepMetadata?.derived.isStepSelfSubmittable()}
function create_if_block$o(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$e, create_else_block$8];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*options*/ ctx[3].length > 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (104:6) <Button         style={options.length > 1 && defaultChoice === Number(opt.value) ? 'primary' : buttonStyle}         type="button"         width="auto"         onClick={() => setBtnValue(Number(opt.value))}       >
function create_default_slot_2$9(ctx) {
	let t0_value = /*opt*/ ctx[15].text + "";
	let t0;
	let t1;

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*options*/ 8 && t0_value !== (t0_value = /*opt*/ ctx[15].text + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (103:4) {#each options as opt}
function create_each_block$9(ctx) {
	let button;
	let current;

	function func() {
		return /*func*/ ctx[14](/*opt*/ ctx[15]);
	}

	button = new Button({
			props: {
				style: /*options*/ ctx[3].length > 1 && /*defaultChoice*/ ctx[5] === Number(/*opt*/ ctx[15].value)
				? 'primary'
				: /*buttonStyle*/ ctx[4],
				type: "button",
				width: "auto",
				onClick: func,
				$$slots: { default: [create_default_slot_2$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};

			if (dirty & /*options, defaultChoice, buttonStyle*/ 56) button_changes.style = /*options*/ ctx[3].length > 1 && /*defaultChoice*/ ctx[5] === Number(/*opt*/ ctx[15].value)
			? 'primary'
			: /*buttonStyle*/ ctx[4];

			if (dirty & /*options*/ 8) button_changes.onClick = func;

			if (dirty & /*$$scope, options*/ 262152) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (102:2) <Grid num={options.length >= 2 ? 2 : 1}>
function create_default_slot_1$g(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*options*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*options, defaultChoice, Number, buttonStyle, setBtnValue*/ 312) {
				each_value = /*options*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (90:2) {:else}
function create_else_block$8(ctx) {
	let checkbox;
	let current;

	checkbox = new /*Checkbox*/ ctx[7]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false,
				isInvalid: false,
				key: /*inputName*/ ctx[6],
				onChange: /*setCheckboxValue*/ ctx[10],
				value: false,
				$$slots: { default: [create_default_slot$n] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*callbackMetadata*/ 1) checkbox_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false;
			if (dirty & /*inputName*/ 64) checkbox_changes.key = /*inputName*/ ctx[6];

			if (dirty & /*$$scope, options*/ 262152) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(checkbox, detaching);
		}
	};
}

// (81:2) {#if options.length > 1}
function create_if_block_1$e(ctx) {
	let select;
	let current;

	select = new Floating_label$1({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false,
				isRequired: false,
				key: /*inputName*/ ctx[6],
				label: /*label*/ ctx[2],
				onChange: /*setOptionValue*/ ctx[9],
				options: /*options*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty & /*callbackMetadata*/ 1) select_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false;
			if (dirty & /*inputName*/ 64) select_changes.key = /*inputName*/ ctx[6];
			if (dirty & /*label*/ 4) select_changes.label = /*label*/ ctx[2];
			if (dirty & /*options*/ 8) select_changes.options = /*options*/ ctx[3];
			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
		}
	};
}

// (91:4) <Checkbox       isFirstInvalidInput={callbackMetadata?.derived.isFirstInvalidInput || false}       isInvalid={false}       key={inputName}       onChange={setCheckboxValue}       value={false}     >
function create_default_slot$n(ctx) {
	let t_value = /*options*/ ctx[3][0].text + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*options*/ 8 && t_value !== (t_value = /*options*/ ctx[3][0].text + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$L(ctx) {
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$o, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*stepMetadata*/ 2) show_if = null;
		if (show_if == null) show_if = !!!/*stepMetadata*/ ctx[1]?.derived.isStepSelfSubmittable();
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$N($$self, $$props, $$invalidate) {
	const style = {};
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { selfSubmitFunction = null } = $$props;
	let { stepMetadata } = $$props;

	const Checkbox = style.checksAndRadios === 'standard'
	? Standard$1
	: Animated$1;

	let buttonStyle;
	let defaultChoice = callback.getDefaultOption();
	let inputName;
	let label;
	let options;

	/**
 * @function setButtonValue - Sets the value on the callback on button click
 * @param {number} index
 */
	function setBtnValue(index) {
		callback.setOptionIndex(index);

		if (callbackMetadata) {
			$$invalidate(0, callbackMetadata.derived.isReadyForSubmission = true, callbackMetadata);
		}

		selfSubmitFunction && selfSubmitFunction();
	}

	/**
 * @function setOptionValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setOptionValue(event) {
		callback.setOptionIndex(Number(event.target.value));
	}

	/**
 * @function setOptionValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setCheckboxValue(event) {
		const value = event.target.checked;

		if (value) {
			callback.setOptionIndex(0);
		} else {
			// If checkbox is unset, revert back to default choice
			callback.setOptionIndex(defaultChoice);
		}
	}

	if (callback.getInputValue() === 0) {
		/**
 * If input value is 0 (falsy value), then let's make sure it's set to the default value
 * There's a case when the input value is 100, and for that we leave it at 100
 */
		callback.setOptionIndex(defaultChoice);
	}

	const func = opt => setBtnValue(Number(opt.value));

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(12, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(0, callbackMetadata = $$props.callbackMetadata);
		if ('selfSubmitFunction' in $$props) $$invalidate(13, selfSubmitFunction = $$props.selfSubmitFunction);
		if ('stepMetadata' in $$props) $$invalidate(1, stepMetadata = $$props.stepMetadata);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata, options, stepMetadata, label*/ 4111) {
			{
				$$invalidate(6, inputName = callback?.payload?.input?.[0].name || `confirmation-${callbackMetadata?.idx}`);
				$$invalidate(3, options = callback.getOptions().map((option, index) => ({ value: `${index}`, text: option })));
				$$invalidate(5, defaultChoice = callback.getDefaultOption());
				$$invalidate(2, label = interpolate(textToKey('pleaseConfirm'), null, 'Please Confirm'));

				if (callbackMetadata?.platform?.showOnlyPositiveAnswer) {
					// The positive option is always first in the `options` array
					$$invalidate(3, options = options.slice(0, 1));
				}

				if (!stepMetadata?.derived.isStepSelfSubmittable() && options.length > 1) {
					// Since the user needs to confirm, add this empty `value` to force selection
					options.unshift({ value: '', text: label });
				} else if (options.length === 1) {
					$$invalidate(4, buttonStyle = 'outline');
				} else {
					$$invalidate(4, buttonStyle = 'secondary');
				}
			}
		}
	};

	return [
		callbackMetadata,
		stepMetadata,
		label,
		options,
		buttonStyle,
		defaultChoice,
		inputName,
		Checkbox,
		setBtnValue,
		setOptionValue,
		setCheckboxValue,
		style,
		callback,
		selfSubmitFunction,
		func
	];
}

class Confirmation extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$N, create_fragment$L, safe_not_equal, {
			style: 11,
			callback: 12,
			callbackMetadata: 0,
			selfSubmitFunction: 13,
			stepMetadata: 1
		});
	}

	get style() {
		return this.$$.ctx[11];
	}
}

/* src/lib/journey/callbacks/hidden-value/hidden-value.svelte generated by Svelte v3.55.1 */

function instance$M($$self, $$props, $$invalidate) {
	const callback = null;
	const callbackMetadata = null;
	const selfSubmitFunction = null;
	const stepMetadata = null;
	const style = {};
	return [callback, callbackMetadata, selfSubmitFunction, stepMetadata, style];
}

class Hidden_value extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$M, null, safe_not_equal, {
			callback: 0,
			callbackMetadata: 1,
			selfSubmitFunction: 2,
			stepMetadata: 3,
			style: 4
		});
	}

	get callback() {
		return this.$$.ctx[0];
	}

	get callbackMetadata() {
		return this.$$.ctx[1];
	}

	get selfSubmitFunction() {
		return this.$$.ctx[2];
	}

	get stepMetadata() {
		return this.$$.ctx[3];
	}

	get style() {
		return this.$$.ctx[4];
	}
}

/* src/lib/components/primitives/input/input.svelte generated by Svelte v3.55.1 */

function create_if_block_7$1(ctx) {
	let label_1;
	let current;

	label_1 = new Label({
			props: {
				key: /*key*/ ctx[3],
				classes: `${/*labelClasses*/ ctx[5]} tw_w-full tw_ml-1`,
				$$slots: { default: [create_default_slot_1$f] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(label_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(label_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_1_changes = {};
			if (dirty & /*key*/ 8) label_1_changes.key = /*key*/ ctx[3];
			if (dirty & /*labelClasses*/ 32) label_1_changes.classes = `${/*labelClasses*/ ctx[5]} tw_w-full tw_ml-1`;

			if (dirty & /*$$scope, label*/ 67108880) {
				label_1_changes.$$scope = { dirty, ctx };
			}

			label_1.$set(label_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(label_1, detaching);
		}
	};
}

// (25:2) <Label {key} classes={`${labelClasses} tw_w-full tw_ml-1`}>
function create_default_slot_1$f(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 16) set_data(t, /*label*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (33:0) {#if type === 'date'}
function create_if_block_6$1(ctx) {
	let input;
	let input_aria_describedby_value;
	let input_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "aria-describedby", input_aria_describedby_value = `${/*key*/ ctx[3]}-message`);
			attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			attr(input, "class", input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`);
			attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			attr(input, "id", /*key*/ ctx[3]);
			attr(input, "placeholder", /*placeholder*/ ctx[8]);
			input.required = /*isRequired*/ ctx[9];
			attr(input, "type", "date");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[14](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "change", function () {
						if (is_function(/*onChange*/ ctx[7])) /*onChange*/ ctx[7].apply(this, arguments);
					}),
					listen(input, "input", /*input_input_handler*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*key*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = `${/*key*/ ctx[3]}-message`)) {
				attr(input, "aria-describedby", input_aria_describedby_value);
			}

			if (dirty & /*isInvalid*/ 1024) {
				attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			}

			if (dirty & /*inputClasses*/ 4 && input_class_value !== (input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`)) {
				attr(input, "class", input_class_value);
			}

			if (dirty & /*forceValidityFailure*/ 2) {
				attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			}

			if (dirty & /*key*/ 8) {
				attr(input, "id", /*key*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 256) {
				attr(input, "placeholder", /*placeholder*/ ctx[8]);
			}

			if (dirty & /*isRequired*/ 512) {
				input.required = /*isRequired*/ ctx[9];
			}

			if (dirty & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (49:0) {#if type === 'email'}
function create_if_block_5$2(ctx) {
	let input;
	let input_aria_describedby_value;
	let input_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "aria-describedby", input_aria_describedby_value = `${/*key*/ ctx[3]}-message`);
			attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			attr(input, "class", input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`);
			attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			attr(input, "id", /*key*/ ctx[3]);
			attr(input, "placeholder", /*placeholder*/ ctx[8]);
			input.required = /*isRequired*/ ctx[9];
			attr(input, "type", "email");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding_1*/ ctx[16](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "change", function () {
						if (is_function(/*onChange*/ ctx[7])) /*onChange*/ ctx[7].apply(this, arguments);
					}),
					listen(input, "input", /*input_input_handler_1*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*key*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = `${/*key*/ ctx[3]}-message`)) {
				attr(input, "aria-describedby", input_aria_describedby_value);
			}

			if (dirty & /*isInvalid*/ 1024) {
				attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			}

			if (dirty & /*inputClasses*/ 4 && input_class_value !== (input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`)) {
				attr(input, "class", input_class_value);
			}

			if (dirty & /*forceValidityFailure*/ 2) {
				attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			}

			if (dirty & /*key*/ 8) {
				attr(input, "id", /*key*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 256) {
				attr(input, "placeholder", /*placeholder*/ ctx[8]);
			}

			if (dirty & /*isRequired*/ 512) {
				input.required = /*isRequired*/ ctx[9];
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding_1*/ ctx[16](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (65:0) {#if type === 'number'}
function create_if_block_4$6(ctx) {
	let input;
	let input_aria_describedby_value;
	let input_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "aria-describedby", input_aria_describedby_value = `${/*key*/ ctx[3]}-message`);
			attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			attr(input, "class", input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`);
			attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			attr(input, "id", /*key*/ ctx[3]);
			attr(input, "placeholder", /*placeholder*/ ctx[8]);
			input.required = /*isRequired*/ ctx[9];
			attr(input, "type", "number");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding_2*/ ctx[18](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "change", function () {
						if (is_function(/*onChange*/ ctx[7])) /*onChange*/ ctx[7].apply(this, arguments);
					}),
					listen(input, "input", /*input_input_handler_2*/ ctx[19])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*key*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = `${/*key*/ ctx[3]}-message`)) {
				attr(input, "aria-describedby", input_aria_describedby_value);
			}

			if (dirty & /*isInvalid*/ 1024) {
				attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			}

			if (dirty & /*inputClasses*/ 4 && input_class_value !== (input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`)) {
				attr(input, "class", input_class_value);
			}

			if (dirty & /*forceValidityFailure*/ 2) {
				attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			}

			if (dirty & /*key*/ 8) {
				attr(input, "id", /*key*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 256) {
				attr(input, "placeholder", /*placeholder*/ ctx[8]);
			}

			if (dirty & /*isRequired*/ 512) {
				input.required = /*isRequired*/ ctx[9];
			}

			if (dirty & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding_2*/ ctx[18](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (81:0) {#if type === 'password'}
function create_if_block_3$9(ctx) {
	let input;
	let input_aria_describedby_value;
	let input_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "aria-describedby", input_aria_describedby_value = `${/*key*/ ctx[3]}-message`);
			attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			attr(input, "class", input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`);
			attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			attr(input, "id", /*key*/ ctx[3]);
			attr(input, "placeholder", /*placeholder*/ ctx[8]);
			input.required = /*isRequired*/ ctx[9];
			attr(input, "type", "password");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding_3*/ ctx[20](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "change", function () {
						if (is_function(/*onChange*/ ctx[7])) /*onChange*/ ctx[7].apply(this, arguments);
					}),
					listen(input, "input", /*input_input_handler_3*/ ctx[21])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*key*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = `${/*key*/ ctx[3]}-message`)) {
				attr(input, "aria-describedby", input_aria_describedby_value);
			}

			if (dirty & /*isInvalid*/ 1024) {
				attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			}

			if (dirty & /*inputClasses*/ 4 && input_class_value !== (input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`)) {
				attr(input, "class", input_class_value);
			}

			if (dirty & /*forceValidityFailure*/ 2) {
				attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			}

			if (dirty & /*key*/ 8) {
				attr(input, "id", /*key*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 256) {
				attr(input, "placeholder", /*placeholder*/ ctx[8]);
			}

			if (dirty & /*isRequired*/ 512) {
				input.required = /*isRequired*/ ctx[9];
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding_3*/ ctx[20](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (97:0) {#if type === 'phone'}
function create_if_block_2$a(ctx) {
	let input;
	let input_aria_describedby_value;
	let input_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "aria-describedby", input_aria_describedby_value = `${/*key*/ ctx[3]}-message`);
			attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			attr(input, "class", input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`);
			attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			attr(input, "id", /*key*/ ctx[3]);
			attr(input, "placeholder", /*placeholder*/ ctx[8]);
			input.required = /*isRequired*/ ctx[9];
			attr(input, "type", "phone");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding_4*/ ctx[22](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "change", function () {
						if (is_function(/*onChange*/ ctx[7])) /*onChange*/ ctx[7].apply(this, arguments);
					}),
					listen(input, "input", /*input_input_handler_4*/ ctx[23])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*key*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = `${/*key*/ ctx[3]}-message`)) {
				attr(input, "aria-describedby", input_aria_describedby_value);
			}

			if (dirty & /*isInvalid*/ 1024) {
				attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			}

			if (dirty & /*inputClasses*/ 4 && input_class_value !== (input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`)) {
				attr(input, "class", input_class_value);
			}

			if (dirty & /*forceValidityFailure*/ 2) {
				attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			}

			if (dirty & /*key*/ 8) {
				attr(input, "id", /*key*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 256) {
				attr(input, "placeholder", /*placeholder*/ ctx[8]);
			}

			if (dirty & /*isRequired*/ 512) {
				input.required = /*isRequired*/ ctx[9];
			}

			if (dirty & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding_4*/ ctx[22](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (113:0) {#if type === 'text'}
function create_if_block_1$d(ctx) {
	let input;
	let input_aria_describedby_value;
	let input_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "aria-describedby", input_aria_describedby_value = `${/*key*/ ctx[3]}-message`);
			attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			attr(input, "class", input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`);
			attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			attr(input, "id", /*key*/ ctx[3]);
			attr(input, "placeholder", /*placeholder*/ ctx[8]);
			input.required = /*isRequired*/ ctx[9];
			attr(input, "type", "text");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding_5*/ ctx[24](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "change", function () {
						if (is_function(/*onChange*/ ctx[7])) /*onChange*/ ctx[7].apply(this, arguments);
					}),
					listen(input, "input", /*input_input_handler_5*/ ctx[25])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*key*/ 8 && input_aria_describedby_value !== (input_aria_describedby_value = `${/*key*/ ctx[3]}-message`)) {
				attr(input, "aria-describedby", input_aria_describedby_value);
			}

			if (dirty & /*isInvalid*/ 1024) {
				attr(input, "aria-invalid", /*isInvalid*/ ctx[10]);
			}

			if (dirty & /*inputClasses*/ 4 && input_class_value !== (input_class_value = `${/*inputClasses*/ ctx[2]} tw_input-base dark:tw_input-base_dark tw_focusable-element dark:tw_focusable-element_dark tw_flex-1 tw_w-full`)) {
				attr(input, "class", input_class_value);
			}

			if (dirty & /*forceValidityFailure*/ 2) {
				attr(input, "data-force-validity-failure", /*forceValidityFailure*/ ctx[1]);
			}

			if (dirty & /*key*/ 8) {
				attr(input, "id", /*key*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 256) {
				attr(input, "placeholder", /*placeholder*/ ctx[8]);
			}

			if (dirty & /*isRequired*/ 512) {
				input.required = /*isRequired*/ ctx[9];
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding_5*/ ctx[24](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (129:0) {#if labelOrder === 'last'}
function create_if_block$n(ctx) {
	let label_1;
	let current;

	label_1 = new Label({
			props: {
				key: /*key*/ ctx[3],
				classes: `${/*labelClasses*/ ctx[5]}`,
				$$slots: { default: [create_default_slot$m] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(label_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(label_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_1_changes = {};
			if (dirty & /*key*/ 8) label_1_changes.key = /*key*/ ctx[3];
			if (dirty & /*labelClasses*/ 32) label_1_changes.classes = `${/*labelClasses*/ ctx[5]}`;

			if (dirty & /*$$scope, label*/ 67108880) {
				label_1_changes.$$scope = { dirty, ctx };
			}

			label_1.$set(label_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(label_1, detaching);
		}
	};
}

// (130:2) <Label {key} classes={`${labelClasses}`}>
function create_default_slot$m(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 16) set_data(t, /*label*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$K(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let if_block7_anchor;
	let current;
	let if_block0 = /*labelOrder*/ ctx[6] === 'first' && create_if_block_7$1(ctx);
	let if_block1 = /*type*/ ctx[11] === 'date' && create_if_block_6$1(ctx);
	let if_block2 = /*type*/ ctx[11] === 'email' && create_if_block_5$2(ctx);
	let if_block3 = /*type*/ ctx[11] === 'number' && create_if_block_4$6(ctx);
	let if_block4 = /*type*/ ctx[11] === 'password' && create_if_block_3$9(ctx);
	let if_block5 = /*type*/ ctx[11] === 'phone' && create_if_block_2$a(ctx);
	let if_block6 = /*type*/ ctx[11] === 'text' && create_if_block_1$d(ctx);
	let if_block7 = /*labelOrder*/ ctx[6] === 'last' && create_if_block$n(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			t6 = space();
			if (if_block7) if_block7.c();
			if_block7_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert(target, t4, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert(target, t5, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert(target, t6, anchor);
			if (if_block7) if_block7.m(target, anchor);
			insert(target, if_block7_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*labelOrder*/ ctx[6] === 'first') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*labelOrder*/ 64) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_7$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*type*/ ctx[11] === 'date') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_6$1(ctx);
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*type*/ ctx[11] === 'email') {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_5$2(ctx);
					if_block2.c();
					if_block2.m(t2.parentNode, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*type*/ ctx[11] === 'number') {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_4$6(ctx);
					if_block3.c();
					if_block3.m(t3.parentNode, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*type*/ ctx[11] === 'password') {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_3$9(ctx);
					if_block4.c();
					if_block4.m(t4.parentNode, t4);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*type*/ ctx[11] === 'phone') {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_2$a(ctx);
					if_block5.c();
					if_block5.m(t5.parentNode, t5);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (/*type*/ ctx[11] === 'text') {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_1$d(ctx);
					if_block6.c();
					if_block6.m(t6.parentNode, t6);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*labelOrder*/ ctx[6] === 'last') {
				if (if_block7) {
					if_block7.p(ctx, dirty);

					if (dirty & /*labelOrder*/ 64) {
						transition_in(if_block7, 1);
					}
				} else {
					if_block7 = create_if_block$n(ctx);
					if_block7.c();
					transition_in(if_block7, 1);
					if_block7.m(if_block7_anchor.parentNode, if_block7_anchor);
				}
			} else if (if_block7) {
				group_outros();

				transition_out(if_block7, 1, 1, () => {
					if_block7 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block7);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block7);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t2);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t3);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t4);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t5);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(t6);
			if (if_block7) if_block7.d(detaching);
			if (detaching) detach(if_block7_anchor);
		}
	};
}

function instance$L($$self, $$props, $$invalidate) {
	let { forceValidityFailure = false } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { inputClasses = '' } = $$props;
	let { key } = $$props;
	let { label } = $$props;
	let { labelClasses = '' } = $$props;
	let { labelOrder = 'first' } = $$props;
	let { onChange } = $$props;
	let { placeholder = ' ' } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = null } = $$props;
	let { type = 'text' } = $$props;
	let { value = '' } = $$props;
	let inputEl;

	afterUpdate(() => {
		if (isFirstInvalidInput) {
			inputEl.focus();
		}
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(12, inputEl);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(12, inputEl);
		});
	}

	function input_input_handler_1() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(12, inputEl);
		});
	}

	function input_input_handler_2() {
		value = to_number(this.value);
		$$invalidate(0, value);
	}

	function input_binding_3($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(12, inputEl);
		});
	}

	function input_input_handler_3() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding_4($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(12, inputEl);
		});
	}

	function input_input_handler_4() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding_5($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(12, inputEl);
		});
	}

	function input_input_handler_5() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('forceValidityFailure' in $$props) $$invalidate(1, forceValidityFailure = $$props.forceValidityFailure);
		if ('isFirstInvalidInput' in $$props) $$invalidate(13, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('inputClasses' in $$props) $$invalidate(2, inputClasses = $$props.inputClasses);
		if ('key' in $$props) $$invalidate(3, key = $$props.key);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('labelClasses' in $$props) $$invalidate(5, labelClasses = $$props.labelClasses);
		if ('labelOrder' in $$props) $$invalidate(6, labelOrder = $$props.labelOrder);
		if ('onChange' in $$props) $$invalidate(7, onChange = $$props.onChange);
		if ('placeholder' in $$props) $$invalidate(8, placeholder = $$props.placeholder);
		if ('isRequired' in $$props) $$invalidate(9, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(10, isInvalid = $$props.isInvalid);
		if ('type' in $$props) $$invalidate(11, type = $$props.type);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	return [
		value,
		forceValidityFailure,
		inputClasses,
		key,
		label,
		labelClasses,
		labelOrder,
		onChange,
		placeholder,
		isRequired,
		isInvalid,
		type,
		inputEl,
		isFirstInvalidInput,
		input_binding,
		input_input_handler,
		input_binding_1,
		input_input_handler_1,
		input_binding_2,
		input_input_handler_2,
		input_binding_3,
		input_input_handler_3,
		input_binding_4,
		input_input_handler_4,
		input_binding_5,
		input_input_handler_5
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$L, create_fragment$K, safe_not_equal, {
			forceValidityFailure: 1,
			isFirstInvalidInput: 13,
			inputClasses: 2,
			key: 3,
			label: 4,
			labelClasses: 5,
			labelOrder: 6,
			onChange: 7,
			placeholder: 8,
			isRequired: 9,
			isInvalid: 10,
			type: 11,
			value: 0
		});
	}
}

/* src/lib/components/compositions/input-floating/floating-label.svelte generated by Svelte v3.55.1 */
const get_input_button_slot_changes$1 = dirty => ({});
const get_input_button_slot_context$1 = ctx => ({});

function create_fragment$J(ctx) {
	let div1;
	let input;
	let updating_value;
	let t0;
	let t1;
	let div0;
	let message_1;
	let t2;
	let div0_id_value;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[16](value);
	}

	let input_props = {
		forceValidityFailure: /*forceValidityFailure*/ ctx[2],
		isFirstInvalidInput: /*isFirstInvalidInput*/ ctx[4],
		inputClasses: `tw_input-floating dark:tw_input-floating_dark ${/*hasRightIcon*/ ctx[5]
		? '!tw_border-r-0 !tw_rounded-r-none'
		: ''}`,
		key: /*key*/ ctx[7],
		onChange: /*onChangeWrapper*/ ctx[11],
		label: /*label*/ ctx[8],
		labelClasses: "tw_absolute tw_border tw_border-transparent tw_input-floating-label",
		labelOrder: "last",
		isRequired: /*isRequired*/ ctx[6],
		isInvalid: /*isInvalid*/ ctx[0],
		type: /*type*/ ctx[10]
	};

	if (/*value*/ ctx[1] !== void 0) {
		input_props.value = /*value*/ ctx[1];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));
	const input_button_slot_template = /*#slots*/ ctx[15]["input-button"];
	const input_button_slot = create_slot(input_button_slot_template, ctx, /*$$scope*/ ctx[14], get_input_button_slot_context$1);

	message_1 = new Input_message({
			props: {
				dirtyMessage: /*message*/ ctx[3],
				showMessage: /*showMessage*/ ctx[9],
				type: /*isInvalid*/ ctx[0] ? 'error' : 'info'
			}
		});

	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	return {
		c() {
			div1 = element("div");
			create_component(input.$$.fragment);
			t0 = space();
			if (input_button_slot) input_button_slot.c();
			t1 = space();
			div0 = element("div");
			create_component(message_1.$$.fragment);
			t2 = space();
			if (default_slot) default_slot.c();
			attr(div0, "class", "tw_w-full");
			attr(div0, "id", div0_id_value = `${/*key*/ ctx[7]}-message`);
			attr(div1, "class", `tw_justify-items-stretch tw_flex tw_input-spacing tw_relative tw_flex-wrap`);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			mount_component(input, div1, null);
			append(div1, t0);

			if (input_button_slot) {
				input_button_slot.m(div1, null);
			}

			append(div1, t1);
			append(div1, div0);
			mount_component(message_1, div0, null);
			append(div0, t2);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			const input_changes = {};
			if (dirty & /*forceValidityFailure*/ 4) input_changes.forceValidityFailure = /*forceValidityFailure*/ ctx[2];
			if (dirty & /*isFirstInvalidInput*/ 16) input_changes.isFirstInvalidInput = /*isFirstInvalidInput*/ ctx[4];

			if (dirty & /*hasRightIcon*/ 32) input_changes.inputClasses = `tw_input-floating dark:tw_input-floating_dark ${/*hasRightIcon*/ ctx[5]
			? '!tw_border-r-0 !tw_rounded-r-none'
			: ''}`;

			if (dirty & /*key*/ 128) input_changes.key = /*key*/ ctx[7];
			if (dirty & /*label*/ 256) input_changes.label = /*label*/ ctx[8];
			if (dirty & /*isRequired*/ 64) input_changes.isRequired = /*isRequired*/ ctx[6];
			if (dirty & /*isInvalid*/ 1) input_changes.isInvalid = /*isInvalid*/ ctx[0];
			if (dirty & /*type*/ 1024) input_changes.type = /*type*/ ctx[10];

			if (!updating_value && dirty & /*value*/ 2) {
				updating_value = true;
				input_changes.value = /*value*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);

			if (input_button_slot) {
				if (input_button_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot_base(
						input_button_slot,
						input_button_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(input_button_slot_template, /*$$scope*/ ctx[14], dirty, get_input_button_slot_changes$1),
						get_input_button_slot_context$1
					);
				}
			}

			const message_1_changes = {};
			if (dirty & /*message*/ 8) message_1_changes.dirtyMessage = /*message*/ ctx[3];
			if (dirty & /*showMessage*/ 512) message_1_changes.showMessage = /*showMessage*/ ctx[9];
			if (dirty & /*isInvalid*/ 1) message_1_changes.type = /*isInvalid*/ ctx[0] ? 'error' : 'info';
			message_1.$set(message_1_changes);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*key*/ 128 && div0_id_value !== (div0_id_value = `${/*key*/ ctx[7]}-message`)) {
				attr(div0, "id", div0_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(input_button_slot, local);
			transition_in(message_1.$$.fragment, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(input_button_slot, local);
			transition_out(message_1.$$.fragment, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(input);
			if (input_button_slot) input_button_slot.d(detaching);
			destroy_component(message_1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$K($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { checkValidity = null } = $$props;
	let { forceValidityFailure = false } = $$props;
	let { message = '' } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { hasRightIcon = false } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { label } = $$props;
	let { onChange } = $$props;
	let { showMessage = undefined } = $$props;
	let { type = 'text' } = $$props;
	let { value = '' } = $$props;

	function onChangeWrapper(event) {
		if (checkValidity) {
			$$invalidate(0, isInvalid = !checkValidity(event));
		}

		onChange(event);
	}

	function input_value_binding(value$1) {
		value = value$1;
		$$invalidate(1, value);
	}

	$$self.$$set = $$props => {
		if ('checkValidity' in $$props) $$invalidate(12, checkValidity = $$props.checkValidity);
		if ('forceValidityFailure' in $$props) $$invalidate(2, forceValidityFailure = $$props.forceValidityFailure);
		if ('message' in $$props) $$invalidate(3, message = $$props.message);
		if ('isFirstInvalidInput' in $$props) $$invalidate(4, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('hasRightIcon' in $$props) $$invalidate(5, hasRightIcon = $$props.hasRightIcon);
		if ('isRequired' in $$props) $$invalidate(6, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(0, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(7, key = $$props.key);
		if ('label' in $$props) $$invalidate(8, label = $$props.label);
		if ('onChange' in $$props) $$invalidate(13, onChange = $$props.onChange);
		if ('showMessage' in $$props) $$invalidate(9, showMessage = $$props.showMessage);
		if ('type' in $$props) $$invalidate(10, type = $$props.type);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
	};

	return [
		isInvalid,
		value,
		forceValidityFailure,
		message,
		isFirstInvalidInput,
		hasRightIcon,
		isRequired,
		key,
		label,
		showMessage,
		type,
		onChangeWrapper,
		checkValidity,
		onChange,
		$$scope,
		slots,
		input_value_binding
	];
}

class Floating_label extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$K, create_fragment$J, safe_not_equal, {
			checkValidity: 12,
			forceValidityFailure: 2,
			message: 3,
			isFirstInvalidInput: 4,
			hasRightIcon: 5,
			isRequired: 6,
			isInvalid: 0,
			key: 7,
			label: 8,
			onChange: 13,
			showMessage: 9,
			type: 10,
			value: 1
		});
	}
}

/* src/lib/components/compositions/input-stacked/stacked-label.svelte generated by Svelte v3.55.1 */
const get_input_button_slot_changes = dirty => ({});
const get_input_button_slot_context = ctx => ({});

function create_fragment$I(ctx) {
	let div1;
	let input;
	let updating_value;
	let t0;
	let t1;
	let div0;
	let message_1;
	let t2;
	let div0_id_value;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[17](value);
	}

	let input_props = {
		forceValidityFailure: /*forceValidityFailure*/ ctx[2],
		isFirstInvalidInput: /*isFirstInvalidInput*/ ctx[3],
		inputClasses: `${/*hasRightIcon*/ ctx[4]
		? '!tw_border-r-0 !tw_rounded-r-none'
		: ''}`,
		key: /*key*/ ctx[7],
		onChange: /*onChangeWrapper*/ ctx[12],
		label: /*label*/ ctx[8],
		labelClasses: "tw_input-stacked-label",
		labelOrder: "first",
		placeholder: /*placeholder*/ ctx[9],
		isRequired: /*isRequired*/ ctx[6],
		isInvalid: /*isInvalid*/ ctx[0],
		type: /*type*/ ctx[11]
	};

	if (/*value*/ ctx[1] !== void 0) {
		input_props.value = /*value*/ ctx[1];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));
	const input_button_slot_template = /*#slots*/ ctx[16]["input-button"];
	const input_button_slot = create_slot(input_button_slot_template, ctx, /*$$scope*/ ctx[15], get_input_button_slot_context);

	message_1 = new Input_message({
			props: {
				key: /*key*/ ctx[7],
				dirtyMessage: /*message*/ ctx[5],
				showMessage: /*showMessage*/ ctx[10],
				type: /*isInvalid*/ ctx[0] ? 'error' : 'info'
			}
		});

	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	return {
		c() {
			div1 = element("div");
			create_component(input.$$.fragment);
			t0 = space();
			if (input_button_slot) input_button_slot.c();
			t1 = space();
			div0 = element("div");
			create_component(message_1.$$.fragment);
			t2 = space();
			if (default_slot) default_slot.c();
			attr(div0, "class", "tw_w-full");
			attr(div0, "id", div0_id_value = `${/*key*/ ctx[7]}-message`);
			attr(div1, "class", "tw_input-spacing tw_flex tw_flex-wrap");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			mount_component(input, div1, null);
			append(div1, t0);

			if (input_button_slot) {
				input_button_slot.m(div1, null);
			}

			append(div1, t1);
			append(div1, div0);
			mount_component(message_1, div0, null);
			append(div0, t2);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			const input_changes = {};
			if (dirty & /*forceValidityFailure*/ 4) input_changes.forceValidityFailure = /*forceValidityFailure*/ ctx[2];
			if (dirty & /*isFirstInvalidInput*/ 8) input_changes.isFirstInvalidInput = /*isFirstInvalidInput*/ ctx[3];

			if (dirty & /*hasRightIcon*/ 16) input_changes.inputClasses = `${/*hasRightIcon*/ ctx[4]
			? '!tw_border-r-0 !tw_rounded-r-none'
			: ''}`;

			if (dirty & /*key*/ 128) input_changes.key = /*key*/ ctx[7];
			if (dirty & /*label*/ 256) input_changes.label = /*label*/ ctx[8];
			if (dirty & /*placeholder*/ 512) input_changes.placeholder = /*placeholder*/ ctx[9];
			if (dirty & /*isRequired*/ 64) input_changes.isRequired = /*isRequired*/ ctx[6];
			if (dirty & /*isInvalid*/ 1) input_changes.isInvalid = /*isInvalid*/ ctx[0];
			if (dirty & /*type*/ 2048) input_changes.type = /*type*/ ctx[11];

			if (!updating_value && dirty & /*value*/ 2) {
				updating_value = true;
				input_changes.value = /*value*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);

			if (input_button_slot) {
				if (input_button_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot_base(
						input_button_slot,
						input_button_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: get_slot_changes(input_button_slot_template, /*$$scope*/ ctx[15], dirty, get_input_button_slot_changes),
						get_input_button_slot_context
					);
				}
			}

			const message_1_changes = {};
			if (dirty & /*key*/ 128) message_1_changes.key = /*key*/ ctx[7];
			if (dirty & /*message*/ 32) message_1_changes.dirtyMessage = /*message*/ ctx[5];
			if (dirty & /*showMessage*/ 1024) message_1_changes.showMessage = /*showMessage*/ ctx[10];
			if (dirty & /*isInvalid*/ 1) message_1_changes.type = /*isInvalid*/ ctx[0] ? 'error' : 'info';
			message_1.$set(message_1_changes);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*key*/ 128 && div0_id_value !== (div0_id_value = `${/*key*/ ctx[7]}-message`)) {
				attr(div0, "id", div0_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(input_button_slot, local);
			transition_in(message_1.$$.fragment, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(input_button_slot, local);
			transition_out(message_1.$$.fragment, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(input);
			if (input_button_slot) input_button_slot.d(detaching);
			destroy_component(message_1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$J($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { checkValidity = null } = $$props;
	let { forceValidityFailure = false } = $$props;
	let { isFirstInvalidInput } = $$props;
	let { hasRightIcon = false } = $$props;
	let { message = '' } = $$props;
	let { isRequired = false } = $$props;
	let { isInvalid = false } = $$props;
	let { key } = $$props;
	let { label } = $$props;
	let { onChange } = $$props;
	let { placeholder = undefined } = $$props;
	let { showMessage = undefined } = $$props;
	let { type = 'text' } = $$props;
	let { value = '' } = $$props;

	function onChangeWrapper(event) {
		if (checkValidity) {
			$$invalidate(0, isInvalid = !checkValidity(event));
		}

		onChange(event);
	}

	function input_value_binding(value$1) {
		value = value$1;
		$$invalidate(1, value);
	}

	$$self.$$set = $$props => {
		if ('checkValidity' in $$props) $$invalidate(13, checkValidity = $$props.checkValidity);
		if ('forceValidityFailure' in $$props) $$invalidate(2, forceValidityFailure = $$props.forceValidityFailure);
		if ('isFirstInvalidInput' in $$props) $$invalidate(3, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('hasRightIcon' in $$props) $$invalidate(4, hasRightIcon = $$props.hasRightIcon);
		if ('message' in $$props) $$invalidate(5, message = $$props.message);
		if ('isRequired' in $$props) $$invalidate(6, isRequired = $$props.isRequired);
		if ('isInvalid' in $$props) $$invalidate(0, isInvalid = $$props.isInvalid);
		if ('key' in $$props) $$invalidate(7, key = $$props.key);
		if ('label' in $$props) $$invalidate(8, label = $$props.label);
		if ('onChange' in $$props) $$invalidate(14, onChange = $$props.onChange);
		if ('placeholder' in $$props) $$invalidate(9, placeholder = $$props.placeholder);
		if ('showMessage' in $$props) $$invalidate(10, showMessage = $$props.showMessage);
		if ('type' in $$props) $$invalidate(11, type = $$props.type);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	return [
		isInvalid,
		value,
		forceValidityFailure,
		isFirstInvalidInput,
		hasRightIcon,
		message,
		isRequired,
		key,
		label,
		placeholder,
		showMessage,
		type,
		onChangeWrapper,
		checkValidity,
		onChange,
		$$scope,
		slots,
		input_value_binding
	];
}

class Stacked_label extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$J, create_fragment$I, safe_not_equal, {
			checkValidity: 13,
			forceValidityFailure: 2,
			isFirstInvalidInput: 3,
			hasRightIcon: 4,
			message: 5,
			isRequired: 6,
			isInvalid: 0,
			key: 7,
			label: 8,
			onChange: 14,
			placeholder: 9,
			showMessage: 10,
			type: 11,
			value: 1
		});
	}
}

/* src/lib/components/icons/lock-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$H(ctx) {
	let svg;
	let path0;
	let path1;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$I($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class Lock_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$I, create_fragment$H, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/callbacks/kba/kba-create.svelte generated by Svelte v3.55.1 */

function create_if_block$m(ctx) {
	let input;
	let current;

	input = new /*Input*/ ctx[7]({
			props: {
				isFirstInvalidInput: false,
				isRequired: true,
				key: `kba-custom-question-${/*callbackMetadata*/ ctx[0]?.idx}`,
				label: interpolate('customSecurityQuestion'),
				showMessage: false,
				message: interpolate('inputRequiredError'),
				onChange: /*setQuestion*/ ctx[12],
				type: "text"
			}
		});

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty & /*callbackMetadata*/ 1) input_changes.key = `kba-custom-question-${/*callbackMetadata*/ ctx[0]?.idx}`;
			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

function create_fragment$G(ctx) {
	let fieldset;
	let legend;
	let t0;
	let t1;
	let h2;
	let t2;
	let t3;
	let span;
	let lockicon;
	let t4;
	let select;
	let t5;
	let t6;
	let input;
	let updating_value;
	let current;
	t0 = new Locale_strings({ props: { key: "securityQuestions" } });

	t2 = new Locale_strings({
			props: { key: "securityQuestionsPrompt" }
		});

	lockicon = new Lock_icon({ props: { size: "18" } });

	select = new /*Select*/ ctx[8]({
			props: {
				isFirstInvalidInput: false,
				isRequired: true,
				key: /*inputNameQuestion*/ ctx[4],
				label: /*prompt*/ ctx[1],
				onChange: /*selectQuestion*/ ctx[11],
				options: /*questions*/ ctx[2]
			}
		});

	let if_block = /*displayCustomQuestionInput*/ ctx[3] && create_if_block$m(ctx);

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[21](value);
	}

	let input_props = {
		isFirstInvalidInput: /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false,
		isRequired: true,
		key: /*inputNameAnswer*/ ctx[5] || `kba-answer-${/*callbackMetadata*/ ctx[0]?.idx}`,
		label: interpolate('securityAnswer'),
		showMessage: false,
		message: interpolate('inputRequiredError'),
		onChange: /*setAnswer*/ ctx[10],
		type: "text"
	};

	if (/*$value*/ ctx[6] !== void 0) {
		input_props.value = /*$value*/ ctx[6];
	}

	input = new /*Input*/ ctx[7]({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

	return {
		c() {
			fieldset = element("fieldset");
			legend = element("legend");
			create_component(t0.$$.fragment);
			t1 = space();
			h2 = element("h2");
			create_component(t2.$$.fragment);
			t3 = space();
			span = element("span");
			create_component(lockicon.$$.fragment);
			t4 = space();
			create_component(select.$$.fragment);
			t5 = space();
			if (if_block) if_block.c();
			t6 = space();
			create_component(input.$$.fragment);
			attr(legend, "class", "tw_sr-only");
			attr(h2, "class", "dark:tw_secondary-header_dark tw_font-semibold tw_mb-4");
			attr(span, "class", "tw_kba-lock-icon dark:tw_kba-lock-icon_dark");
			attr(fieldset, "class", "tw_kba-fieldset tw_input-spacing dark:tw_kba-fieldset_dark");
		},
		m(target, anchor) {
			insert(target, fieldset, anchor);
			append(fieldset, legend);
			mount_component(t0, legend, null);
			append(fieldset, t1);
			append(fieldset, h2);
			mount_component(t2, h2, null);
			append(fieldset, t3);
			append(fieldset, span);
			mount_component(lockicon, span, null);
			append(fieldset, t4);
			mount_component(select, fieldset, null);
			append(fieldset, t5);
			if (if_block) if_block.m(fieldset, null);
			append(fieldset, t6);
			mount_component(input, fieldset, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const select_changes = {};
			if (dirty & /*inputNameQuestion*/ 16) select_changes.key = /*inputNameQuestion*/ ctx[4];
			if (dirty & /*prompt*/ 2) select_changes.label = /*prompt*/ ctx[1];
			if (dirty & /*questions*/ 4) select_changes.options = /*questions*/ ctx[2];
			select.$set(select_changes);

			if (/*displayCustomQuestionInput*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*displayCustomQuestionInput*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$m(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(fieldset, t6);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const input_changes = {};
			if (dirty & /*callbackMetadata*/ 1) input_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false;
			if (dirty & /*inputNameAnswer, callbackMetadata*/ 33) input_changes.key = /*inputNameAnswer*/ ctx[5] || `kba-answer-${/*callbackMetadata*/ ctx[0]?.idx}`;

			if (!updating_value && dirty & /*$value*/ 64) {
				updating_value = true;
				input_changes.value = /*$value*/ ctx[6];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(t0.$$.fragment, local);
			transition_in(t2.$$.fragment, local);
			transition_in(lockicon.$$.fragment, local);
			transition_in(select.$$.fragment, local);
			transition_in(if_block);
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t0.$$.fragment, local);
			transition_out(t2.$$.fragment, local);
			transition_out(lockicon.$$.fragment, local);
			transition_out(select.$$.fragment, local);
			transition_out(if_block);
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(fieldset);
			destroy_component(t0);
			destroy_component(t2);
			destroy_component(lockicon);
			destroy_component(select);
			if (if_block) if_block.d();
			destroy_component(input);
		}
	};
}

function instance$H($$self, $$props, $$invalidate) {
	let $value;
	const selfSubmitFunction = null;
	const stepMetadata = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { style = {} } = $$props;

	const Input = style.labels === 'stacked'
	? Stacked_label
	: Floating_label;

	const Select = style.labels === 'stacked'
	? Stacked_label$1
	: Floating_label$1;

	let customQuestionIndex = null;
	let displayCustomQuestionInput = false;
	let inputArr;
	let inputName;
	let inputNameQuestion;
	let inputNameAnswer;
	let prompt;
	let questions;
	let shouldAllowCustomQuestion;
	let value = writable('');
	component_subscribe($$self, value, value => $$invalidate(6, $value = value));

	/**
 * `getOutputValue` throws if it doesn't find this property. There _may_ be a context
 * in which the property doesn't exist, so I'm going to wrap it in a try-catch, just
 * in case
 */
	try {
		shouldAllowCustomQuestion = callback.getOutputValue('allowUserDefinedQuestions');
	} catch(err) {
		console.error('`allowUserDefinedQuestions` property is missing in callback `KbaCreateCallback`');
	}

	/**
 * @function setAnswer - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setAnswer(event) {
		callback.setAnswer(event.target.value);
	}

	/**
 * @function setQuestion - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function selectQuestion(event) {
		const selectValue = event.target.value;

		if (selectValue === customQuestionIndex) {
			$$invalidate(3, displayCustomQuestionInput = true);
			value.set('');
			callback.setAnswer('');
		} else {
			$$invalidate(3, displayCustomQuestionInput = false);
			callback.setQuestion(selectValue);
		}
	}

	/**
 * @function setQuestion - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setQuestion(event) {
		const inputValue = event.target.value;
		callback.setQuestion(inputValue);
	}

	function input_value_binding(value$1) {
		$value = value$1;
		value.set($value);
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(15, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(0, callbackMetadata = $$props.callbackMetadata);
		if ('style' in $$props) $$invalidate(16, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata, inputName, inputArr, questions, prompt, shouldAllowCustomQuestion, customQuestionIndex*/ 1998855) {
			{
				$$invalidate(18, inputArr = callback?.payload?.input);
				$$invalidate(19, inputName = callback?.payload?.input?.[0].name || `kba-${callbackMetadata?.idx}`);
				$$invalidate(4, inputNameQuestion = inputName);
				$$invalidate(5, inputNameAnswer = Array.isArray(inputArr) && inputArr[1].name);
				$$invalidate(1, prompt = callback.getPrompt());
				$$invalidate(2, questions = callback.getPredefinedQuestions()?.map((label, idx) => ({ text: label, value: `${idx}` })));

				/**
 * `getOutputValue` throws if it doesn't find this property. There _may_ be a context
 * in which the property doesn't exist, so I'm going to wrap it in a try-catch, just
 * in case
 */
				try {
					$$invalidate(20, shouldAllowCustomQuestion = callback.getOutputValue('allowUserDefinedQuestions'));
				} catch(err) {
					console.error('`allowUserDefinedQuestions` property is missing in callback `KbaCreateCallback`');
				}

				questions.unshift({ text: prompt, value: '' });

				/**
 * Uncomment the below `setQuestion` if you remove the `unshift` above.
 * The `unshift` defaults the UI to a non-question, but if you remove it,
 * you will default to a question, which needs to be set in the callback.
 *
 * callback.setQuestion(questions[0].text);
 */
				if (shouldAllowCustomQuestion) {
					$$invalidate(17, customQuestionIndex = `${questions.length - 1}`);

					questions.push({
						text: interpolate('provideCustomQuestion'),
						value: customQuestionIndex
					});
				}
			}
		}
	};

	return [
		callbackMetadata,
		prompt,
		questions,
		displayCustomQuestionInput,
		inputNameQuestion,
		inputNameAnswer,
		$value,
		Input,
		Select,
		value,
		setAnswer,
		selectQuestion,
		setQuestion,
		selfSubmitFunction,
		stepMetadata,
		callback,
		style,
		customQuestionIndex,
		inputArr,
		inputName,
		shouldAllowCustomQuestion,
		input_value_binding
	];
}

class Kba_create extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$H, create_fragment$G, safe_not_equal, {
			selfSubmitFunction: 13,
			stepMetadata: 14,
			callback: 15,
			callbackMetadata: 0,
			style: 16
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[13];
	}

	get stepMetadata() {
		return this.$$.ctx[14];
	}
}

/* src/lib/journey/callbacks/username/name.svelte generated by Svelte v3.55.1 */

function create_key_block$4(ctx) {
	let input;
	let current;

	input = new /*Input*/ ctx[6]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[1]?.derived.isFirstInvalidInput || false,
				key: /*inputName*/ ctx[3],
				label: interpolate(textToKey(/*textInputLabel*/ ctx[4] || /*callbackType*/ ctx[2]), null, /*textInputLabel*/ ctx[4]),
				onChange: /*setValue*/ ctx[7],
				type: "text",
				showMessage: false,
				value: typeof /*value*/ ctx[5] === 'string'
				? /*value*/ ctx[5]
				: ''
			}
		});

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty & /*callbackMetadata*/ 2) input_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[1]?.derived.isFirstInvalidInput || false;
			if (dirty & /*inputName*/ 8) input_changes.key = /*inputName*/ ctx[3];
			if (dirty & /*textInputLabel, callbackType*/ 20) input_changes.label = interpolate(textToKey(/*textInputLabel*/ ctx[4] || /*callbackType*/ ctx[2]), null, /*textInputLabel*/ ctx[4]);

			if (dirty & /*value*/ 32) input_changes.value = typeof /*value*/ ctx[5] === 'string'
			? /*value*/ ctx[5]
			: '';

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

function create_fragment$F(ctx) {
	let previous_key = /*callback*/ ctx[0];
	let key_block_anchor;
	let current;
	let key_block = create_key_block$4(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*callback*/ 1 && safe_not_equal(previous_key, previous_key = /*callback*/ ctx[0])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block$4(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(key_block_anchor);
			key_block.d(detaching);
		}
	};
}

function instance$G($$self, $$props, $$invalidate) {
	const selfSubmitFunction = null;
	const stepMetadata = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { style = {} } = $$props;
	const Input = style.labels === 'stacked' ? Stacked_label : Floating_label;
	let callbackType;
	let inputName;
	let textInputLabel;
	let value;

	function setValue(event) {
		callback.setInputValue(event.target.value);
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(0, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(1, callbackMetadata = $$props.callbackMetadata);
		if ('style' in $$props) $$invalidate(10, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata*/ 3) {
			{
				$$invalidate(2, callbackType = callback.getType());
				$$invalidate(3, inputName = callback?.payload?.input?.[0].name || `name-${callbackMetadata?.idx}`);
				$$invalidate(4, textInputLabel = callback.getPrompt());
				$$invalidate(5, value = callback?.getInputValue());
			}
		}
	};

	return [
		callback,
		callbackMetadata,
		callbackType,
		inputName,
		textInputLabel,
		value,
		Input,
		setValue,
		selfSubmitFunction,
		stepMetadata,
		style
	];
}

class Name extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$G, create_fragment$F, safe_not_equal, {
			selfSubmitFunction: 8,
			stepMetadata: 9,
			callback: 0,
			callbackMetadata: 1,
			style: 10
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[8];
	}

	get stepMetadata() {
		return this.$$.ctx[9];
	}
}

/* src/lib/components/icons/eye-icon.svelte generated by Svelte v3.55.1 */

function create_else_block$7(ctx) {
	let svg;
	let path0;
	let path1;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path0, "d", "M0 0h24v24H0zm0 0h24v24H0zm0 0h24v24H0zm0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (6:0) {#if !visible}
function create_if_block$l(ctx) {
	let svg;
	let path0;
	let path1;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$E(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$l, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*visible*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$F($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;
	let { visible = false } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('visible' in $$props) $$invalidate(2, visible = $$props.visible);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [classes, size, visible, $$scope, slots];
}

class Eye_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$F, create_fragment$E, safe_not_equal, { classes: 0, size: 1, visible: 2 });
	}
}

/* src/lib/journey/callbacks/password/confirm-input.svelte generated by Svelte v3.55.1 */

function create_default_slot_2$8(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (66:6) {#if showPassword === "button"}
function create_if_block_1$c(ctx) {
	let button;
	let eyeicon;
	let current;
	let mounted;
	let dispose;

	eyeicon = new Eye_icon({
			props: {
				classes: "tw_password-icon dark:tw_password-icon_dark",
				visible: /*isVisible*/ ctx[8],
				$$slots: { default: [create_default_slot_1$e] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			button = element("button");
			create_component(eyeicon.$$.fragment);
			attr(button, "class", `tw_password-button dark:tw_password-button_dark tw_focusable-element tw_input-base dark:tw_input-base_dark`);
			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			mount_component(eyeicon, button, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*toggleVisibility*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const eyeicon_changes = {};
			if (dirty & /*isVisible*/ 256) eyeicon_changes.visible = /*isVisible*/ ctx[8];

			if (dirty & /*$$scope*/ 262144) {
				eyeicon_changes.$$scope = { dirty, ctx };
			}

			eyeicon.$set(eyeicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(eyeicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(eyeicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			destroy_component(eyeicon);
			mounted = false;
			dispose();
		}
	};
}

// (72:10) <EyeIcon classes="tw_password-icon dark:tw_password-icon_dark" visible={isVisible}>
function create_default_slot_1$e(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "showPassword" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (65:1) <svelte:fragment slot="input-button">
function create_input_button_slot$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*showPassword*/ ctx[12] === "button" && create_if_block_1$c(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*showPassword*/ ctx[12] === "button") if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (80:0) {#if showPassword === "checkbox"}
function create_if_block$k(ctx) {
	let div;
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				isFirstInvalidInput: /*isFirstInvalidInput*/ ctx[5],
				isInvalid: false,
				key: /*key*/ ctx[3] + /*style*/ ctx[4].showPassword,
				onChange: /*toggleVisibility*/ ctx[14],
				value: false,
				$$slots: { default: [create_default_slot$l] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(checkbox.$$.fragment);
			attr(div, "class", "tw_w-full tw_input-spacing");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(checkbox, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*isFirstInvalidInput*/ 32) checkbox_changes.isFirstInvalidInput = /*isFirstInvalidInput*/ ctx[5];
			if (dirty & /*key, style*/ 24) checkbox_changes.key = /*key*/ ctx[3] + /*style*/ ctx[4].showPassword;

			if (dirty & /*$$scope*/ 262144) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(checkbox);
		}
	};
}

// (82:6) <Checkbox          {isFirstInvalidInput}         isInvalid={false}         key = {key + style.showPassword}         onChange={toggleVisibility}         value={false}       >
function create_default_slot$l(ctx) {
	let t;

	return {
		c() {
			t = text("Show Password");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$D(ctx) {
	let input;
	let t;
	let if_block_anchor;
	let current;

	input = new /*Input*/ ctx[11]({
			props: {
				forceValidityFailure: /*forceValidityFailure*/ ctx[0],
				isFirstInvalidInput: false,
				hasRightIcon: /*style*/ ctx[4].showPassword === 'button'
				? true
				: false,
				key: `${/*key*/ ctx[3]}-confirm`,
				label: interpolate('confirmPassword', null, 'Confirm Password'),
				message: /*message*/ ctx[10],
				onChange: /*onChangeWrapper*/ ctx[13],
				isInvalid: /*passwordsDoNotMatch*/ ctx[1],
				isRequired: /*isRequired*/ ctx[2],
				showMessage: /*showMessage*/ ctx[6],
				type: /*type*/ ctx[9],
				value: typeof /*value*/ ctx[7] === 'string'
				? /*value*/ ctx[7]
				: '',
				$$slots: {
					"input-button": [create_input_button_slot$1],
					default: [create_default_slot_2$8]
				},
				$$scope: { ctx }
			}
		});

	let if_block = /*showPassword*/ ctx[12] === "checkbox" && create_if_block$k(ctx);

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const input_changes = {};
			if (dirty & /*forceValidityFailure*/ 1) input_changes.forceValidityFailure = /*forceValidityFailure*/ ctx[0];

			if (dirty & /*style*/ 16) input_changes.hasRightIcon = /*style*/ ctx[4].showPassword === 'button'
			? true
			: false;

			if (dirty & /*key*/ 8) input_changes.key = `${/*key*/ ctx[3]}-confirm`;
			if (dirty & /*message*/ 1024) input_changes.message = /*message*/ ctx[10];
			if (dirty & /*passwordsDoNotMatch*/ 2) input_changes.isInvalid = /*passwordsDoNotMatch*/ ctx[1];
			if (dirty & /*isRequired*/ 4) input_changes.isRequired = /*isRequired*/ ctx[2];
			if (dirty & /*showMessage*/ 64) input_changes.showMessage = /*showMessage*/ ctx[6];
			if (dirty & /*type*/ 512) input_changes.type = /*type*/ ctx[9];

			if (dirty & /*value*/ 128) input_changes.value = typeof /*value*/ ctx[7] === 'string'
			? /*value*/ ctx[7]
			: '';

			if (dirty & /*$$scope, isVisible*/ 262400) {
				input_changes.$$scope = { dirty, ctx };
			}

			input.$set(input_changes);
			if (/*showPassword*/ ctx[12] === "checkbox") if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$E($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { forceValidityFailure = false } = $$props;
	let { passwordsDoNotMatch = false } = $$props;
	let { isRequired = false } = $$props;
	let { key } = $$props;
	let { onChange } = $$props;
	let { resetValue } = $$props;
	let { style = {} } = $$props;
	let { isFirstInvalidInput } = $$props;
	const Input = style.labels === 'stacked' ? Stacked_label : Floating_label;
	const showPassword = style.showPassword;
	let { showMessage = undefined } = $$props;
	let isVisible = false;
	let type = 'password';
	let value;
	let message = '';

	function onChangeWrapper(event) {
		$$invalidate(7, value = event.target?.value);

		// TODO: revisit this logic to avoid unnecessary ternary
		onChange(typeof value === 'string' ? value : undefined);
	}

	/**
 * @function toggleVisibility - toggles the password from masked to plaintext
 */
	function toggleVisibility() {
		$$invalidate(8, isVisible = !isVisible);
		$$invalidate(9, type = isVisible ? 'text' : 'password');
	}

	$$self.$$set = $$props => {
		if ('forceValidityFailure' in $$props) $$invalidate(0, forceValidityFailure = $$props.forceValidityFailure);
		if ('passwordsDoNotMatch' in $$props) $$invalidate(1, passwordsDoNotMatch = $$props.passwordsDoNotMatch);
		if ('isRequired' in $$props) $$invalidate(2, isRequired = $$props.isRequired);
		if ('key' in $$props) $$invalidate(3, key = $$props.key);
		if ('onChange' in $$props) $$invalidate(15, onChange = $$props.onChange);
		if ('resetValue' in $$props) $$invalidate(16, resetValue = $$props.resetValue);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('isFirstInvalidInput' in $$props) $$invalidate(5, isFirstInvalidInput = $$props.isFirstInvalidInput);
		if ('showMessage' in $$props) $$invalidate(6, showMessage = $$props.showMessage);
		if ('$$scope' in $$props) $$invalidate(18, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*resetValue, onChange, value, passwordsDoNotMatch, isRequired*/ 98438) {
			{
				if (resetValue) {
					$$invalidate(7, value = undefined);
					onChange(value);
				}

				if (passwordsDoNotMatch) {
					$$invalidate(10, message = interpolate('passwordConfirmationError', null, 'Passwords do not match'));
				} else if (isRequired) {
					$$invalidate(10, message = interpolate('requiredField', null, 'This field is required'));
				} else {
					$$invalidate(10, message = '');
				}
			}
		}
	};

	return [
		forceValidityFailure,
		passwordsDoNotMatch,
		isRequired,
		key,
		style,
		isFirstInvalidInput,
		showMessage,
		value,
		isVisible,
		type,
		message,
		Input,
		showPassword,
		onChangeWrapper,
		toggleVisibility,
		onChange,
		resetValue,
		slots,
		$$scope
	];
}

class Confirm_input extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$E, create_fragment$D, safe_not_equal, {
			forceValidityFailure: 0,
			passwordsDoNotMatch: 1,
			isRequired: 2,
			key: 3,
			onChange: 15,
			resetValue: 16,
			style: 4,
			isFirstInvalidInput: 5,
			showMessage: 6
		});
	}
}

/* src/lib/journey/callbacks/password/base.svelte generated by Svelte v3.55.1 */

function create_default_slot_2$7(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[23],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (92:6) {#if showPassword === 'button'}
function create_if_block_2$9(ctx) {
	let button;
	let eyeicon;
	let current;
	let mounted;
	let dispose;

	eyeicon = new Eye_icon({
			props: {
				classes: "tw_password-icon dark:tw_password-icon_dark",
				visible: /*isVisible*/ ctx[11],
				$$slots: { default: [create_default_slot_1$d] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			button = element("button");
			create_component(eyeicon.$$.fragment);
			attr(button, "class", `tw_password-button dark:tw_password-button_dark tw_focusable-element tw_input-base dark:tw_input-base_dark`);
			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			mount_component(eyeicon, button, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*toggleVisibility*/ ctx[19]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const eyeicon_changes = {};
			if (dirty & /*isVisible*/ 2048) eyeicon_changes.visible = /*isVisible*/ ctx[11];

			if (dirty & /*$$scope*/ 8388608) {
				eyeicon_changes.$$scope = { dirty, ctx };
			}

			eyeicon.$set(eyeicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(eyeicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(eyeicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			destroy_component(eyeicon);
			mounted = false;
			dispose();
		}
	};
}

// (98:10) <EyeIcon classes="tw_password-icon dark:tw_password-icon_dark" visible={isVisible}>
function create_default_slot_1$d(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "showPassword" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (91:4) <svelte:fragment slot="input-button">
function create_input_button_slot(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*showPassword*/ ctx[16] === 'button' && create_if_block_2$9(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*showPassword*/ ctx[16] === 'button') if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (107:2) {#if showPassword === 'checkbox'}
function create_if_block_1$b(ctx) {
	let div;
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[2]?.derived.isFirstInvalidInput || false,
				isInvalid: false,
				key: /*key*/ ctx[0] + /*style*/ ctx[5].showPassword,
				onChange: /*toggleVisibility*/ ctx[19],
				value: false,
				$$slots: { default: [create_default_slot$k] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(checkbox.$$.fragment);
			attr(div, "class", "tw_w-full tw_input-spacing");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(checkbox, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty & /*callbackMetadata*/ 4) checkbox_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[2]?.derived.isFirstInvalidInput || false;
			if (dirty & /*key, style*/ 33) checkbox_changes.key = /*key*/ ctx[0] + /*style*/ ctx[5].showPassword;

			if (dirty & /*$$scope*/ 8388608) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(checkbox);
		}
	};
}

// (109:6) <Checkbox         isFirstInvalidInput={callbackMetadata?.derived.isFirstInvalidInput || false}         isInvalid={false}         key={key + style.showPassword}         onChange={toggleVisibility}         value={false}       >
function create_default_slot$k(ctx) {
	let t;

	return {
		c() {
			t = text("Show Password");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (120:2) {#if callbackMetadata?.platform?.confirmPassword}
function create_if_block$j(ctx) {
	let confirminput;
	let current;

	confirminput = new Confirm_input({
			props: {
				forceValidityFailure: /*doPasswordsMatch*/ ctx[10] === false,
				passwordsDoNotMatch: /*doPasswordsMatch*/ ctx[10] === false,
				key: /*key*/ ctx[0],
				isRequired: /*value*/ ctx[8].length > 0,
				onChange: /*confirmInput*/ ctx[17],
				resetValue: /*resetValue*/ ctx[12],
				showMessage: /*doPasswordsMatch*/ ctx[10] === false,
				style: /*style*/ ctx[5],
				isFirstInvalidInput: /*callbackMetadata*/ ctx[2]?.derived.isFirstInvalidInput || false
			}
		});

	return {
		c() {
			create_component(confirminput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(confirminput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const confirminput_changes = {};
			if (dirty & /*doPasswordsMatch*/ 1024) confirminput_changes.forceValidityFailure = /*doPasswordsMatch*/ ctx[10] === false;
			if (dirty & /*doPasswordsMatch*/ 1024) confirminput_changes.passwordsDoNotMatch = /*doPasswordsMatch*/ ctx[10] === false;
			if (dirty & /*key*/ 1) confirminput_changes.key = /*key*/ ctx[0];
			if (dirty & /*value*/ 256) confirminput_changes.isRequired = /*value*/ ctx[8].length > 0;
			if (dirty & /*resetValue*/ 4096) confirminput_changes.resetValue = /*resetValue*/ ctx[12];
			if (dirty & /*doPasswordsMatch*/ 1024) confirminput_changes.showMessage = /*doPasswordsMatch*/ ctx[10] === false;
			if (dirty & /*style*/ 32) confirminput_changes.style = /*style*/ ctx[5];
			if (dirty & /*callbackMetadata*/ 4) confirminput_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[2]?.derived.isFirstInvalidInput || false;
			confirminput.$set(confirminput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(confirminput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(confirminput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(confirminput, detaching);
		}
	};
}

// (77:0) {#key callback}
function create_key_block$3(ctx) {
	let input;
	let t0;
	let t1;
	let if_block1_anchor;
	let current;

	input = new /*Input*/ ctx[15]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[2]?.derived.isFirstInvalidInput || false,
				hasRightIcon: /*style*/ ctx[5].showPassword === 'button'
				? true
				: false,
				key: /*key*/ ctx[0],
				label: interpolate(textToKey(/*callbackType*/ ctx[9]), null, /*textInputLabel*/ ctx[13]),
				message: /*validationFailure*/ ctx[7] || (/*isRequired*/ ctx[4]
				? interpolate('inputRequiredError')
				: undefined),
				onChange: /*setValue*/ ctx[18],
				isInvalid: /*isInvalid*/ ctx[3],
				isRequired: /*isRequired*/ ctx[4],
				showMessage: /*showMessage*/ ctx[6],
				type: /*type*/ ctx[14],
				value: typeof /*value*/ ctx[8] === 'string'
				? /*value*/ ctx[8]
				: '',
				$$slots: {
					"input-button": [create_input_button_slot],
					default: [create_default_slot_2$7]
				},
				$$scope: { ctx }
			}
		});

	let if_block0 = /*showPassword*/ ctx[16] === 'checkbox' && create_if_block_1$b(ctx);
	let if_block1 = /*callbackMetadata*/ ctx[2]?.platform?.confirmPassword && create_if_block$j(ctx);

	return {
		c() {
			create_component(input.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty & /*callbackMetadata*/ 4) input_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[2]?.derived.isFirstInvalidInput || false;

			if (dirty & /*style*/ 32) input_changes.hasRightIcon = /*style*/ ctx[5].showPassword === 'button'
			? true
			: false;

			if (dirty & /*key*/ 1) input_changes.key = /*key*/ ctx[0];
			if (dirty & /*callbackType, textInputLabel*/ 8704) input_changes.label = interpolate(textToKey(/*callbackType*/ ctx[9]), null, /*textInputLabel*/ ctx[13]);

			if (dirty & /*validationFailure, isRequired*/ 144) input_changes.message = /*validationFailure*/ ctx[7] || (/*isRequired*/ ctx[4]
			? interpolate('inputRequiredError')
			: undefined);

			if (dirty & /*isInvalid*/ 8) input_changes.isInvalid = /*isInvalid*/ ctx[3];
			if (dirty & /*isRequired*/ 16) input_changes.isRequired = /*isRequired*/ ctx[4];
			if (dirty & /*showMessage*/ 64) input_changes.showMessage = /*showMessage*/ ctx[6];
			if (dirty & /*type*/ 16384) input_changes.type = /*type*/ ctx[14];

			if (dirty & /*value*/ 256) input_changes.value = typeof /*value*/ ctx[8] === 'string'
			? /*value*/ ctx[8]
			: '';

			if (dirty & /*$$scope, isVisible*/ 8390656) {
				input_changes.$$scope = { dirty, ctx };
			}

			input.$set(input_changes);
			if (/*showPassword*/ ctx[16] === 'checkbox') if_block0.p(ctx, dirty);

			if (/*callbackMetadata*/ ctx[2]?.platform?.confirmPassword) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*callbackMetadata*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$j(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function create_fragment$C(ctx) {
	let previous_key = /*callback*/ ctx[1];
	let key_block_anchor;
	let current;
	let key_block = create_key_block$3(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*callback*/ 2 && safe_not_equal(previous_key, previous_key = /*callback*/ ctx[1])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block$3(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(key_block_anchor);
			key_block.d(detaching);
		}
	};
}

function instance$D($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { key } = $$props;
	let { isInvalid = false } = $$props;
	let { isRequired = false } = $$props;
	let { style = {} } = $$props;
	const Input = style.labels === 'stacked' ? Stacked_label : Floating_label;
	const showPassword = style.showPassword;
	let { showMessage = undefined } = $$props;
	let { validationFailure = '' } = $$props;
	let confirmValue;
	let callbackType;
	let doPasswordsMatch;
	let isVisible = false;
	let resetValue = false;
	let savedValue = '';
	let textInputLabel;
	let type = 'password';
	let value;

	/**
 * @function confirmInput - ensures the second password input matches the first
 * @param event
 */
	function confirmInput(val) {
		$$invalidate(20, confirmValue = val);
	}

	/**
 * @function setValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setValue(event) {
		$$invalidate(8, value = event.target.value);

		/** ***********************************************************************
 * SDK INTEGRATION POINT
 * Summary: SDK callback methods for setting values
 * ------------------------------------------------------------------------
 * Details: Each callback is wrapped by the SDK to provide helper methods
 * for writing values to the callbacks received from AM
 *********************************************************************** */
		callback.setInputValue(value);

		$$invalidate(21, savedValue = String(value));
	}

	/**
 * @function toggleVisibility - toggles the password from masked to plaintext
 */
	function toggleVisibility() {
		$$invalidate(11, isVisible = !isVisible);
		$$invalidate(14, type = isVisible ? 'text' : 'password');
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(1, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(2, callbackMetadata = $$props.callbackMetadata);
		if ('key' in $$props) $$invalidate(0, key = $$props.key);
		if ('isInvalid' in $$props) $$invalidate(3, isInvalid = $$props.isInvalid);
		if ('isRequired' in $$props) $$invalidate(4, isRequired = $$props.isRequired);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('showMessage' in $$props) $$invalidate(6, showMessage = $$props.showMessage);
		if ('validationFailure' in $$props) $$invalidate(7, validationFailure = $$props.validationFailure);
		if ('$$scope' in $$props) $$invalidate(23, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata, savedValue, value, confirmValue*/ 3145990) {
			{
				$$invalidate(9, callbackType = callback.getType());
				$$invalidate(0, key = callback?.payload?.input?.[0].name || `password-${callbackMetadata?.idx}`);
				$$invalidate(13, textInputLabel = callback.getPrompt());
				$$invalidate(8, value = callback?.getInputValue());

				/**
 * `savedValue` represents what the user set after blur (local component state)
 * `value` represents what's in the callback (empties from AM response)
 *
 * This unique combination is what produces the most reliable reset flag
 */
				$$invalidate(12, resetValue = !!savedValue && value === '');

				/**
 * Only assign a boolean if the confirm input has an actual value.
 */
				$$invalidate(10, doPasswordsMatch = confirmValue !== undefined
				? confirmValue === value
				: undefined);
			}
		}
	};

	return [
		key,
		callback,
		callbackMetadata,
		isInvalid,
		isRequired,
		style,
		showMessage,
		validationFailure,
		value,
		callbackType,
		doPasswordsMatch,
		isVisible,
		resetValue,
		textInputLabel,
		type,
		Input,
		showPassword,
		confirmInput,
		setValue,
		toggleVisibility,
		confirmValue,
		savedValue,
		slots,
		$$scope
	];
}

class Base extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$D, create_fragment$C, safe_not_equal, {
			callback: 1,
			callbackMetadata: 2,
			key: 0,
			isInvalid: 3,
			isRequired: 4,
			style: 5,
			showMessage: 6,
			validationFailure: 7
		});
	}
}

/* src/lib/journey/callbacks/password/password.svelte generated by Svelte v3.55.1 */

function create_fragment$B(ctx) {
	let base;
	let current;

	base = new Base({
			props: {
				callback: /*callback*/ ctx[0],
				callbackMetadata: /*callbackMetadata*/ ctx[1],
				style: /*style*/ ctx[2],
				key: /*inputName*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(base.$$.fragment);
		},
		m(target, anchor) {
			mount_component(base, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const base_changes = {};
			if (dirty & /*callback*/ 1) base_changes.callback = /*callback*/ ctx[0];
			if (dirty & /*callbackMetadata*/ 2) base_changes.callbackMetadata = /*callbackMetadata*/ ctx[1];
			if (dirty & /*style*/ 4) base_changes.style = /*style*/ ctx[2];
			if (dirty & /*inputName*/ 8) base_changes.key = /*inputName*/ ctx[3];
			base.$set(base_changes);
		},
		i(local) {
			if (current) return;
			transition_in(base.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(base.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(base, detaching);
		}
	};
}

function instance$C($$self, $$props, $$invalidate) {
	const selfSubmitFunction = null;
	const stepMetadata = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { style = {} } = $$props;
	let inputName;

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(0, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(1, callbackMetadata = $$props.callbackMetadata);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata*/ 3) {
			{
				($$invalidate(0, callback), $$invalidate(1, callbackMetadata));
				$$invalidate(3, inputName = callback?.payload?.input?.[0].name || `password-${callbackMetadata?.idx}`);
			}
		}
	};

	return [callback, callbackMetadata, style, inputName, selfSubmitFunction, stepMetadata];
}

class Password extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$C, create_fragment$B, safe_not_equal, {
			selfSubmitFunction: 4,
			stepMetadata: 5,
			callback: 0,
			callbackMetadata: 1,
			style: 2
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[4];
	}

	get stepMetadata() {
		return this.$$.ctx[5];
	}
}

/* src/lib/components/primitives/text/text.svelte generated by Svelte v3.55.1 */

function create_fragment$A(ctx) {
	let p;
	let p_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			attr(p, "class", p_class_value = `${/*classes*/ ctx[0]} tw_text-base tw_text-secondary-dark dark:tw_text-secondary-light tw_input-spacing`);
		},
		m(target, anchor) {
			insert(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1 && p_class_value !== (p_class_value = `${/*classes*/ ctx[0]} tw_text-base tw_text-secondary-dark dark:tw_text-secondary-light tw_input-spacing`)) {
				attr(p, "class", p_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$B($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [classes, $$scope, slots];
}

class Text extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$B, create_fragment$A, safe_not_equal, { classes: 0 });
	}
}

/* src/lib/journey/callbacks/polling-wait/polling-wait.svelte generated by Svelte v3.55.1 */

function create_else_block$6(ctx) {
	let spinner;
	let t;
	let text_1;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-24 tw_mb-6 tw_w-24"
			}
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_1$c] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(spinner.$$.fragment);
			t = space();
			create_component(text_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			insert(target, t, anchor);
			mount_component(text_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope, message*/ 258) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
			if (detaching) detach(t);
			destroy_component(text_1, detaching);
		}
	};
}

// (28:2) {#if options?.inline}
function create_if_block$i(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot$j] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(text_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope, message*/ 258) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(text_1, detaching);
		}
	};
}

// (35:4) <Text>
function create_default_slot_1$c(ctx) {
	let t;

	return {
		c() {
			t = text(/*message*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*message*/ 2) set_data(t, /*message*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (29:4) <Text>
function create_default_slot$j(ctx) {
	let spinner;
	let t0;
	let span;
	let t1;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "white",
				layoutClasses: "tw_h-4 tw_w-4 tw_mr-2"
			}
		});

	return {
		c() {
			create_component(spinner.$$.fragment);
			t0 = space();
			span = element("span");
			t1 = text(/*message*/ ctx[1]);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			insert(target, t0, anchor);
			insert(target, span, anchor);
			append(span, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*message*/ 2) set_data(t1, /*message*/ ctx[1]);
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
		}
	};
}

function create_fragment$z(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$i, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*options*/ ctx[0]?.inline) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "tw_text-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$A($$self, $$props, $$invalidate) {
	const style = {};
	const stepMetadata = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { selfSubmitFunction = null } = $$props;
	let { options = null } = $$props;
	let message;
	let timer;

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(2, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(3, callbackMetadata = $$props.callbackMetadata);
		if ('selfSubmitFunction' in $$props) $$invalidate(6, selfSubmitFunction = $$props.selfSubmitFunction);
		if ('options' in $$props) $$invalidate(0, options = $$props.options);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, timer, callbackMetadata, selfSubmitFunction*/ 204) {
			{
				((($$invalidate(2, callback), $$invalidate(7, timer)), $$invalidate(3, callbackMetadata)), $$invalidate(6, selfSubmitFunction));
				$$invalidate(1, message = callback.getMessage());

				// Clear any existing timeouts to avoid duplicates
				clearTimeout(timer);

				// Create new timeout, now that the previous has been cleared
				$$invalidate(7, timer = setTimeout(
					() => {
						if (callbackMetadata) {
							$$invalidate(3, callbackMetadata.derived.isReadyForSubmission = true, callbackMetadata);
						}

						selfSubmitFunction && selfSubmitFunction();
					},
					callback.getWaitTime()
				));
			}
		}
	};

	return [
		options,
		message,
		callback,
		callbackMetadata,
		style,
		stepMetadata,
		selfSubmitFunction,
		timer
	];
}

class Polling_wait extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$A, create_fragment$z, safe_not_equal, {
			style: 4,
			stepMetadata: 5,
			callback: 2,
			callbackMetadata: 3,
			selfSubmitFunction: 6,
			options: 0
		});
	}

	get style() {
		return this.$$.ctx[4];
	}

	get stepMetadata() {
		return this.$$.ctx[5];
	}
}

/* src/lib/journey/callbacks/redirect/redirect.svelte generated by Svelte v3.55.1 */

function create_default_slot$i(ctx) {
	let t;

	return {
		c() {
			t = text(/*message*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*message*/ 1) set_data(t, /*message*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$y(ctx) {
	let div;
	let spinner;
	let t;
	let text_1;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-24 tw_mb-6 tw_w-24"
			}
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot$i] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(spinner.$$.fragment);
			t = space();
			create_component(text_1.$$.fragment);
			attr(div, "class", "tw_text-center");
			attr(div, "aria-live", "assertive");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(spinner, div, null);
			append(div, t);
			mount_component(text_1, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const text_1_changes = {};

			if (dirty & /*$$scope, message*/ 65) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(spinner);
			destroy_component(text_1);
		}
	};
}

function instance$z($$self, $$props, $$invalidate) {
	const callbackMetadata = null;
	const selfSubmitFunction = null;
	const stepMetadata = null;
	const style = {};
	let { callback } = $$props;
	let message;

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(5, callback = $$props.callback);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback*/ 32) {
			{
				$$invalidate(0, message = `${interpolate('redirectingTo')} ${new URL(callback.getRedirectUrl()).hostname}`);
			}
		}
	};

	return [message, callbackMetadata, selfSubmitFunction, stepMetadata, style, callback];
}

class Redirect extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$z, create_fragment$y, safe_not_equal, {
			callbackMetadata: 1,
			selfSubmitFunction: 2,
			stepMetadata: 3,
			style: 4,
			callback: 5
		});
	}

	get callbackMetadata() {
		return this.$$.ctx[1];
	}

	get selfSubmitFunction() {
		return this.$$.ctx[2];
	}

	get stepMetadata() {
		return this.$$.ctx[3];
	}

	get style() {
		return this.$$.ctx[4];
	}
}

/* src/lib/components/icons/apple-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$x(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", "M11.182.008C11.148-.03 9.923.023 8.857 1.18c-1.066 1.156-.902 2.482-.878 2.516.024.034 1.52.087 2.475-1.258.955-1.345.762-2.391.728-2.43Zm3.314 11.733c-.048-.096-2.325-1.234-2.113-3.422.212-2.189 1.675-2.789 1.698-2.854.023-.065-.597-.79-1.254-1.157a3.692 3.692 0 0 0-1.563-.434c-.108-.003-.483-.095-1.254.116-.508.139-1.653.589-1.968.607-.316.018-1.256-.522-2.267-.665-.647-.125-1.333.131-1.824.328-.49.196-1.422.754-2.074 2.237-.652 1.482-.311 3.83-.067 4.56.244.729.625 1.924 1.273 2.796.576.984 1.34 1.667 1.659 1.899.319.232 1.219.386 1.843.067.502-.308 1.408-.485 1.766-.472.357.013 1.061.154 1.782.539.571.197 1.111.115 1.652-.105.541-.221 1.324-1.059 2.238-2.758.347-.79.505-1.217.473-1.282Z");
			attr(path1, "d", "M11.182.008C11.148-.03 9.923.023 8.857 1.18c-1.066 1.156-.902 2.482-.878 2.516.024.034 1.52.087 2.475-1.258.955-1.345.762-2.391.728-2.43Zm3.314 11.733c-.048-.096-2.325-1.234-2.113-3.422.212-2.189 1.675-2.789 1.698-2.854.023-.065-.597-.79-1.254-1.157a3.692 3.692 0 0 0-1.563-.434c-.108-.003-.483-.095-1.254.116-.508.139-1.653.589-1.968.607-.316.018-1.256-.522-2.267-.665-.647-.125-1.333.131-1.824.328-.49.196-1.422.754-2.074 2.237-.652 1.482-.311 3.83-.067 4.56.244.729.625 1.924 1.273 2.796.576.984 1.34 1.667 1.659 1.899.319.232 1.219.386 1.843.067.502-.308 1.408-.485 1.766-.472.357.013 1.061.154 1.782.539.571.197 1.111.115 1.652-.105.541-.221 1.324-1.059 2.238-2.758.347-.79.505-1.217.473-1.282Z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "fill", "currentColor");
			attr(svg, "viewBox", "0 0 16 18");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}

			if (dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$y($$self, $$props, $$invalidate) {
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
	};

	return [classes, size];
}

class Apple_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$y, create_fragment$x, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/components/icons/facebook-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$w(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M16 8.049c0-4.446-3.582-8.05-8-8.05C3.58 0-.002 3.603-.002 8.05c0 4.017 2.926 7.347 6.75 7.951v-5.625h-2.03V8.05H6.75V6.275c0-2.017 1.195-3.131 3.022-3.131.876 0 1.791.157 1.791.157v1.98h-1.009c-.993 0-1.303.621-1.303 1.258v1.51h2.218l-.354 2.326H9.25V16c3.824-.604 6.75-3.934 6.75-7.951z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "fill", "currentColor");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "viewBox", "0 0 18 18");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$x($$self, $$props, $$invalidate) {
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
	};

	return [classes, size];
}

class Facebook_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$x, create_fragment$w, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/components/icons/google-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$v(ctx) {
	let svg;
	let g;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;

	return {
		c() {
			svg = svg_element("svg");
			g = svg_element("g");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			attr(path0, "fill", "#EA4335");
			attr(path0, "d", "M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z");
			attr(path1, "fill", "#4285F4");
			attr(path1, "d", "M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z");
			attr(path2, "fill", "#FBBC05");
			attr(path2, "d", "M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z");
			attr(path3, "fill", "#34A853");
			attr(path3, "d", "M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z");
			attr(path4, "fill", "none");
			attr(path4, "d", "M0 0h48v48H0z");
			attr(svg, "version", "1.1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 56 56");
			attr(svg, "class", /*classes*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g);
			append(g, path0);
			append(g, path1);
			append(g, path2);
			append(g, path3);
			append(g, path4);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}

			if (dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$w($$self, $$props, $$invalidate) {
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
	};

	return [classes, size];
}

class Google_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$w, create_fragment$v, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/callbacks/select-idp/select-idp.svelte generated by Svelte v3.55.1 */

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (66:56) 
function create_if_block_3$8(ctx) {
	let button;
	let current;

	function func_2() {
		return /*func_2*/ ctx[9](/*idp*/ ctx[10]);
	}

	button = new Button({
			props: {
				classes: "tw_button-google dark:tw_button-google_dark",
				type: "button",
				width: "auto",
				onClick: func_2,
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*idps*/ 2) button_changes.onClick = func_2;

			if (dirty & /*$$scope, idps*/ 8194) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (55:58) 
function create_if_block_2$8(ctx) {
	let button;
	let current;

	function func_1() {
		return /*func_1*/ ctx[8](/*idp*/ ctx[10]);
	}

	button = new Button({
			props: {
				classes: "tw_button-facebook dark:tw_button-facebook_dark",
				type: "button",
				width: "auto",
				onClick: func_1,
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*idps*/ 2) button_changes.onClick = func_1;

			if (dirty & /*$$scope, idps*/ 8194) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (44:4) {#if idp.text.toUpperCase().includes('APPLE')}
function create_if_block_1$a(ctx) {
	let button;
	let current;

	function func() {
		return /*func*/ ctx[7](/*idp*/ ctx[10]);
	}

	button = new Button({
			props: {
				classes: "tw_button-apple dark:tw_button-apple_dark",
				type: "button",
				width: "auto",
				onClick: func,
				$$slots: { default: [create_default_slot_2$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*idps*/ 2) button_changes.onClick = func;

			if (dirty & /*$$scope, idps*/ 8194) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (67:6) <Button         classes="tw_button-google dark:tw_button-google_dark"         type="button"         width="auto"         onClick={() => setBtnValue(idp.value)}       >
function create_default_slot_4$2(ctx) {
	let googleicon;
	let t0;
	let t1;
	let t2;
	let t3_value = /*idp*/ ctx[10].text + "";
	let t3;
	let current;

	googleicon = new Google_icon({
			props: {
				classes: "tw_inline-block tw_fill-current"
			}
		});

	t1 = new Locale_strings({ props: { key: "continueWith" } });

	return {
		c() {
			create_component(googleicon.$$.fragment);
			t0 = space();
			create_component(t1.$$.fragment);
			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			mount_component(googleicon, target, anchor);
			insert(target, t0, anchor);
			mount_component(t1, target, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*idps*/ 2) && t3_value !== (t3_value = /*idp*/ ctx[10].text + "")) set_data(t3, t3_value);
		},
		i(local) {
			if (current) return;
			transition_in(googleicon.$$.fragment, local);
			transition_in(t1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(googleicon.$$.fragment, local);
			transition_out(t1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(googleicon, detaching);
			if (detaching) detach(t0);
			destroy_component(t1, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (56:6) <Button         classes="tw_button-facebook dark:tw_button-facebook_dark"         type="button"         width="auto"         onClick={() => setBtnValue(idp.value)}       >
function create_default_slot_3$3(ctx) {
	let facebookicon;
	let t0;
	let t1;
	let t2;
	let t3_value = /*idp*/ ctx[10].text + "";
	let t3;
	let current;

	facebookicon = new Facebook_icon({
			props: {
				classes: "tw_inline-block tw_fill-current"
			}
		});

	t1 = new Locale_strings({ props: { key: "continueWith" } });

	return {
		c() {
			create_component(facebookicon.$$.fragment);
			t0 = space();
			create_component(t1.$$.fragment);
			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			mount_component(facebookicon, target, anchor);
			insert(target, t0, anchor);
			mount_component(t1, target, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*idps*/ 2) && t3_value !== (t3_value = /*idp*/ ctx[10].text + "")) set_data(t3, t3_value);
		},
		i(local) {
			if (current) return;
			transition_in(facebookicon.$$.fragment, local);
			transition_in(t1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(facebookicon.$$.fragment, local);
			transition_out(t1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(facebookicon, detaching);
			if (detaching) detach(t0);
			destroy_component(t1, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (45:6) <Button         classes="tw_button-apple dark:tw_button-apple_dark"         type="button"         width="auto"         onClick={() => setBtnValue(idp.value)}       >
function create_default_slot_2$6(ctx) {
	let appleicon;
	let t0;
	let t1;
	let t2;
	let t3_value = /*idp*/ ctx[10].text + "";
	let t3;
	let current;

	appleicon = new Apple_icon({
			props: {
				classes: "tw_inline-block tw_fill-current"
			}
		});

	t1 = new Locale_strings({ props: { key: "continueWith" } });

	return {
		c() {
			create_component(appleicon.$$.fragment);
			t0 = space();
			create_component(t1.$$.fragment);
			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			mount_component(appleicon, target, anchor);
			insert(target, t0, anchor);
			mount_component(t1, target, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*idps*/ 2) && t3_value !== (t3_value = /*idp*/ ctx[10].text + "")) set_data(t3, t3_value);
		},
		i(local) {
			if (current) return;
			transition_in(appleicon.$$.fragment, local);
			transition_in(t1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(appleicon.$$.fragment, local);
			transition_out(t1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(appleicon, detaching);
			if (detaching) detach(t0);
			destroy_component(t1, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (43:2) <Grid num={1}>
function create_default_slot_1$b(ctx) {
	let show_if;
	let show_if_1;
	let show_if_2;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$a, create_if_block_2$8, create_if_block_3$8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*idps*/ 2) show_if = null;
		if (dirty & /*idps*/ 2) show_if_1 = null;
		if (dirty & /*idps*/ 2) show_if_2 = null;
		if (show_if == null) show_if = !!/*idp*/ ctx[10].text.toUpperCase().includes('APPLE');
		if (show_if) return 0;
		if (show_if_1 == null) show_if_1 = !!/*idp*/ ctx[10].text.toUpperCase().includes('FACEBOOK');
		if (show_if_1) return 1;
		if (show_if_2 == null) show_if_2 = !!/*idp*/ ctx[10].text.toUpperCase().includes('GOOGLE');
		if (show_if_2) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (42:0) {#each idps as idp}
function create_each_block$8(ctx) {
	let grid;
	let current;

	grid = new Grid({
			props: {
				num: 1,
				$$slots: { default: [create_default_slot_1$b] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(grid.$$.fragment);
		},
		m(target, anchor) {
			mount_component(grid, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const grid_changes = {};

			if (dirty & /*$$scope, idps*/ 8194) {
				grid_changes.$$scope = { dirty, ctx };
			}

			grid.$set(grid_changes);
		},
		i(local) {
			if (current) return;
			transition_in(grid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(grid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(grid, detaching);
		}
	};
}

// (81:0) {#if stepMetadata && stepMetadata.derived.numOfCallbacks > 1}
function create_if_block$h(ctx) {
	let grid;
	let current;

	grid = new Grid({
			props: {
				num: 1,
				$$slots: { default: [create_default_slot$h] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(grid.$$.fragment);
		},
		m(target, anchor) {
			mount_component(grid, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(grid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(grid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(grid, detaching);
		}
	};
}

// (82:2) <Grid num={1}>
function create_default_slot$h(ctx) {
	let hr;

	return {
		c() {
			hr = element("hr");
			attr(hr, "class", "tw_border-0 tw_border-b tw_border-secondary-light dark:tw_border-secondary-dark");
		},
		m(target, anchor) {
			insert(target, hr, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(hr);
		}
	};
}

function create_fragment$u(ctx) {
	let t;
	let if_block_anchor;
	let current;
	let each_value = /*idps*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*stepMetadata*/ ctx[0] && /*stepMetadata*/ ctx[0].derived.numOfCallbacks > 1 && create_if_block$h(ctx);

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*setBtnValue, idps*/ 6) {
				each_value = /*idps*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t.parentNode, t);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*stepMetadata*/ ctx[0] && /*stepMetadata*/ ctx[0].derived.numOfCallbacks > 1) {
				if (if_block) {
					if (dirty & /*stepMetadata*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$h(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$v($$self, $$props, $$invalidate) {
	const style = {};
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { selfSubmitFunction = null } = $$props;
	let { stepMetadata } = $$props;
	let idps;

	/**
 * @function setButtonValue - Sets the value on the callback on button click
 * @param {number} index
 */
	function setBtnValue(value) {
		callback.setProvider(value);

		if (callbackMetadata) {
			$$invalidate(3, callbackMetadata.derived.isReadyForSubmission = true, callbackMetadata);
		}

		selfSubmitFunction && selfSubmitFunction();
	}

	const func = idp => setBtnValue(idp.value);
	const func_1 = idp => setBtnValue(idp.value);
	const func_2 = idp => setBtnValue(idp.value);

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(5, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(3, callbackMetadata = $$props.callbackMetadata);
		if ('selfSubmitFunction' in $$props) $$invalidate(6, selfSubmitFunction = $$props.selfSubmitFunction);
		if ('stepMetadata' in $$props) $$invalidate(0, stepMetadata = $$props.stepMetadata);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback*/ 32) {
			{
				const localAuthentication = callback.getProviders().filter(provider => provider.provider === 'localAuthentication');
				const socialProviders = callback.getProviders().filter(provider => provider.provider !== 'localAuthentication');

				if (localAuthentication.length > 0) {
					// Assume that clicking "next" will indicate the user wants to use local authentication
					callback.setProvider('localAuthentication');
				}

				$$invalidate(1, idps = socialProviders.map(option => ({
					value: option.provider,
					text: option.uiConfig.buttonDisplayName
				})));
			}
		}
	};

	return [
		stepMetadata,
		idps,
		setBtnValue,
		callbackMetadata,
		style,
		callback,
		selfSubmitFunction,
		func,
		func_1,
		func_2
	];
}

class Select_idp extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$v, create_fragment$u, safe_not_equal, {
			style: 4,
			callback: 5,
			callbackMetadata: 3,
			selfSubmitFunction: 6,
			stepMetadata: 0
		});
	}

	get style() {
		return this.$$.ctx[4];
	}
}

/* src/lib/journey/callbacks/_utilities/policies.svelte generated by Svelte v3.55.1 */

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (35:51) 
function create_if_block_1$9(ctx) {
	let div;
	let p;
	let t0;
	let t1;
	let ul;
	let div_id_value;
	let current;
	t0 = new Locale_strings({ props: { key: /*messageKey*/ ctx[1] } });
	let each_value_1 = /*validationRules*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");
			p = element("p");
			create_component(t0.$$.fragment);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(p, "class", "tw_text-secondary-dark dark:tw_text-secondary-light tw_w-full");
			attr(ul, "class", "tw_text-secondary-dark dark:tw_text-secondary-light tw_w-full");
			attr(div, "class", "tw_input-policies tw_w-full");
			attr(div, "id", div_id_value = `${/*key*/ ctx[0] ? `${/*key*/ ctx[0]}-message` : ''}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);
			mount_component(t0, p, null);
			append(div, t1);
			append(div, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			const t0_changes = {};
			if (dirty & /*messageKey*/ 2) t0_changes.key = /*messageKey*/ ctx[1];
			t0.$set(t0_changes);

			if (dirty & /*validationRules*/ 8) {
				each_value_1 = /*validationRules*/ ctx[3];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (!current || dirty & /*key*/ 1 && div_id_value !== (div_id_value = `${/*key*/ ctx[0] ? `${/*key*/ ctx[0]}-message` : ''}`)) {
				attr(div, "id", div_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(t0.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t0.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(t0);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (24:0) {#if simplifiedFailures.length}
function create_if_block$g(ctx) {
	let div;
	let p;
	let t0;
	let t1;
	let ul;
	let div_id_value;
	let current;
	t0 = new Locale_strings({ props: { key: /*messageKey*/ ctx[1] } });
	let each_value = /*simplifiedFailures*/ ctx[4];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");
			p = element("p");
			create_component(t0.$$.fragment);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(p, "class", "tw_text-error-dark dark:tw_text-error-light tw_w-full");
			attr(ul, "class", "tw_text-error-dark dark:tw_text-error-light tw_w-full");
			attr(div, "class", "tw_input-policies tw_w-full");
			attr(div, "id", div_id_value = `${/*key*/ ctx[0] ? `${/*key*/ ctx[0]}-message` : ''}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);
			mount_component(t0, p, null);
			append(div, t1);
			append(div, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			const t0_changes = {};
			if (dirty & /*messageKey*/ 2) t0_changes.key = /*messageKey*/ ctx[1];
			t0.$set(t0_changes);

			if (dirty & /*simplifiedFailures*/ 16) {
				each_value = /*simplifiedFailures*/ ctx[4];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*key*/ 1 && div_id_value !== (div_id_value = `${/*key*/ ctx[0] ? `${/*key*/ ctx[0]}-message` : ''}`)) {
				attr(div, "id", div_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(t0.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t0.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(t0);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (41:6) {#each validationRules as rule}
function create_each_block_1(ctx) {
	let li;
	let t_value = /*rule*/ ctx[11].message + "";
	let t;

	return {
		c() {
			li = element("li");
			t = text(t_value);
			attr(li, "class", "tw_list-disc");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t);
		},
		p(ctx, dirty) {
			if (dirty & /*validationRules*/ 8 && t_value !== (t_value = /*rule*/ ctx[11].message + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (30:6) {#each simplifiedFailures as failure}
function create_each_block$7(ctx) {
	let li;
	let t_value = /*failure*/ ctx[8].message + "";
	let t;

	return {
		c() {
			li = element("li");
			t = text(t_value);
			attr(li, "class", "tw_list-disc");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t);
		},
		p(ctx, dirty) {
			if (dirty & /*simplifiedFailures*/ 16 && t_value !== (t_value = /*failure*/ ctx[8].message + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

function create_fragment$t(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$g, create_if_block_1$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*simplifiedFailures*/ ctx[4].length) return 0;
		if (/*showPolicies*/ ctx[2] && /*validationRules*/ ctx[3].length) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	let { callback } = $$props;
	let { key = undefined } = $$props;
	let { label } = $$props;
	let { messageKey } = $$props;
	let { showPolicies = false } = $$props;
	let validationFailures = getValidationFailures(callback, label);
	let validationRules = getValidationPolicies(callback.getPolicies());

	let simplifiedFailures = validationFailures.reduce(
		(prev, curr) => {
			prev = prev.concat(curr.restructured);
			return prev;
		},
		[]
	);

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(5, callback = $$props.callback);
		if ('key' in $$props) $$invalidate(0, key = $$props.key);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('messageKey' in $$props) $$invalidate(1, messageKey = $$props.messageKey);
		if ('showPolicies' in $$props) $$invalidate(2, showPolicies = $$props.showPolicies);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, label, validationFailures*/ 224) {
			{
				$$invalidate(7, validationFailures = getValidationFailures(callback, label));
				$$invalidate(3, validationRules = getValidationPolicies(callback.getPolicies()));

				$$invalidate(4, simplifiedFailures = validationFailures.reduce(
					(prev, curr) => {
						prev = prev.concat(curr.restructured);
						return prev;
					},
					[]
				));
			}
		}
	};

	return [
		key,
		messageKey,
		showPolicies,
		validationRules,
		simplifiedFailures,
		callback,
		label,
		validationFailures
	];
}

class Policies extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$u, create_fragment$t, safe_not_equal, {
			callback: 5,
			key: 0,
			label: 6,
			messageKey: 1,
			showPolicies: 2
		});
	}
}

/* src/lib/journey/callbacks/string-attribute/string-attribute-input.svelte generated by Svelte v3.55.1 */

function create_default_slot$g(ctx) {
	let policies_1;
	let current;

	policies_1 = new Policies({
			props: {
				callback: /*callback*/ ctx[0],
				key: /*inputName*/ ctx[3],
				label: /*prompt*/ ctx[2],
				messageKey: "valueRequirements"
			}
		});

	return {
		c() {
			create_component(policies_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(policies_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const policies_1_changes = {};
			if (dirty & /*callback*/ 1) policies_1_changes.callback = /*callback*/ ctx[0];
			if (dirty & /*inputName*/ 8) policies_1_changes.key = /*inputName*/ ctx[3];
			if (dirty & /*prompt*/ 4) policies_1_changes.label = /*prompt*/ ctx[2];
			policies_1.$set(policies_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(policies_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(policies_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(policies_1, detaching);
		}
	};
}

// (47:0) {#key callback}
function create_key_block$2(ctx) {
	let input;
	let current;

	input = new /*Input*/ ctx[9]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[1]?.derived.isFirstInvalidInput || false,
				key: /*inputName*/ ctx[3],
				label: interpolate(/*outputName*/ ctx[5], null, /*prompt*/ ctx[2]),
				message: /*isRequired*/ ctx[4]
				? interpolate('inputRequiredError')
				: undefined,
				onChange: /*setValue*/ ctx[10],
				isRequired: /*isRequired*/ ctx[4],
				isInvalid: /*isInvalid*/ ctx[8],
				type: /*type*/ ctx[7],
				showMessage: !!/*isInvalid*/ ctx[8],
				value: /*previousValue*/ ctx[6],
				$$slots: { default: [create_default_slot$g] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty & /*callbackMetadata*/ 2) input_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[1]?.derived.isFirstInvalidInput || false;
			if (dirty & /*inputName*/ 8) input_changes.key = /*inputName*/ ctx[3];
			if (dirty & /*outputName, prompt*/ 36) input_changes.label = interpolate(/*outputName*/ ctx[5], null, /*prompt*/ ctx[2]);

			if (dirty & /*isRequired*/ 16) input_changes.message = /*isRequired*/ ctx[4]
			? interpolate('inputRequiredError')
			: undefined;

			if (dirty & /*isRequired*/ 16) input_changes.isRequired = /*isRequired*/ ctx[4];
			if (dirty & /*isInvalid*/ 256) input_changes.isInvalid = /*isInvalid*/ ctx[8];
			if (dirty & /*type*/ 128) input_changes.type = /*type*/ ctx[7];
			if (dirty & /*isInvalid*/ 256) input_changes.showMessage = !!/*isInvalid*/ ctx[8];
			if (dirty & /*previousValue*/ 64) input_changes.value = /*previousValue*/ ctx[6];

			if (dirty & /*$$scope, callback, inputName, prompt*/ 65549) {
				input_changes.$$scope = { dirty, ctx };
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

function create_fragment$s(ctx) {
	let previous_key = /*callback*/ ctx[0];
	let key_block_anchor;
	let current;
	let key_block = create_key_block$2(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*callback*/ 1 && safe_not_equal(previous_key, previous_key = /*callback*/ ctx[0])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block$2(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(key_block_anchor);
			key_block.d(detaching);
		}
	};
}

function instance$t($$self, $$props, $$invalidate) {
	const selfSubmitFunction = null;
	const stepMetadata = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { style = {} } = $$props;
	const Input = style.labels === 'stacked' ? Stacked_label : Floating_label;
	let inputName;
	let isRequired;
	let outputName;
	let policies;
	let previousValue;
	let prompt;
	let type;
	let validationFailures;
	let isInvalid;

	/**
 * @function setValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setValue(event) {
		callback.setInputValue(event.target.value);
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(0, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(1, callbackMetadata = $$props.callbackMetadata);
		if ('style' in $$props) $$invalidate(13, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata, policies, prompt, validationFailures*/ 49159) {
			{
				/**
 * We need to wrap this in a reactive block, so it reruns the function
 * on value changes within `callback`
 */
				$$invalidate(3, inputName = callback?.payload?.input?.[0].name || `password-${callbackMetadata?.idx}`);

				$$invalidate(4, isRequired = isInputRequired(callback));
				$$invalidate(5, outputName = callback.getOutputByName('name', ''));
				$$invalidate(14, policies = callback.getPolicies());
				$$invalidate(6, previousValue = callback?.getInputValue());
				$$invalidate(2, prompt = callback.getPrompt());
				$$invalidate(7, type = getInputTypeFromPolicies(policies));
				$$invalidate(15, validationFailures = getValidationFailures(callback, prompt));
				$$invalidate(8, isInvalid = !!validationFailures.length);
			}
		}
	};

	return [
		callback,
		callbackMetadata,
		prompt,
		inputName,
		isRequired,
		outputName,
		previousValue,
		type,
		isInvalid,
		Input,
		setValue,
		selfSubmitFunction,
		stepMetadata,
		style,
		policies,
		validationFailures
	];
}

class String_attribute_input extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$t, create_fragment$s, safe_not_equal, {
			selfSubmitFunction: 11,
			stepMetadata: 12,
			callback: 0,
			callbackMetadata: 1,
			style: 13
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[11];
	}

	get stepMetadata() {
		return this.$$.ctx[12];
	}
}

/* src/lib/components/primitives/link/link.svelte generated by Svelte v3.55.1 */

function create_fragment$r(ctx) {
	let a;
	let a_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			a = element("a");
			if (default_slot) default_slot.c();
			attr(a, "class", a_class_value = `${/*classes*/ ctx[0]} tw_link dark:tw_link_dark`);
			attr(a, "href", /*href*/ ctx[1]);
			attr(a, "target", /*target*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1 && a_class_value !== (a_class_value = `${/*classes*/ ctx[0]} tw_link dark:tw_link_dark`)) {
				attr(a, "class", a_class_value);
			}

			if (!current || dirty & /*href*/ 2) {
				attr(a, "href", /*href*/ ctx[1]);
			}

			if (!current || dirty & /*target*/ 4) {
				attr(a, "target", /*target*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { href } = $$props;
	let { target = '_self' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('href' in $$props) $$invalidate(1, href = $$props.href);
		if ('target' in $$props) $$invalidate(2, target = $$props.target);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [classes, href, target, $$scope, slots];
}

class Link extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$s, create_fragment$r, safe_not_equal, { classes: 0, href: 1, target: 2 });
	}
}

/* src/lib/journey/callbacks/terms-and-conditions/terms-conditions.svelte generated by Svelte v3.55.1 */

function create_else_block$5(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.innerHTML = `Error: Configuration is missing <code>termsAndConditions</code> URL.`;
			attr(p, "class", "tw_text-error-dark dark:tw_text-error-light tw_input-spacing");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (27:0) {#if $linksStore?.termsAndConditions}
function create_if_block$f(ctx) {
	let link;
	let t;
	let checkbox;
	let current;

	link = new Link({
			props: {
				classes: "tw_block tw_mb-4",
				href: /*$linksStore*/ ctx[2]?.termsAndConditions,
				target: "_blank",
				$$slots: { default: [create_default_slot_1$a] },
				$$scope: { ctx }
			}
		});

	checkbox = new /*Checkbox*/ ctx[3]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false,
				key: /*inputName*/ ctx[1],
				onChange: /*setValue*/ ctx[4],
				value: false,
				$$slots: { default: [create_default_slot$f] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(link.$$.fragment);
			t = space();
			create_component(checkbox.$$.fragment);
		},
		m(target, anchor) {
			mount_component(link, target, anchor);
			insert(target, t, anchor);
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const link_changes = {};
			if (dirty & /*$linksStore*/ 4) link_changes.href = /*$linksStore*/ ctx[2]?.termsAndConditions;

			if (dirty & /*$$scope*/ 512) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
			const checkbox_changes = {};
			if (dirty & /*callbackMetadata*/ 1) checkbox_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[0]?.derived.isFirstInvalidInput || false;
			if (dirty & /*inputName*/ 2) checkbox_changes.key = /*inputName*/ ctx[1];

			if (dirty & /*$$scope*/ 512) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
		},
		i(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(link.$$.fragment, local);
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(link, detaching);
			if (detaching) detach(t);
			destroy_component(checkbox, detaching);
		}
	};
}

// (28:2) <Link classes="tw_block tw_mb-4" href={$linksStore?.termsAndConditions} target="_blank">
function create_default_slot_1$a(ctx) {
	let t_value = interpolate('termsAndConditionsLinkText') + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (31:2) <Checkbox     isFirstInvalidInput={callbackMetadata?.derived.isFirstInvalidInput || false}     key={inputName}     onChange={setValue}     value={false}   >
function create_default_slot$f(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "termsAndConditions" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

function create_fragment$q(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$f, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$linksStore*/ ctx[2]?.termsAndConditions) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let $linksStore;
	component_subscribe($$self, linksStore, $$value => $$invalidate(2, $linksStore = $$value));
	const selfSubmitFunction = null;
	const stepMetadata = null;
	let { style = {} } = $$props;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;

	const Checkbox = style.checksAndRadios === 'standard'
	? Standard$1
	: Animated$1;

	let inputName;

	/**
 * @function setValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setValue(event) {
		callback.setAccepted(event.target.checked);
	}

	$$self.$$set = $$props => {
		if ('style' in $$props) $$invalidate(7, style = $$props.style);
		if ('callback' in $$props) $$invalidate(8, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(0, callbackMetadata = $$props.callbackMetadata);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata*/ 257) {
			{
				$$invalidate(1, inputName = callback?.payload?.input?.[0].name || `terms-${callbackMetadata?.idx}`);
			}
		}
	};

	return [
		callbackMetadata,
		inputName,
		$linksStore,
		Checkbox,
		setValue,
		selfSubmitFunction,
		stepMetadata,
		style,
		callback
	];
}

class Terms_conditions extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$r, create_fragment$q, safe_not_equal, {
			selfSubmitFunction: 5,
			stepMetadata: 6,
			style: 7,
			callback: 8,
			callbackMetadata: 0
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[5];
	}

	get stepMetadata() {
		return this.$$.ctx[6];
	}
}

/* src/lib/journey/callbacks/text-output/text-output.svelte generated by Svelte v3.55.1 */

function create_else_block$4(ctx) {
	let alert;
	let current;

	alert = new Alert({
			props: {
				id: "",
				needsFocus: false,
				type: /*callbackMessageType*/ ctx[1],
				$$slots: { default: [create_default_slot_1$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*callbackMessageType*/ 2) alert_changes.type = /*callbackMessageType*/ ctx[1];

			if (dirty & /*$$scope, cleanMessage*/ 257) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
		}
	};
}

// (32:0) {#if callbackMessageType === 'info'}
function create_if_block$e(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				classes: /*cleanMessage*/ ctx[0].length < 100
				? 'tw_font-bold tw_mt-6'
				: 'tw_mt-6',
				$$slots: { default: [create_default_slot$e] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(text_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*cleanMessage*/ 1) text_1_changes.classes = /*cleanMessage*/ ctx[0].length < 100
			? 'tw_font-bold tw_mt-6'
			: 'tw_mt-6';

			if (dirty & /*$$scope, cleanMessage*/ 257) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(text_1, detaching);
		}
	};
}

// (37:2) <Alert id="" needsFocus={false} type={callbackMessageType}>
function create_default_slot_1$9(ctx) {
	let t;

	return {
		c() {
			t = text(/*cleanMessage*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*cleanMessage*/ 1) set_data(t, /*cleanMessage*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (33:2) <Text classes={cleanMessage.length < 100 ? 'tw_font-bold tw_mt-6' : 'tw_mt-6'}>
function create_default_slot$e(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*cleanMessage*/ ctx[0], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*cleanMessage*/ 1) html_tag.p(/*cleanMessage*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

function create_fragment$p(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$e, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*callbackMessageType*/ ctx[1] === 'info') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function getCallbackMessage(messageType) {
	switch (messageType) {
		case '0':
			return 'info';
		case '1':
			return 'warning';
		case '2':
			return 'error';
		default:
			return 'info';
	}
}

function instance$q($$self, $$props, $$invalidate) {
	const callbackMetadata = null;
	const selfSubmitFunction = null;
	const stepMetadata = null;
	const style = {};
	let { callback } = $$props;
	let dirtyMessage = callback.getMessage();
	let cleanMessage = sanitize(dirtyMessage);
	let callbackMessageType = 'info';

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(6, callback = $$props.callback);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, dirtyMessage*/ 192) {
			{
				$$invalidate(7, dirtyMessage = callback.getMessage());
				$$invalidate(0, cleanMessage = sanitize(dirtyMessage));
				$$invalidate(1, callbackMessageType = getCallbackMessage(callback.getMessageType()));
			}
		}
	};

	return [
		cleanMessage,
		callbackMessageType,
		callbackMetadata,
		selfSubmitFunction,
		stepMetadata,
		style,
		callback,
		dirtyMessage
	];
}

class Text_output extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$q, create_fragment$p, safe_not_equal, {
			callbackMetadata: 2,
			selfSubmitFunction: 3,
			stepMetadata: 4,
			style: 5,
			callback: 6
		});
	}

	get callbackMetadata() {
		return this.$$.ctx[2];
	}

	get selfSubmitFunction() {
		return this.$$.ctx[3];
	}

	get stepMetadata() {
		return this.$$.ctx[4];
	}

	get style() {
		return this.$$.ctx[5];
	}
}

/* src/lib/journey/callbacks/unknown/unknown.svelte generated by Svelte v3.55.1 */

function create_fragment$o(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = `Unknown callback encountered: ${/*type*/ ctx[0]}. Please contact support.`;
			attr(p, "class", "tw_text-base tw_text-secondary-dark dark:tw_text-secondary-light tw_input-spacing");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	const callbackMetadata = null;
	const selfSubmitFunction = null;
	const stepMetadata = null;
	const style = {};
	let { callback } = $$props;
	const type = callback.getType();

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(5, callback = $$props.callback);
	};

	return [type, callbackMetadata, selfSubmitFunction, stepMetadata, style, callback];
}

class Unknown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$p, create_fragment$o, safe_not_equal, {
			callbackMetadata: 1,
			selfSubmitFunction: 2,
			stepMetadata: 3,
			style: 4,
			callback: 5
		});
	}

	get callbackMetadata() {
		return this.$$.ctx[1];
	}

	get selfSubmitFunction() {
		return this.$$.ctx[2];
	}

	get stepMetadata() {
		return this.$$.ctx[3];
	}

	get style() {
		return this.$$.ctx[4];
	}
}

/* src/lib/journey/callbacks/password/validated-create-password.svelte generated by Svelte v3.55.1 */

function create_default_slot$d(ctx) {
	let policies;
	let current;

	policies = new Policies({
			props: {
				callback: /*callback*/ ctx[0],
				label: /*prompt*/ ctx[3],
				messageKey: "passwordRequirements",
				showPolicies: true
			}
		});

	return {
		c() {
			create_component(policies.$$.fragment);
		},
		m(target, anchor) {
			mount_component(policies, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const policies_changes = {};
			if (dirty & /*callback*/ 1) policies_changes.callback = /*callback*/ ctx[0];
			if (dirty & /*prompt*/ 8) policies_changes.label = /*prompt*/ ctx[3];
			policies.$set(policies_changes);
		},
		i(local) {
			if (current) return;
			transition_in(policies.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(policies.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(policies, detaching);
		}
	};
}

// (28:0) {#key callback}
function create_key_block$1(ctx) {
	let base;
	let current;

	base = new Base({
			props: {
				callback: /*callback*/ ctx[0],
				callbackMetadata: /*callbackMetadata*/ ctx[1],
				isInvalid: /*isInvalid*/ ctx[5],
				isRequired: /*isRequired*/ ctx[6],
				key: /*inputName*/ ctx[4],
				showMessage: /*isInvalid*/ ctx[5],
				style: /*style*/ ctx[2],
				$$slots: { default: [create_default_slot$d] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(base.$$.fragment);
		},
		m(target, anchor) {
			mount_component(base, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const base_changes = {};
			if (dirty & /*callback*/ 1) base_changes.callback = /*callback*/ ctx[0];
			if (dirty & /*callbackMetadata*/ 2) base_changes.callbackMetadata = /*callbackMetadata*/ ctx[1];
			if (dirty & /*isInvalid*/ 32) base_changes.isInvalid = /*isInvalid*/ ctx[5];
			if (dirty & /*inputName*/ 16) base_changes.key = /*inputName*/ ctx[4];
			if (dirty & /*isInvalid*/ 32) base_changes.showMessage = /*isInvalid*/ ctx[5];
			if (dirty & /*style*/ 4) base_changes.style = /*style*/ ctx[2];

			if (dirty & /*$$scope, callback, prompt*/ 1033) {
				base_changes.$$scope = { dirty, ctx };
			}

			base.$set(base_changes);
		},
		i(local) {
			if (current) return;
			transition_in(base.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(base.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(base, detaching);
		}
	};
}

function create_fragment$n(ctx) {
	let previous_key = /*callback*/ ctx[0];
	let key_block_anchor;
	let current;
	let key_block = create_key_block$1(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*callback*/ 1 && safe_not_equal(previous_key, previous_key = /*callback*/ ctx[0])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block$1(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(key_block_anchor);
			key_block.d(detaching);
		}
	};
}

function instance$o($$self, $$props, $$invalidate) {
	const selfSubmitFunction = null;
	const stepMetadata = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { style = {} } = $$props;
	const isRequired = isInputRequired(callback);
	let inputName;
	let isInvalid;
	let prompt;
	let validationFailures;

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(0, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(1, callbackMetadata = $$props.callbackMetadata);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata, prompt, validationFailures*/ 523) {
			{
				/**
 * We need to wrap this in a reactive block, so it reruns the function
 * on value changes within `callback`
 */
				$$invalidate(4, inputName = callback?.payload?.input?.[0].name || `password-${callbackMetadata?.idx}`);

				$$invalidate(3, prompt = callback.getPrompt());
				$$invalidate(9, validationFailures = getValidationFailures(callback, prompt));
				$$invalidate(5, isInvalid = !!validationFailures.length);
			}
		}
	};

	return [
		callback,
		callbackMetadata,
		style,
		prompt,
		inputName,
		isInvalid,
		isRequired,
		selfSubmitFunction,
		stepMetadata,
		validationFailures
	];
}

class Validated_create_password extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$o, create_fragment$n, safe_not_equal, {
			selfSubmitFunction: 7,
			stepMetadata: 8,
			callback: 0,
			callbackMetadata: 1,
			style: 2
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[7];
	}

	get stepMetadata() {
		return this.$$.ctx[8];
	}
}

/* src/lib/journey/callbacks/username/validated-create-username.svelte generated by Svelte v3.55.1 */

function create_default_slot$c(ctx) {
	let policies;
	let current;

	policies = new Policies({
			props: {
				callback: /*callback*/ ctx[0],
				key: /*inputName*/ ctx[4],
				label: /*prompt*/ ctx[2],
				messageKey: "usernameRequirements"
			}
		});

	return {
		c() {
			create_component(policies.$$.fragment);
		},
		m(target, anchor) {
			mount_component(policies, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const policies_changes = {};
			if (dirty & /*callback*/ 1) policies_changes.callback = /*callback*/ ctx[0];
			if (dirty & /*inputName*/ 16) policies_changes.key = /*inputName*/ ctx[4];
			if (dirty & /*prompt*/ 4) policies_changes.label = /*prompt*/ ctx[2];
			policies.$set(policies_changes);
		},
		i(local) {
			if (current) return;
			transition_in(policies.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(policies.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(policies, detaching);
		}
	};
}

// (38:0) {#key callback}
function create_key_block(ctx) {
	let input;
	let current;

	input = new /*Input*/ ctx[8]({
			props: {
				isFirstInvalidInput: /*callbackMetadata*/ ctx[1]?.derived.isFirstInvalidInput || false,
				isRequired: /*isRequired*/ ctx[6],
				isInvalid: /*isInvalid*/ ctx[5],
				key: /*inputName*/ ctx[4],
				label: interpolate(textToKey(/*callbackType*/ ctx[3]), null, /*prompt*/ ctx[2]),
				message: /*isRequired*/ ctx[6]
				? interpolate('inputRequiredError')
				: undefined,
				onChange: /*setValue*/ ctx[9],
				showMessage: false,
				type: "text",
				value: typeof /*value*/ ctx[7] === 'string'
				? /*value*/ ctx[7]
				: '',
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty & /*callbackMetadata*/ 2) input_changes.isFirstInvalidInput = /*callbackMetadata*/ ctx[1]?.derived.isFirstInvalidInput || false;
			if (dirty & /*isRequired*/ 64) input_changes.isRequired = /*isRequired*/ ctx[6];
			if (dirty & /*isInvalid*/ 32) input_changes.isInvalid = /*isInvalid*/ ctx[5];
			if (dirty & /*inputName*/ 16) input_changes.key = /*inputName*/ ctx[4];
			if (dirty & /*callbackType, prompt*/ 12) input_changes.label = interpolate(textToKey(/*callbackType*/ ctx[3]), null, /*prompt*/ ctx[2]);

			if (dirty & /*isRequired*/ 64) input_changes.message = /*isRequired*/ ctx[6]
			? interpolate('inputRequiredError')
			: undefined;

			if (dirty & /*value*/ 128) input_changes.value = typeof /*value*/ ctx[7] === 'string'
			? /*value*/ ctx[7]
			: '';

			if (dirty & /*$$scope, callback, inputName, prompt*/ 16405) {
				input_changes.$$scope = { dirty, ctx };
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

function create_fragment$m(ctx) {
	let previous_key = /*callback*/ ctx[0];
	let key_block_anchor;
	let current;
	let key_block = create_key_block(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*callback*/ 1 && safe_not_equal(previous_key, previous_key = /*callback*/ ctx[0])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(key_block_anchor);
			key_block.d(detaching);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	const selfSubmitFunction = null;
	const stepMetadata = null;
	let { callback } = $$props;
	let { callbackMetadata } = $$props;
	let { style = {} } = $$props;
	const Input = style.labels === 'stacked' ? Stacked_label : Floating_label;
	let callbackType;
	let inputName;
	let isInvalid;
	let isRequired;
	let prompt;
	let value;
	let validationFailures;

	/**
 * @function setValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setValue(event) {
		callback.setInputValue(event.target.value);
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(0, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(1, callbackMetadata = $$props.callbackMetadata);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*callback, callbackMetadata, prompt, validationFailures*/ 8199) {
			{
				$$invalidate(3, callbackType = callback.getType());
				$$invalidate(4, inputName = callback?.payload?.input?.[0].name || `validated-name=${callbackMetadata?.idx}`);
				$$invalidate(6, isRequired = isInputRequired(callback));
				$$invalidate(2, prompt = callback.getPrompt());
				$$invalidate(7, value = callback?.getInputValue());
				$$invalidate(13, validationFailures = getValidationFailures(callback, prompt));
				$$invalidate(5, isInvalid = !!validationFailures.length);
			}
		}
	};

	return [
		callback,
		callbackMetadata,
		prompt,
		callbackType,
		inputName,
		isInvalid,
		isRequired,
		value,
		Input,
		setValue,
		selfSubmitFunction,
		stepMetadata,
		style,
		validationFailures
	];
}

class Validated_create_username extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$n, create_fragment$m, safe_not_equal, {
			selfSubmitFunction: 10,
			stepMetadata: 11,
			callback: 0,
			callbackMetadata: 1,
			style: 12
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[10];
	}

	get stepMetadata() {
		return this.$$.ctx[11];
	}
}

/* src/lib/journey/callbacks/device-profile/device-profile.svelte generated by Svelte v3.55.1 */

function create_if_block$d(ctx) {
	let div;
	let spinner;
	let t;
	let text_1;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-24 tw_mb-6 tw_w-24"
			}
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(spinner.$$.fragment);
			t = space();
			create_component(text_1.$$.fragment);
			attr(div, "class", "tw_text-center tw_w-full tw_py-4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(spinner, div, null);
			append(div, t);
			mount_component(text_1, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 128) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(spinner);
			destroy_component(text_1);
		}
	};
}

// (26:4) <Text>
function create_default_slot$b(ctx) {
	let t;

	return {
		c() {
			t = text(/*deviceMessage*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$l(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*stepMetadata*/ ctx[0]?.derived.numOfCallbacks === 1 && create_if_block$d(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*stepMetadata*/ ctx[0]?.derived.numOfCallbacks === 1) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*stepMetadata*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$d(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let { callback } = $$props;
	let { callbackMetadata = null } = $$props;
	let { stepMetadata = null } = $$props;
	let { selfSubmitFunction } = $$props;
	const device = new O$1({});
	let deviceMessage = callback.getMessage();

	async function initializeProfile() {
		const location = callback?.isLocationRequired() ?? false;
		const metadata = callback?.isMetadataRequired() ?? false;
		const profile = await device.getProfile({ location, metadata });
		callback.setProfile(profile);

		if (callbackMetadata) {
			$$invalidate(2, callbackMetadata.derived.isReadyForSubmission = true, callbackMetadata);
		}

		return selfSubmitFunction && selfSubmitFunction();
	}

	initializeProfile();

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(3, callback = $$props.callback);
		if ('callbackMetadata' in $$props) $$invalidate(2, callbackMetadata = $$props.callbackMetadata);
		if ('stepMetadata' in $$props) $$invalidate(0, stepMetadata = $$props.stepMetadata);
		if ('selfSubmitFunction' in $$props) $$invalidate(4, selfSubmitFunction = $$props.selfSubmitFunction);
	};

	return [stepMetadata, deviceMessage, callbackMetadata, callback, selfSubmitFunction];
}

class Device_profile extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$m, create_fragment$l, safe_not_equal, {
			callback: 3,
			callbackMetadata: 2,
			stepMetadata: 0,
			selfSubmitFunction: 4
		});
	}
}

/*
 * Because hcaptch and grecaptcha would
 * both be loaded on the page, we need to just leverage
 * the classnames to determine which one is being rendered.
 * This is retrieved from the step
 */
function checkForHCaptcha(captchaClassname) {
    return captchaClassname.match('h-captcha');
}
function renderCaptcha({ nameOfCaptcha, siteKey, }) {
    if (nameOfCaptcha === 'hcaptcha' && window.hcaptcha) {
        return window.hcaptcha.render('fr-recaptcha', {
            sitekey: siteKey,
            callback: 'frHandleCaptcha',
            'expired-callback': 'frHandleExpiredCallback',
            'chalexpired-callback': 'frHandleExpiredCallback',
            'error-callback': 'frHandleErrorCallback',
        });
    }
    if (nameOfCaptcha === 'grecaptcha' && window.grecaptcha) {
        return window.grecaptcha.render('fr-recaptcha', {
            sitekey: siteKey,
            callback: window.frHandleCaptcha,
            'expired-callback': window.frHandleExpiredCallback,
        });
    }
}
function handleCaptchaError(callback) {
    const siteKey = callback?.getSiteKey() ?? '';
    const className = callback?.getOutputByName('captchaDivClass', 'h-captcha') ?? 'h-captcha';
    if (checkForHCaptcha(className)) {
        return () => renderCaptcha({ nameOfCaptcha: 'hcaptcha', siteKey });
    }
    else {
        return () => renderCaptcha({ nameOfCaptcha: 'grecaptcha', siteKey });
    }
}
function handleCaptchaToken(callback) {
    return (token) => {
        callback?.setResult(token);
    };
}

/* src/lib/journey/callbacks/recaptcha/recaptcha.svelte generated by Svelte v3.55.1 */

function create_if_block$c(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "id", "fr-recaptcha");
			attr(div, "class", `${/*recaptchaClass*/ ctx[2]} tw_flex-1 tw_w-full tw_input-spacing`);
			attr(div, "data-sitekey", /*siteKey*/ ctx[0]);
			attr(div, "data-expired-callback", "frHandleExpiredCallback");
			attr(div, "data-chalexpired-callback", "frHandleExpiredCallback");
			attr(div, "data-error-callback", "frHandleErrorCallback");
			attr(div, "data-callback", "frHandleCaptcha");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$k(ctx) {
	let if_block_anchor;
	let if_block = /*isV3*/ ctx[1] === false && create_if_block$c(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*isV3*/ ctx[1] === false) if_block.p(ctx, dirty);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { callback } = $$props;
	const selfSubmitFunction = null;
	const stepMetadata = null;
	const style = {};

	/**
 * This is a component level variable that is set from the journey store
 * If it isn't passed in via journey.start, we
 * default to the journey.tree value. However, journey.tree won't
 * necessarily be set on mount. It is async, so we
 * have to wait for it to resolve. Therefore, defaulting to
 * an empty string so its falsey.
 */
	let recaptchaAction = '';

	const siteKey = callback?.getSiteKey() ?? '';
	let isV3 = callback?.getOutputByName('reCaptchaV3', false);

	/**
 * AM defaults the class name to g-captcha which is wrong
 * I dont think we should be manipulating the class here,
 * but the classname should be g-recaptcha for google
 */
	const recaptchaClass = callback?.getOutputByName('captchaDivClass', 'h-captcha') ?? 'h-captcha';

	onMount(() => {
		if (isV3) {
			// If ReCaptcha v3, do nothing and return early
			return;
		}

		if (callback) {
			window.frHandleCaptchaError = handleCaptchaError(callback);
			window.frHandleCaptcha = handleCaptchaToken(callback);

			window.frHandleExpiredCallback = function handleExpiredCallback() {
				callback?.setResult('');
				renderCaptcha({ nameOfCaptcha: 'hcaptcha', siteKey });
			};

			renderCaptcha({
				nameOfCaptcha: recaptchaClass === 'g-recaptcha'
				? 'grecaptcha'
				: 'hcaptcha',
				siteKey
			});
		}
	});

	// defining this outside of the reactive block and guarding it with a isV3 check so it only runs when v3
	// is defined as true and we have a recaptcha action to assign.
	function executeV3Captcha() {
		if (isV3 && recaptchaAction.length) {
			try {
				window.grecaptcha.ready(async function () {
					const value = await window.grecaptcha.execute(siteKey, { action: recaptchaAction });
					callback?.setResult(value);
				});
			} catch(err) {
				throw new Error(`Error executing recaptcha. Please make sure you have passed a siteKey and you have loaded the google recaptcha script in your app prior to this Error: ${err}`);
			}
		}
	}

	journeyStore.subscribe(value => {
		$$invalidate(7, recaptchaAction = value?.recaptchaAction ?? '');
	});

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(3, callback = $$props.callback);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*recaptchaAction*/ 128) {
			{
				if (recaptchaAction.length) {
					executeV3Captcha();
				}
			}
		}
	};

	return [
		siteKey,
		isV3,
		recaptchaClass,
		callback,
		selfSubmitFunction,
		stepMetadata,
		style,
		recaptchaAction
	];
}

class Recaptcha extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$l, create_fragment$k, safe_not_equal, {
			callback: 3,
			selfSubmitFunction: 4,
			stepMetadata: 5,
			style: 6
		});
	}

	get selfSubmitFunction() {
		return this.$$.ctx[4];
	}

	get stepMetadata() {
		return this.$$.ctx[5];
	}

	get style() {
		return this.$$.ctx[6];
	}
}

/* src/lib/journey/callbacks/metadata/metadata.svelte generated by Svelte v3.55.1 */

function instance$k($$self, $$props, $$invalidate) {
	const callback = null;
	const callbackMetadata = null;
	const selfSubmitFunction = null;
	const stepMetadata = null;
	const style = {};
	return [callback, callbackMetadata, selfSubmitFunction, stepMetadata, style];
}

class Metadata extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$k, null, safe_not_equal, {
			callback: 0,
			callbackMetadata: 1,
			selfSubmitFunction: 2,
			stepMetadata: 3,
			style: 4
		});
	}

	get callback() {
		return this.$$.ctx[0];
	}

	get callbackMetadata() {
		return this.$$.ctx[1];
	}

	get selfSubmitFunction() {
		return this.$$.ctx[2];
	}

	get stepMetadata() {
		return this.$$.ctx[3];
	}

	get style() {
		return this.$$.ctx[4];
	}
}

/* src/lib/journey/callbacks/ping-protect-evaluation/ping-protect-evaluation.svelte generated by Svelte v3.55.1 */

function create_default_slot$a(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "signalsEvaluation" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

function create_fragment$j(ctx) {
	let div;
	let spinner;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-24 tw_mb-6 tw_w-24",
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(spinner.$$.fragment);
			attr(div, "class", "tw_text-center tw_w-full tw_py-4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(spinner, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const spinner_changes = {};

			if (dirty & /*$$scope*/ 16) {
				spinner_changes.$$scope = { dirty, ctx };
			}

			spinner.$set(spinner_changes);
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(spinner);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	let { callback } = $$props;
	let { selfSubmitFunction = null } = $$props;
	let { pingProtect = { envId: '' } } = $$props;
	let pauseBehavioralData = false;

	onMount(() => {
		async function handleGetData() {
			try {
				await e.getData();
			} catch(error) {
				if (error instanceof Error) {
					callback.setClientError(error.message);
				} else {
					callback.setClientError('An error occurred while initializing PingProtect');
				}
			}

			return selfSubmitFunction && selfSubmitFunction();
		}

		handleGetData();
	});

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(0, callback = $$props.callback);
		if ('selfSubmitFunction' in $$props) $$invalidate(1, selfSubmitFunction = $$props.selfSubmitFunction);
		if ('pingProtect' in $$props) $$invalidate(2, pingProtect = $$props.pingProtect);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*pingProtect, pauseBehavioralData*/ 12) {
			{
				$$invalidate(3, pauseBehavioralData = pingProtect?.behavioralDataCollection ?? false);

				if (typeof window !== 'undefined') {
					if (pauseBehavioralData === true) {
						e.pauseBehavioralData();
					} else {
						e.resumeBehavioralData();
					}
				}
			}
		}
	};

	return [callback, selfSubmitFunction, pingProtect, pauseBehavioralData];
}

class Ping_protect_evaluation extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			callback: 0,
			selfSubmitFunction: 1,
			pingProtect: 2
		});
	}
}

/* src/lib/journey/callbacks/ping-protect-initialize/ping-protect-initialize.svelte generated by Svelte v3.55.1 */

function create_if_block$b(ctx) {
	let spinner;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-24 tw_mb-6 tw_w-24"
			}
		});

	return {
		c() {
			create_component(spinner.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
		}
	};
}

function create_fragment$i(ctx) {
	let div;
	let current;
	let if_block = !/*loaded*/ ctx[0] && create_if_block$b();

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!/*loaded*/ ctx[0]) {
				if (if_block) {
					if (dirty & /*loaded*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$b();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	const style = {};
	const stepMetadata = null;
	let { callback } = $$props;
	let { selfSubmitFunction = null } = $$props;
	let loaded = false;

	onMount(() => {
		async function loadingPingProtect() {
			const config = callback.getConfig();

			try {
				await e.start(config);
				$$invalidate(0, loaded = true);
			} catch(error) {
				if (error instanceof Error) {
					callback.setClientError(error.message);
				} else {
					callback.setClientError('An error occurred while initializing PingProtect');
				}
			}

			return selfSubmitFunction && selfSubmitFunction();
		}

		loadingPingProtect();
	});

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(3, callback = $$props.callback);
		if ('selfSubmitFunction' in $$props) $$invalidate(4, selfSubmitFunction = $$props.selfSubmitFunction);
	};

	return [loaded, style, stepMetadata, callback, selfSubmitFunction];
}

class Ping_protect_initialize extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
			style: 1,
			stepMetadata: 2,
			callback: 3,
			selfSubmitFunction: 4
		});
	}

	get style() {
		return this.$$.ctx[1];
	}

	get stepMetadata() {
		return this.$$.ctx[2];
	}
}

/* src/lib/journey/_utilities/callback-mapper.svelte generated by Svelte v3.55.1 */

function get_else_ctx(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_FRCallback*/ child_ctx[23]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_20(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_PingProtectInitialize*/ child_ctx[22]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_19(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_PingProtectEvaluation*/ child_ctx[21]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_18(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_RecaptchaCallback*/ child_ctx[20]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_17(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_MetadataCallback*/ child_ctx[18]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_16(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_DeviceProfileCallback*/ child_ctx[19]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_15(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_SuspendedTextOutputCallback*/ child_ctx[17]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_14(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_TextOutputCallback*/ child_ctx[16]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_13(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_TermsAndConditionsCallback*/ child_ctx[15]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_12(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_ValidatedCreateUsernameCallback*/ child_ctx[14]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_11(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_ValidatedCreatePasswordCallback*/ child_ctx[13]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_10(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_StringAttributeInputCallback*/ child_ctx[12]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_9(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_SelectIdPCallback*/ child_ctx[11]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_8(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_RedirectCallback*/ child_ctx[10]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_7(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_PollingWaitCallback*/ child_ctx[9]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_6(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_PasswordCallback*/ child_ctx[8]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_5(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_NameCallback*/ child_ctx[7]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_4(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_KbaCreateCallback*/ child_ctx[6]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_3(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_HiddenValueCallback*/ child_ctx[5]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_2(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_ConfirmationCallback*/ child_ctx[4]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx_1(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_ChoiceCallback*/ child_ctx[3]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_if_ctx$1(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		.../*props*/ child_ctx[0],
		callback: /*_BooleanAttributeInputCallback*/ child_ctx[2]
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

// (253:0) {:else}
function create_else_block$3(ctx) {
	let unknown;
	let current;
	const unknown_spread_levels = [/*newProps*/ ctx[24]];
	let unknown_props = {};

	for (let i = 0; i < unknown_spread_levels.length; i += 1) {
		unknown_props = assign(unknown_props, unknown_spread_levels[i]);
	}

	unknown = new Unknown({ props: unknown_props });

	return {
		c() {
			create_component(unknown.$$.fragment);
		},
		m(target, anchor) {
			mount_component(unknown, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const unknown_changes = (dirty & /*props, _FRCallback*/ 8388609)
			? get_spread_update(unknown_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			unknown.$set(unknown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(unknown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(unknown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(unknown, detaching);
		}
	};
}

// (247:67) 
function create_if_block_20(ctx) {
	let pingprotectinitialize;
	let current;
	const pingprotectinitialize_spread_levels = [/*newProps*/ ctx[24]];
	let pingprotectinitialize_props = {};

	for (let i = 0; i < pingprotectinitialize_spread_levels.length; i += 1) {
		pingprotectinitialize_props = assign(pingprotectinitialize_props, pingprotectinitialize_spread_levels[i]);
	}

	pingprotectinitialize = new Ping_protect_initialize({ props: pingprotectinitialize_props });

	return {
		c() {
			create_component(pingprotectinitialize.$$.fragment);
		},
		m(target, anchor) {
			mount_component(pingprotectinitialize, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const pingprotectinitialize_changes = (dirty & /*props, _PingProtectInitialize*/ 4194305)
			? get_spread_update(pingprotectinitialize_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			pingprotectinitialize.$set(pingprotectinitialize_changes);
		},
		i(local) {
			if (current) return;
			transition_in(pingprotectinitialize.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(pingprotectinitialize.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(pingprotectinitialize, detaching);
		}
	};
}

// (241:67) 
function create_if_block_19(ctx) {
	let pingprotectevaluation;
	let current;
	const pingprotectevaluation_spread_levels = [/*newProps*/ ctx[24]];
	let pingprotectevaluation_props = {};

	for (let i = 0; i < pingprotectevaluation_spread_levels.length; i += 1) {
		pingprotectevaluation_props = assign(pingprotectevaluation_props, pingprotectevaluation_spread_levels[i]);
	}

	pingprotectevaluation = new Ping_protect_evaluation({ props: pingprotectevaluation_props });

	return {
		c() {
			create_component(pingprotectevaluation.$$.fragment);
		},
		m(target, anchor) {
			mount_component(pingprotectevaluation, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const pingprotectevaluation_changes = (dirty & /*props, _PingProtectEvaluation*/ 2097153)
			? get_spread_update(pingprotectevaluation_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			pingprotectevaluation.$set(pingprotectevaluation_changes);
		},
		i(local) {
			if (current) return;
			transition_in(pingprotectevaluation.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(pingprotectevaluation.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(pingprotectevaluation, detaching);
		}
	};
}

// (235:52) 
function create_if_block_18(ctx) {
	let recaptcha;
	let current;
	const recaptcha_spread_levels = [/*newProps*/ ctx[24]];
	let recaptcha_props = {};

	for (let i = 0; i < recaptcha_spread_levels.length; i += 1) {
		recaptcha_props = assign(recaptcha_props, recaptcha_spread_levels[i]);
	}

	recaptcha = new Recaptcha({ props: recaptcha_props });

	return {
		c() {
			create_component(recaptcha.$$.fragment);
		},
		m(target, anchor) {
			mount_component(recaptcha, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const recaptcha_changes = (dirty & /*props, _RecaptchaCallback*/ 1048577)
			? get_spread_update(recaptcha_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			recaptcha.$set(recaptcha_changes);
		},
		i(local) {
			if (current) return;
			transition_in(recaptcha.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(recaptcha.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(recaptcha, detaching);
		}
	};
}

// (229:51) 
function create_if_block_17(ctx) {
	let metadata;
	let current;
	const metadata_spread_levels = [/*newProps*/ ctx[24]];
	let metadata_props = {};

	for (let i = 0; i < metadata_spread_levels.length; i += 1) {
		metadata_props = assign(metadata_props, metadata_spread_levels[i]);
	}

	metadata = new Metadata({ props: metadata_props });

	return {
		c() {
			create_component(metadata.$$.fragment);
		},
		m(target, anchor) {
			mount_component(metadata, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const metadata_changes = (dirty & /*props, _MetadataCallback*/ 262145)
			? get_spread_update(metadata_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			metadata.$set(metadata_changes);
		},
		i(local) {
			if (current) return;
			transition_in(metadata.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(metadata.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(metadata, detaching);
		}
	};
}

// (223:56) 
function create_if_block_16(ctx) {
	let deviceprofile;
	let current;
	const deviceprofile_spread_levels = [/*newProps*/ ctx[24]];
	let deviceprofile_props = {};

	for (let i = 0; i < deviceprofile_spread_levels.length; i += 1) {
		deviceprofile_props = assign(deviceprofile_props, deviceprofile_spread_levels[i]);
	}

	deviceprofile = new Device_profile({ props: deviceprofile_props });

	return {
		c() {
			create_component(deviceprofile.$$.fragment);
		},
		m(target, anchor) {
			mount_component(deviceprofile, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const deviceprofile_changes = (dirty & /*props, _DeviceProfileCallback*/ 524289)
			? get_spread_update(deviceprofile_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			deviceprofile.$set(deviceprofile_changes);
		},
		i(local) {
			if (current) return;
			transition_in(deviceprofile.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(deviceprofile.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(deviceprofile, detaching);
		}
	};
}

// (217:62) 
function create_if_block_15(ctx) {
	let textoutput;
	let current;
	const textoutput_spread_levels = [/*newProps*/ ctx[24]];
	let textoutput_props = {};

	for (let i = 0; i < textoutput_spread_levels.length; i += 1) {
		textoutput_props = assign(textoutput_props, textoutput_spread_levels[i]);
	}

	textoutput = new Text_output({ props: textoutput_props });

	return {
		c() {
			create_component(textoutput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textoutput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textoutput_changes = (dirty & /*props, _SuspendedTextOutputCallback*/ 131073)
			? get_spread_update(textoutput_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			textoutput.$set(textoutput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textoutput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textoutput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textoutput, detaching);
		}
	};
}

// (211:53) 
function create_if_block_14(ctx) {
	let textoutput;
	let current;
	const textoutput_spread_levels = [/*newProps*/ ctx[24]];
	let textoutput_props = {};

	for (let i = 0; i < textoutput_spread_levels.length; i += 1) {
		textoutput_props = assign(textoutput_props, textoutput_spread_levels[i]);
	}

	textoutput = new Text_output({ props: textoutput_props });

	return {
		c() {
			create_component(textoutput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textoutput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textoutput_changes = (dirty & /*props, _TextOutputCallback*/ 65537)
			? get_spread_update(textoutput_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			textoutput.$set(textoutput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textoutput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textoutput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textoutput, detaching);
		}
	};
}

// (205:61) 
function create_if_block_13(ctx) {
	let termsconditions;
	let current;
	const termsconditions_spread_levels = [/*newProps*/ ctx[24]];
	let termsconditions_props = {};

	for (let i = 0; i < termsconditions_spread_levels.length; i += 1) {
		termsconditions_props = assign(termsconditions_props, termsconditions_spread_levels[i]);
	}

	termsconditions = new Terms_conditions({ props: termsconditions_props });

	return {
		c() {
			create_component(termsconditions.$$.fragment);
		},
		m(target, anchor) {
			mount_component(termsconditions, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const termsconditions_changes = (dirty & /*props, _TermsAndConditionsCallback*/ 32769)
			? get_spread_update(termsconditions_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			termsconditions.$set(termsconditions_changes);
		},
		i(local) {
			if (current) return;
			transition_in(termsconditions.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(termsconditions.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(termsconditions, detaching);
		}
	};
}

// (199:66) 
function create_if_block_12(ctx) {
	let validatedcreateusername;
	let current;
	const validatedcreateusername_spread_levels = [/*newProps*/ ctx[24]];
	let validatedcreateusername_props = {};

	for (let i = 0; i < validatedcreateusername_spread_levels.length; i += 1) {
		validatedcreateusername_props = assign(validatedcreateusername_props, validatedcreateusername_spread_levels[i]);
	}

	validatedcreateusername = new Validated_create_username({ props: validatedcreateusername_props });

	return {
		c() {
			create_component(validatedcreateusername.$$.fragment);
		},
		m(target, anchor) {
			mount_component(validatedcreateusername, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const validatedcreateusername_changes = (dirty & /*props, _ValidatedCreateUsernameCallback*/ 16385)
			? get_spread_update(validatedcreateusername_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			validatedcreateusername.$set(validatedcreateusername_changes);
		},
		i(local) {
			if (current) return;
			transition_in(validatedcreateusername.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(validatedcreateusername.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(validatedcreateusername, detaching);
		}
	};
}

// (193:66) 
function create_if_block_11(ctx) {
	let validatedcreatepassword;
	let current;
	const validatedcreatepassword_spread_levels = [/*newProps*/ ctx[24]];
	let validatedcreatepassword_props = {};

	for (let i = 0; i < validatedcreatepassword_spread_levels.length; i += 1) {
		validatedcreatepassword_props = assign(validatedcreatepassword_props, validatedcreatepassword_spread_levels[i]);
	}

	validatedcreatepassword = new Validated_create_password({ props: validatedcreatepassword_props });

	return {
		c() {
			create_component(validatedcreatepassword.$$.fragment);
		},
		m(target, anchor) {
			mount_component(validatedcreatepassword, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const validatedcreatepassword_changes = (dirty & /*props, _ValidatedCreatePasswordCallback*/ 8193)
			? get_spread_update(validatedcreatepassword_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			validatedcreatepassword.$set(validatedcreatepassword_changes);
		},
		i(local) {
			if (current) return;
			transition_in(validatedcreatepassword.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(validatedcreatepassword.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(validatedcreatepassword, detaching);
		}
	};
}

// (187:63) 
function create_if_block_10(ctx) {
	let stringattributeinput;
	let current;
	const stringattributeinput_spread_levels = [/*newProps*/ ctx[24]];
	let stringattributeinput_props = {};

	for (let i = 0; i < stringattributeinput_spread_levels.length; i += 1) {
		stringattributeinput_props = assign(stringattributeinput_props, stringattributeinput_spread_levels[i]);
	}

	stringattributeinput = new String_attribute_input({ props: stringattributeinput_props });

	return {
		c() {
			create_component(stringattributeinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(stringattributeinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const stringattributeinput_changes = (dirty & /*props, _StringAttributeInputCallback*/ 4097)
			? get_spread_update(stringattributeinput_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			stringattributeinput.$set(stringattributeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(stringattributeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(stringattributeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(stringattributeinput, detaching);
		}
	};
}

// (181:52) 
function create_if_block_9(ctx) {
	let selectidp;
	let current;
	const selectidp_spread_levels = [/*newProps*/ ctx[24]];
	let selectidp_props = {};

	for (let i = 0; i < selectidp_spread_levels.length; i += 1) {
		selectidp_props = assign(selectidp_props, selectidp_spread_levels[i]);
	}

	selectidp = new Select_idp({ props: selectidp_props });

	return {
		c() {
			create_component(selectidp.$$.fragment);
		},
		m(target, anchor) {
			mount_component(selectidp, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const selectidp_changes = (dirty & /*props, _SelectIdPCallback*/ 2049)
			? get_spread_update(selectidp_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			selectidp.$set(selectidp_changes);
		},
		i(local) {
			if (current) return;
			transition_in(selectidp.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(selectidp.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(selectidp, detaching);
		}
	};
}

// (175:51) 
function create_if_block_8(ctx) {
	let redirect;
	let current;
	const redirect_spread_levels = [/*newProps*/ ctx[24]];
	let redirect_props = {};

	for (let i = 0; i < redirect_spread_levels.length; i += 1) {
		redirect_props = assign(redirect_props, redirect_spread_levels[i]);
	}

	redirect = new Redirect({ props: redirect_props });

	return {
		c() {
			create_component(redirect.$$.fragment);
		},
		m(target, anchor) {
			mount_component(redirect, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const redirect_changes = (dirty & /*props, _RedirectCallback*/ 1025)
			? get_spread_update(redirect_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			redirect.$set(redirect_changes);
		},
		i(local) {
			if (current) return;
			transition_in(redirect.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(redirect.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(redirect, detaching);
		}
	};
}

// (169:54) 
function create_if_block_7(ctx) {
	let pollingwait;
	let current;
	const pollingwait_spread_levels = [/*newProps*/ ctx[24]];
	let pollingwait_props = {};

	for (let i = 0; i < pollingwait_spread_levels.length; i += 1) {
		pollingwait_props = assign(pollingwait_props, pollingwait_spread_levels[i]);
	}

	pollingwait = new Polling_wait({ props: pollingwait_props });

	return {
		c() {
			create_component(pollingwait.$$.fragment);
		},
		m(target, anchor) {
			mount_component(pollingwait, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const pollingwait_changes = (dirty & /*props, _PollingWaitCallback*/ 513)
			? get_spread_update(pollingwait_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			pollingwait.$set(pollingwait_changes);
		},
		i(local) {
			if (current) return;
			transition_in(pollingwait.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(pollingwait.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(pollingwait, detaching);
		}
	};
}

// (163:51) 
function create_if_block_6(ctx) {
	let password;
	let current;
	const password_spread_levels = [/*newProps*/ ctx[24]];
	let password_props = {};

	for (let i = 0; i < password_spread_levels.length; i += 1) {
		password_props = assign(password_props, password_spread_levels[i]);
	}

	password = new Password({ props: password_props });

	return {
		c() {
			create_component(password.$$.fragment);
		},
		m(target, anchor) {
			mount_component(password, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const password_changes = (dirty & /*props, _PasswordCallback*/ 257)
			? get_spread_update(password_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			password.$set(password_changes);
		},
		i(local) {
			if (current) return;
			transition_in(password.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(password.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(password, detaching);
		}
	};
}

// (157:47) 
function create_if_block_5$1(ctx) {
	let name;
	let current;
	const name_spread_levels = [/*newProps*/ ctx[24]];
	let name_props = {};

	for (let i = 0; i < name_spread_levels.length; i += 1) {
		name_props = assign(name_props, name_spread_levels[i]);
	}

	name = new Name({ props: name_props });

	return {
		c() {
			create_component(name.$$.fragment);
		},
		m(target, anchor) {
			mount_component(name, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const name_changes = (dirty & /*props, _NameCallback*/ 129)
			? get_spread_update(name_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			name.$set(name_changes);
		},
		i(local) {
			if (current) return;
			transition_in(name.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(name.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(name, detaching);
		}
	};
}

// (151:52) 
function create_if_block_4$5(ctx) {
	let kbacreate;
	let current;
	const kbacreate_spread_levels = [/*newProps*/ ctx[24]];
	let kbacreate_props = {};

	for (let i = 0; i < kbacreate_spread_levels.length; i += 1) {
		kbacreate_props = assign(kbacreate_props, kbacreate_spread_levels[i]);
	}

	kbacreate = new Kba_create({ props: kbacreate_props });

	return {
		c() {
			create_component(kbacreate.$$.fragment);
		},
		m(target, anchor) {
			mount_component(kbacreate, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const kbacreate_changes = (dirty & /*props, _KbaCreateCallback*/ 65)
			? get_spread_update(kbacreate_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			kbacreate.$set(kbacreate_changes);
		},
		i(local) {
			if (current) return;
			transition_in(kbacreate.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(kbacreate.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(kbacreate, detaching);
		}
	};
}

// (145:54) 
function create_if_block_3$7(ctx) {
	let hiddenvalue;
	let current;
	const hiddenvalue_spread_levels = [/*newProps*/ ctx[24]];
	let hiddenvalue_props = {};

	for (let i = 0; i < hiddenvalue_spread_levels.length; i += 1) {
		hiddenvalue_props = assign(hiddenvalue_props, hiddenvalue_spread_levels[i]);
	}

	hiddenvalue = new Hidden_value({ props: hiddenvalue_props });

	return {
		c() {
			create_component(hiddenvalue.$$.fragment);
		},
		m(target, anchor) {
			mount_component(hiddenvalue, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const hiddenvalue_changes = (dirty & /*props, _HiddenValueCallback*/ 33)
			? get_spread_update(hiddenvalue_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			hiddenvalue.$set(hiddenvalue_changes);
		},
		i(local) {
			if (current) return;
			transition_in(hiddenvalue.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(hiddenvalue.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(hiddenvalue, detaching);
		}
	};
}

// (139:55) 
function create_if_block_2$7(ctx) {
	let confirmation;
	let current;
	const confirmation_spread_levels = [/*newProps*/ ctx[24]];
	let confirmation_props = {};

	for (let i = 0; i < confirmation_spread_levels.length; i += 1) {
		confirmation_props = assign(confirmation_props, confirmation_spread_levels[i]);
	}

	confirmation = new Confirmation({ props: confirmation_props });

	return {
		c() {
			create_component(confirmation.$$.fragment);
		},
		m(target, anchor) {
			mount_component(confirmation, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const confirmation_changes = (dirty & /*props, _ConfirmationCallback*/ 17)
			? get_spread_update(confirmation_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			confirmation.$set(confirmation_changes);
		},
		i(local) {
			if (current) return;
			transition_in(confirmation.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(confirmation.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(confirmation, detaching);
		}
	};
}

// (133:49) 
function create_if_block_1$8(ctx) {
	let choice;
	let current;
	const choice_spread_levels = [/*newProps*/ ctx[24]];
	let choice_props = {};

	for (let i = 0; i < choice_spread_levels.length; i += 1) {
		choice_props = assign(choice_props, choice_spread_levels[i]);
	}

	choice = new Choice({ props: choice_props });

	return {
		c() {
			create_component(choice.$$.fragment);
		},
		m(target, anchor) {
			mount_component(choice, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const choice_changes = (dirty & /*props, _ChoiceCallback*/ 9)
			? get_spread_update(choice_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			choice.$set(choice_changes);
		},
		i(local) {
			if (current) return;
			transition_in(choice.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(choice.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(choice, detaching);
		}
	};
}

// (127:0) {#if cbType === CallbackType.BooleanAttributeInputCallback}
function create_if_block$a(ctx) {
	let boolean;
	let current;
	const boolean_spread_levels = [/*newProps*/ ctx[24]];
	let boolean_props = {};

	for (let i = 0; i < boolean_spread_levels.length; i += 1) {
		boolean_props = assign(boolean_props, boolean_spread_levels[i]);
	}

	boolean = new Boolean$1({ props: boolean_props });

	return {
		c() {
			create_component(boolean.$$.fragment);
		},
		m(target, anchor) {
			mount_component(boolean, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const boolean_changes = (dirty & /*props, _BooleanAttributeInputCallback*/ 5)
			? get_spread_update(boolean_spread_levels, [get_spread_object(/*newProps*/ ctx[24])])
			: {};

			boolean.$set(boolean_changes);
		},
		i(local) {
			if (current) return;
			transition_in(boolean.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(boolean.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(boolean, detaching);
		}
	};
}

function create_fragment$h(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block$a,
		create_if_block_1$8,
		create_if_block_2$7,
		create_if_block_3$7,
		create_if_block_4$5,
		create_if_block_5$1,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9,
		create_if_block_10,
		create_if_block_11,
		create_if_block_12,
		create_if_block_13,
		create_if_block_14,
		create_if_block_15,
		create_if_block_16,
		create_if_block_17,
		create_if_block_18,
		create_if_block_19,
		create_if_block_20,
		create_else_block$3
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*cbType*/ ctx[1] === l.BooleanAttributeInputCallback) return 0;
		if (/*cbType*/ ctx[1] === l.ChoiceCallback) return 1;
		if (/*cbType*/ ctx[1] === l.ConfirmationCallback) return 2;
		if (/*cbType*/ ctx[1] === l.HiddenValueCallback) return 3;
		if (/*cbType*/ ctx[1] === l.KbaCreateCallback) return 4;
		if (/*cbType*/ ctx[1] === l.NameCallback) return 5;
		if (/*cbType*/ ctx[1] === l.PasswordCallback) return 6;
		if (/*cbType*/ ctx[1] === l.PollingWaitCallback) return 7;
		if (/*cbType*/ ctx[1] === l.RedirectCallback) return 8;
		if (/*cbType*/ ctx[1] === l.SelectIdPCallback) return 9;
		if (/*cbType*/ ctx[1] === l.StringAttributeInputCallback) return 10;
		if (/*cbType*/ ctx[1] === l.ValidatedCreatePasswordCallback) return 11;
		if (/*cbType*/ ctx[1] === l.ValidatedCreateUsernameCallback) return 12;
		if (/*cbType*/ ctx[1] === l.TermsAndConditionsCallback) return 13;
		if (/*cbType*/ ctx[1] === l.TextOutputCallback) return 14;
		if (/*cbType*/ ctx[1] === l.SuspendedTextOutputCallback) return 15;
		if (/*cbType*/ ctx[1] === l.DeviceProfileCallback) return 16;
		if (/*cbType*/ ctx[1] === l.MetadataCallback) return 17;
		if (/*cbType*/ ctx[1] === l.ReCaptchaCallback) return 18;
		if (/*cbType*/ ctx[1] === l.PingOneProtectEvaluationCallback) return 19;
		if (/*cbType*/ ctx[1] === l.PingOneProtectInitializeCallback) return 20;
		return 21;
	}

	function select_block_ctx(ctx, index) {
		if (index === 0) return get_if_ctx$1(ctx);
		if (index === 1) return get_if_ctx_1(ctx);
		if (index === 2) return get_if_ctx_2(ctx);
		if (index === 3) return get_if_ctx_3(ctx);
		if (index === 4) return get_if_ctx_4(ctx);
		if (index === 5) return get_if_ctx_5(ctx);
		if (index === 6) return get_if_ctx_6(ctx);
		if (index === 7) return get_if_ctx_7(ctx);
		if (index === 8) return get_if_ctx_8(ctx);
		if (index === 9) return get_if_ctx_9(ctx);
		if (index === 10) return get_if_ctx_10(ctx);
		if (index === 11) return get_if_ctx_11(ctx);
		if (index === 12) return get_if_ctx_12(ctx);
		if (index === 13) return get_if_ctx_13(ctx);
		if (index === 14) return get_if_ctx_14(ctx);
		if (index === 15) return get_if_ctx_15(ctx);
		if (index === 16) return get_if_ctx_16(ctx);
		if (index === 17) return get_if_ctx_17(ctx);
		if (index === 18) return get_if_ctx_18(ctx);
		if (index === 19) return get_if_ctx_19(ctx);
		if (index === 20) return get_if_ctx_20(ctx);
		return get_else_ctx(ctx);
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(select_block_ctx(ctx, current_block_type_index), dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
					if_block.c();
				} else {
					if_block.p(select_block_ctx(ctx, current_block_type_index), dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let { props } = $$props;
	let cbType;
	let _BooleanAttributeInputCallback;
	let _ChoiceCallback;
	let _ConfirmationCallback;
	let _HiddenValueCallback;
	let _KbaCreateCallback;
	let _NameCallback;
	let _PasswordCallback;
	let _PollingWaitCallback;
	let _RedirectCallback;
	let _SelectIdPCallback;
	let _StringAttributeInputCallback;
	let _ValidatedCreatePasswordCallback;
	let _ValidatedCreateUsernameCallback;
	let _TermsAndConditionsCallback;
	let _TextOutputCallback;
	let _SuspendedTextOutputCallback;
	let _MetadataCallback;
	let _DeviceProfileCallback;
	let _RecaptchaCallback;
	let _PingProtectEvaluation;
	let _PingProtectInitialize;
	let _FRCallback;

	$$self.$$set = $$props => {
		if ('props' in $$props) $$invalidate(0, props = $$props.props);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*props, cbType*/ 3) {
			{
				$$invalidate(1, cbType = props.callback.getType());

				switch (cbType) {
					case l.BooleanAttributeInputCallback:
						$$invalidate(2, _BooleanAttributeInputCallback = props.callback);
						break;
					case l.ChoiceCallback:
						$$invalidate(3, _ChoiceCallback = props.callback);
						break;
					case l.ConfirmationCallback:
						$$invalidate(4, _ConfirmationCallback = props.callback);
						break;
					case l.HiddenValueCallback:
						$$invalidate(5, _HiddenValueCallback = props.callback);
						break;
					case l.KbaCreateCallback:
						$$invalidate(6, _KbaCreateCallback = props.callback);
						break;
					case l.NameCallback:
						$$invalidate(7, _NameCallback = props.callback);
						break;
					case l.ReCaptchaCallback:
						$$invalidate(20, _RecaptchaCallback = props.callback);
						break;
					case l.PasswordCallback:
						$$invalidate(8, _PasswordCallback = props.callback);
						break;
					case l.PollingWaitCallback:
						$$invalidate(9, _PollingWaitCallback = props.callback);
						break;
					case l.RedirectCallback:
						$$invalidate(10, _RedirectCallback = props.callback);
						break;
					case l.SelectIdPCallback:
						$$invalidate(11, _SelectIdPCallback = props.callback);
						break;
					case l.StringAttributeInputCallback:
						$$invalidate(12, _StringAttributeInputCallback = props.callback);
						break;
					case l.ValidatedCreatePasswordCallback:
						$$invalidate(13, _ValidatedCreatePasswordCallback = props.callback);
						break;
					case l.ValidatedCreateUsernameCallback:
						$$invalidate(14, _ValidatedCreateUsernameCallback = props.callback);
						break;
					case l.TermsAndConditionsCallback:
						$$invalidate(15, _TermsAndConditionsCallback = props.callback);
						break;
					case l.TextOutputCallback:
						$$invalidate(16, _TextOutputCallback = props.callback);
						break;
					case l.SuspendedTextOutputCallback:
						$$invalidate(17, _SuspendedTextOutputCallback = props.callback);
						break;
					case l.DeviceProfileCallback:
						$$invalidate(19, _DeviceProfileCallback = props.callback);
						break;
					case l.MetadataCallback:
						$$invalidate(18, _MetadataCallback = props.callback);
						break;
					case l.PingOneProtectEvaluationCallback:
						$$invalidate(21, _PingProtectEvaluation = props.callback);
						break;
					case l.PingOneProtectInitializeCallback:
						$$invalidate(22, _PingProtectInitialize = props.callback);
						break;
					default:
						$$invalidate(23, _FRCallback = props.callback);
				}
			}
		}
	};

	return [
		props,
		cbType,
		_BooleanAttributeInputCallback,
		_ChoiceCallback,
		_ConfirmationCallback,
		_HiddenValueCallback,
		_KbaCreateCallback,
		_NameCallback,
		_PasswordCallback,
		_PollingWaitCallback,
		_RedirectCallback,
		_SelectIdPCallback,
		_StringAttributeInputCallback,
		_ValidatedCreatePasswordCallback,
		_ValidatedCreateUsernameCallback,
		_TermsAndConditionsCallback,
		_TextOutputCallback,
		_SuspendedTextOutputCallback,
		_MetadataCallback,
		_DeviceProfileCallback,
		_RecaptchaCallback,
		_PingProtectEvaluation,
		_PingProtectInitialize,
		_FRCallback
	];
}

class Callback_mapper extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { props: 0 });
	}
}

/* src/lib/journey/stages/generic.svelte generated by Svelte v3.55.1 */

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

// (70:2) {#if form?.icon && componentStyle !== 'inline'}
function create_if_block_4$4(ctx) {
	let div;
	let shieldicon;
	let current;

	shieldicon = new Shield_icon({
			props: {
				classes: "tw_text-gray-400 tw_fill-current",
				size: "72px"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(shieldicon.$$.fragment);
			attr(div, "class", "tw_flex tw_justify-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(shieldicon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(shieldicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shieldicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(shieldicon);
		}
	};
}

// (86:2) {#if form?.message}
function create_if_block_3$6(ctx) {
	let alert;
	let current;

	alert = new Alert({
			props: {
				id: formFailureMessageId$3,
				needsFocus: /*alertNeedsFocus*/ ctx[6],
				type: "error",
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*alertNeedsFocus*/ 64) alert_changes.needsFocus = /*alertNeedsFocus*/ ctx[6];

			if (dirty & /*$$scope, formMessageKey, form*/ 524420) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
		}
	};
}

// (87:4) <Alert id={formFailureMessageId} needsFocus={alertNeedsFocus} type="error">
function create_default_slot_4$1(ctx) {
	let t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*formMessageKey, form*/ 132 && t_value !== (t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (92:2) {#each step?.callbacks as callback, idx}
function create_each_block$6(ctx) {
	let callbackmapper;
	let current;

	callbackmapper = new Callback_mapper({
			props: {
				props: {
					callback: /*callback*/ ctx[16],
					callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[18]],
					selfSubmitFunction: /*determineSubmission*/ ctx[12],
					stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
					style: /*$styleStore*/ ctx[11]
				}
			}
		});

	return {
		c() {
			create_component(callbackmapper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callbackmapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callbackmapper_changes = {};

			if (dirty & /*step, metadata, $styleStore*/ 2096) callbackmapper_changes.props = {
				callback: /*callback*/ ctx[16],
				callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[18]],
				selfSubmitFunction: /*determineSubmission*/ ctx[12],
				stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
				style: /*$styleStore*/ ctx[11]
			};

			callbackmapper.$set(callbackmapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callbackmapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callbackmapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callbackmapper, detaching);
		}
	};
}

// (117:61) 
function create_if_block_2$6(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				busy: /*journey*/ ctx[3]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*journey*/ 8) button_changes.busy = /*journey*/ ctx[3]?.loading;

			if (dirty & /*$$scope*/ 524288) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (113:56) 
function create_if_block_1$7(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				busy: /*journey*/ ctx[3]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_2$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*journey*/ 8) button_changes.busy = /*journey*/ ctx[3]?.loading;

			if (dirty & /*$$scope*/ 524288) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (109:2) {#if !metadata?.step?.derived.isStepSelfSubmittable()}
function create_if_block$9(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				busy: /*journey*/ ctx[3]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_1$8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*journey*/ 8) button_changes.busy = /*journey*/ ctx[3]?.loading;

			if (dirty & /*$$scope*/ 524288) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (118:4) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_3$2(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "nextButton" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (114:4) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_2$5(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "nextButton" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (110:4) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_1$8(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "nextButton" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (63:0) <Form   bind:formEl   ariaDescribedBy={formAriaDescriptor}   id={formElementId}   needsFocus={formNeedsFocus}   onSubmitWhenValid={submitFormWrapper} >
function create_default_slot$9(ctx) {
	let t0;
	let header;
	let h1;
	let sanitize0;
	let t1;
	let p;
	let sanitize1;
	let t2;
	let t3;
	let t4;
	let show_if;
	let current_block_type_index;
	let if_block2;
	let t5;
	let backto;
	let current;
	let if_block0 = /*form*/ ctx[2]?.icon && /*componentStyle*/ ctx[1] !== 'inline' && create_if_block_4$4();

	sanitize0 = new Server_strings({
			props: {
				html: true,
				string: /*step*/ ctx[5]?.getHeader() || ''
			}
		});

	sanitize1 = new Server_strings({
			props: {
				html: true,
				string: /*step*/ ctx[5]?.getDescription() || ''
			}
		});

	let if_block1 = /*form*/ ctx[2]?.message && create_if_block_3$6(ctx);
	let each_value = /*step*/ ctx[5]?.callbacks;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const if_block_creators = [create_if_block$9, create_if_block_1$7, create_if_block_2$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*metadata*/ 16) show_if = null;
		if (show_if == null) show_if = !!!/*metadata*/ ctx[4]?.step?.derived.isStepSelfSubmittable();
		if (show_if) return 0;
		if (/*metadata*/ ctx[4]?.step?.derived.isUserInputOptional) return 1;
		if (!/*metadata*/ ctx[4]?.step?.derived.numOfSelfSubmittableCbs) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	backto = new Back_to({ props: { journey: /*journey*/ ctx[3] } });

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			header = element("header");
			h1 = element("h1");
			create_component(sanitize0.$$.fragment);
			t1 = space();
			p = element("p");
			create_component(sanitize1.$$.fragment);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			create_component(backto.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
			attr(p, "class", "tw_text-center tw_-mt-5 tw_mb-2 tw_py-4 tw_text-secondary-dark dark:tw_text-secondary-light");
			attr(header, "id", formHeaderId$3);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, header, anchor);
			append(header, h1);
			mount_component(sanitize0, h1, null);
			append(header, t1);
			append(header, p);
			mount_component(sanitize1, p, null);
			/*header_binding*/ ctx[14](header);
			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t3, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t4, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, t5, anchor);
			mount_component(backto, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*form*/ ctx[2]?.icon && /*componentStyle*/ ctx[1] !== 'inline') {
				if (if_block0) {
					if (dirty & /*form, componentStyle*/ 6) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$4();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const sanitize0_changes = {};
			if (dirty & /*step*/ 32) sanitize0_changes.string = /*step*/ ctx[5]?.getHeader() || '';
			sanitize0.$set(sanitize0_changes);
			const sanitize1_changes = {};
			if (dirty & /*step*/ 32) sanitize1_changes.string = /*step*/ ctx[5]?.getDescription() || '';
			sanitize1.$set(sanitize1_changes);

			if (/*form*/ ctx[2]?.message) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*form*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*step, metadata, determineSubmission, $styleStore*/ 6192) {
				each_value = /*step*/ ctx[5]?.callbacks;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t4.parentNode, t4);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block2) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block2 = if_blocks[current_block_type_index];

					if (!if_block2) {
						if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block2.c();
					} else {
						if_block2.p(ctx, dirty);
					}

					transition_in(if_block2, 1);
					if_block2.m(t5.parentNode, t5);
				} else {
					if_block2 = null;
				}
			}

			const backto_changes = {};
			if (dirty & /*journey*/ 8) backto_changes.journey = /*journey*/ ctx[3];
			backto.$set(backto_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(sanitize0.$$.fragment, local);
			transition_in(sanitize1.$$.fragment, local);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block2);
			transition_in(backto.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(sanitize0.$$.fragment, local);
			transition_out(sanitize1.$$.fragment, local);
			transition_out(if_block1);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block2);
			transition_out(backto.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(header);
			destroy_component(sanitize0);
			destroy_component(sanitize1);
			/*header_binding*/ ctx[14](null);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t4);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(t5);
			destroy_component(backto, detaching);
		}
	};
}

function create_fragment$g(ctx) {
	let form_1;
	let updating_formEl;
	let current;

	function form_1_formEl_binding(value) {
		/*form_1_formEl_binding*/ ctx[15](value);
	}

	let form_1_props = {
		ariaDescribedBy: /*formAriaDescriptor*/ ctx[8],
		id: formElementId$3,
		needsFocus: /*formNeedsFocus*/ ctx[9],
		onSubmitWhenValid: /*submitFormWrapper*/ ctx[13],
		$$slots: { default: [create_default_slot$9] },
		$$scope: { ctx }
	};

	if (/*formEl*/ ctx[0] !== void 0) {
		form_1_props.formEl = /*formEl*/ ctx[0];
	}

	form_1 = new Form({ props: form_1_props });
	binding_callbacks.push(() => bind(form_1, 'formEl', form_1_formEl_binding));

	return {
		c() {
			create_component(form_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const form_1_changes = {};
			if (dirty & /*formAriaDescriptor*/ 256) form_1_changes.ariaDescribedBy = /*formAriaDescriptor*/ ctx[8];
			if (dirty & /*formNeedsFocus*/ 512) form_1_changes.needsFocus = /*formNeedsFocus*/ ctx[9];

			if (dirty & /*$$scope, journey, metadata, step, $styleStore, alertNeedsFocus, formMessageKey, form, linkWrapper, componentStyle*/ 527614) {
				form_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_formEl && dirty & /*formEl*/ 1) {
				updating_formEl = true;
				form_1_changes.formEl = /*formEl*/ ctx[0];
				add_flush_callback(() => updating_formEl = false);
			}

			form_1.$set(form_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form_1, detaching);
		}
	};
}

const formFailureMessageId$3 = 'genericStepFailureMessage';
const formHeaderId$3 = 'genericStepHeader';
const formElementId$3 = 'genericStepForm';

function instance$g($$self, $$props, $$invalidate) {
	let $styleStore;
	component_subscribe($$self, styleStore, $$value => $$invalidate(11, $styleStore = $$value));
	let { componentStyle } = $$props;
	let { form } = $$props;
	let { formEl = null } = $$props;
	let { journey } = $$props;
	let { metadata } = $$props;
	let { step } = $$props;
	let alertNeedsFocus = false;
	let formMessageKey = '';
	let formAriaDescriptor = 'genericStepHeader';
	let formNeedsFocus = false;
	let linkWrapper;

	function determineSubmission() {
		// TODO: the below is more strict; all self-submitting cbs have to complete before submitting
		// if (stepMetadata.isStepSelfSubmittable && isStepReadyToSubmit(callbackMetadataArray)) {
		// The below variation is more liberal, first self-submittable cb to call this wins.
		if (metadata?.step?.derived.isStepSelfSubmittable()) {
			submitFormWrapper();
		}
	}

	function submitFormWrapper() {
		$$invalidate(6, alertNeedsFocus = false);
		$$invalidate(9, formNeedsFocus = false);
		form?.submit();
	}

	afterUpdate(() => {
		if (form?.message) {
			$$invalidate(8, formAriaDescriptor = formFailureMessageId$3);
			$$invalidate(6, alertNeedsFocus = true);
			$$invalidate(9, formNeedsFocus = false);
		} else {
			$$invalidate(8, formAriaDescriptor = formHeaderId$3);
			$$invalidate(6, alertNeedsFocus = false);
			$$invalidate(9, formNeedsFocus = true);
		}
	});

	onMount(() => captureLinks(linkWrapper, journey));

	function header_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			linkWrapper = $$value;
			$$invalidate(10, linkWrapper);
		});
	}

	function form_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(0, formEl);
	}

	$$self.$$set = $$props => {
		if ('componentStyle' in $$props) $$invalidate(1, componentStyle = $$props.componentStyle);
		if ('form' in $$props) $$invalidate(2, form = $$props.form);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('journey' in $$props) $$invalidate(3, journey = $$props.journey);
		if ('metadata' in $$props) $$invalidate(4, metadata = $$props.metadata);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*step, form*/ 36) {
			{
				shouldRedirectFromStep(step) && f$1.redirect(step);
				$$invalidate(7, formMessageKey = convertStringToKey(form?.message));
			}
		}
	};

	return [
		formEl,
		componentStyle,
		form,
		journey,
		metadata,
		step,
		alertNeedsFocus,
		formMessageKey,
		formAriaDescriptor,
		formNeedsFocus,
		linkWrapper,
		$styleStore,
		determineSubmission,
		submitFormWrapper,
		header_binding,
		form_1_formEl_binding
	];
}

class Generic extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			componentStyle: 1,
			form: 2,
			formEl: 0,
			journey: 3,
			metadata: 4,
			step: 5
		});
	}
}

/* src/lib/components/icons/key-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$f(ctx) {
	let svg;
	let path0;
	let path1;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M12.65 10C11.83 7.67 9.61 6 7 6c-3.31 0-6 2.69-6 6s2.69 6 6 6c2.61 0 4.83-1.67 5.65-4H17v4h4v-4h2v-4H12.65zM7 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class Key_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/stages/one-time-password.svelte generated by Svelte v3.55.1 */

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	child_ctx[15] = i;
	return child_ctx;
}

// (57:2) {#if componentStyle !== 'inline'}
function create_if_block_3$5(ctx) {
	let t0;
	let h1;
	let t1;
	let t2;
	let p;
	let t3;
	let current;
	let if_block = /*form*/ ctx[2]?.icon && create_if_block_4$3();

	t1 = new Locale_strings({
			props: { key: "twoFactorAuthentication" }
		});

	t3 = new Locale_strings({
			props: { key: "useTheAuthenticatorAppOnYourPhone" }
		});

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			h1 = element("h1");
			create_component(t1.$$.fragment);
			t2 = space();
			p = element("p");
			create_component(t3.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
			attr(p, "class", "tw_text-center tw_text-sm tw_-mt-5 tw_mb-2 tw_py-4 tw_text-secondary-dark dark:tw_text-secondary-light");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, h1, anchor);
			mount_component(t1, h1, null);
			insert(target, t2, anchor);
			insert(target, p, anchor);
			mount_component(t3, p, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*form*/ ctx[2]?.icon) {
				if (if_block) {
					if (dirty & /*form*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4$3();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(t1.$$.fragment, local);
			transition_in(t3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(t1.$$.fragment, local);
			transition_out(t3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(h1);
			destroy_component(t1);
			if (detaching) detach(t2);
			if (detaching) detach(p);
			destroy_component(t3);
		}
	};
}

// (58:4) {#if form?.icon}
function create_if_block_4$3(ctx) {
	let div;
	let keyicon;
	let current;

	keyicon = new Key_icon({
			props: {
				classes: "tw_text-gray-400 tw_fill-current",
				size: "72px"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(keyicon.$$.fragment);
			attr(div, "class", "tw_flex tw_justify-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(keyicon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(keyicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(keyicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(keyicon);
		}
	};
}

// (73:2) {#if form?.message}
function create_if_block_2$5(ctx) {
	let alert;
	let current;

	alert = new Alert({
			props: {
				id: "formFailureMessageAlert",
				needsFocus: /*alertNeedsFocus*/ ctx[5],
				type: "error",
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*alertNeedsFocus*/ 32) alert_changes.needsFocus = /*alertNeedsFocus*/ ctx[5];

			if (dirty & /*$$scope, formMessageKey, form*/ 65668) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
		}
	};
}

// (74:4) <Alert id="formFailureMessageAlert" needsFocus={alertNeedsFocus} type="error">
function create_default_slot_3$1(ctx) {
	let t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*formMessageKey, form*/ 132 && t_value !== (t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (79:2) {#each modifiedCallbacks as callback, idx}
function create_each_block$5(ctx) {
	let callbackmapper;
	let current;

	callbackmapper = new Callback_mapper({
			props: {
				props: {
					callback: /*callback*/ ctx[13],
					callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[15]],
					selfSubmitFunction: /*determineSubmission*/ ctx[10],
					stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
					style: /*$style*/ ctx[9]
				}
			}
		});

	return {
		c() {
			create_component(callbackmapper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callbackmapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callbackmapper_changes = {};

			if (dirty & /*modifiedCallbacks, metadata, $style*/ 784) callbackmapper_changes.props = {
				callback: /*callback*/ ctx[13],
				callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[15]],
				selfSubmitFunction: /*determineSubmission*/ ctx[10],
				stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
				style: /*$style*/ ctx[9]
			};

			callbackmapper.$set(callbackmapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callbackmapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callbackmapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callbackmapper, detaching);
		}
	};
}

// (95:108) 
function create_if_block_1$6(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				busy: /*journey*/ ctx[3]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*journey*/ 8) button_changes.busy = /*journey*/ ctx[3]?.loading;

			if (dirty & /*$$scope*/ 65536) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (91:2) {#if buttons?.length}
function create_if_block$8(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				busy: /*journey*/ ctx[3]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*journey*/ 8) button_changes.busy = /*journey*/ ctx[3]?.loading;

			if (dirty & /*$$scope, buttons*/ 65600) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (96:4) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_2$4(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "loginButton" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (92:4) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_1$7(ctx) {
	let t;
	let current;

	t = new Locale_strings({
			props: { key: /*buttons*/ ctx[6][0].text }
		});

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const t_changes = {};
			if (dirty & /*buttons*/ 64) t_changes.key = /*buttons*/ ctx[6][0].text;
			t.$set(t_changes);
		},
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (56:0) <Form bind:formEl ariaDescribedBy="formFailureMessageAlert" onSubmitWhenValid={form?.submit}>
function create_default_slot$8(ctx) {
	let t0;
	let t1;
	let t2;
	let show_if;
	let current_block_type_index;
	let if_block2;
	let if_block2_anchor;
	let current;
	let if_block0 = /*componentStyle*/ ctx[1] !== 'inline' && create_if_block_3$5(ctx);
	let if_block1 = /*form*/ ctx[2]?.message && create_if_block_2$5(ctx);
	let each_value = /*modifiedCallbacks*/ ctx[8];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const if_block_creators = [create_if_block$8, create_if_block_1$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*metadata*/ 16) show_if = null;
		if (/*buttons*/ ctx[6]?.length) return 0;
		if (show_if == null) show_if = !!(/*metadata*/ ctx[4]?.step?.derived.isUserInputOptional || !/*metadata*/ ctx[4]?.step?.derived.isStepSelfSubmittable());
		if (show_if) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t2, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*componentStyle*/ ctx[1] !== 'inline') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*componentStyle*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*form*/ ctx[2]?.message) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*form*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*modifiedCallbacks, metadata, determineSubmission, $style*/ 1808) {
				each_value = /*modifiedCallbacks*/ ctx[8];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t2.parentNode, t2);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block2) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block2 = if_blocks[current_block_type_index];

					if (!if_block2) {
						if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block2.c();
					} else {
						if_block2.p(ctx, dirty);
					}

					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				} else {
					if_block2 = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t2);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block2_anchor);
		}
	};
}

function create_fragment$e(ctx) {
	let form_1;
	let updating_formEl;
	let current;

	function form_1_formEl_binding(value) {
		/*form_1_formEl_binding*/ ctx[12](value);
	}

	let form_1_props = {
		ariaDescribedBy: "formFailureMessageAlert",
		onSubmitWhenValid: /*form*/ ctx[2]?.submit,
		$$slots: { default: [create_default_slot$8] },
		$$scope: { ctx }
	};

	if (/*formEl*/ ctx[0] !== void 0) {
		form_1_props.formEl = /*formEl*/ ctx[0];
	}

	form_1 = new Form({ props: form_1_props });
	binding_callbacks.push(() => bind(form_1, 'formEl', form_1_formEl_binding));

	return {
		c() {
			create_component(form_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const form_1_changes = {};
			if (dirty & /*form*/ 4) form_1_changes.onSubmitWhenValid = /*form*/ ctx[2]?.submit;

			if (dirty & /*$$scope, journey, buttons, metadata, modifiedCallbacks, $style, alertNeedsFocus, formMessageKey, form, componentStyle*/ 66558) {
				form_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_formEl && dirty & /*formEl*/ 1) {
				updating_formEl = true;
				form_1_changes.formEl = /*formEl*/ ctx[0];
				add_flush_callback(() => updating_formEl = false);
			}

			form_1.$set(form_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form_1, detaching);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let $style;
	component_subscribe($$self, styleStore, $$value => $$invalidate(9, $style = $$value));
	let { componentStyle } = $$props;
	let { form } = $$props;
	let { formEl = null } = $$props;
	let { journey } = $$props;
	let { metadata } = $$props;
	let { step } = $$props;
	let alertNeedsFocus = false;
	let buttons;
	let formMessageKey = '';
	let modifiedCallbacks = [];

	function determineSubmission() {
		// TODO: the below is more strict; all self-submitting cbs have to complete before submitting
		// if (stepMetadata.isStepSelfSubmittable && isStepReadyToSubmit(callbackMetadataArray)) {
		// The below variation is more liberal first self-submittable cb to call this wins.
		if (metadata?.step?.derived.isStepSelfSubmittable()) {
			form?.submit();
		}
	}

	afterUpdate(() => {
		$$invalidate(5, alertNeedsFocus = !!form?.message);
	});

	function form_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(0, formEl);
	}

	$$self.$$set = $$props => {
		if ('componentStyle' in $$props) $$invalidate(1, componentStyle = $$props.componentStyle);
		if ('form' in $$props) $$invalidate(2, form = $$props.form);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('journey' in $$props) $$invalidate(3, journey = $$props.journey);
		if ('metadata' in $$props) $$invalidate(4, metadata = $$props.metadata);
		if ('step' in $$props) $$invalidate(11, step = $$props.step);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*form, step*/ 2052) {
			{
				$$invalidate(7, formMessageKey = convertStringToKey(form?.message));
				const confirmationCallbacks = step.getCallbacksOfType(l.ConfirmationCallback);

				if (confirmationCallbacks.length) {
					const confirmationCb = confirmationCallbacks[0];
					$$invalidate(6, buttons = confirmationCb.getOptions().map((option, index) => ({ value: `${index}`, text: option })));
				}

				/**
 * Filter out ConfirmationCallbacks; we'll use them seperately
 */
				$$invalidate(8, modifiedCallbacks = step.callbacks.filter(callback => {
					if (callback.getType() === l.ConfirmationCallback) {
						return false;
					}

					return true;
				}));
			}
		}
	};

	return [
		formEl,
		componentStyle,
		form,
		journey,
		metadata,
		alertNeedsFocus,
		buttons,
		formMessageKey,
		modifiedCallbacks,
		$style,
		determineSubmission,
		step,
		form_1_formEl_binding
	];
}

class One_time_password extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			componentStyle: 1,
			form: 2,
			formEl: 0,
			journey: 3,
			metadata: 4,
			step: 11
		});
	}
}

/* src/lib/components/icons/new-user-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$d(ctx) {
	let svg;
	let path0;
	let path1;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path0, "d", "M0 0h24v24H0z");
			attr(path0, "fill", "none");
			attr(path1, "d", "M15 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm-9-2V7H4v3H1v2h3v3h2v-3h3v-2H6zm9 4c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "width", /*size*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class New_user_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/stages/registration.svelte generated by Svelte v3.55.1 */

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	child_ctx[15] = i;
	return child_ctx;
}

// (45:2) {#if componentStyle !== 'inline'}
function create_if_block_2$4(ctx) {
	let t0;
	let h1;
	let t1;
	let t2;
	let p;
	let t3;
	let current;
	let if_block = /*form*/ ctx[2]?.icon && create_if_block_3$4();
	t1 = new Locale_strings({ props: { key: "registerHeader" } });

	t3 = new Locale_strings({
			props: { key: "alreadyHaveAnAccount", html: true }
		});

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			h1 = element("h1");
			create_component(t1.$$.fragment);
			t2 = space();
			p = element("p");
			create_component(t3.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
			attr(p, "class", "tw_text-base tw_text-center tw_-mt-5 tw_mb-2 tw_py-4 tw_text-secondary-dark dark:tw_text-secondary-light");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, h1, anchor);
			mount_component(t1, h1, null);
			insert(target, t2, anchor);
			insert(target, p, anchor);
			mount_component(t3, p, null);
			/*p_binding*/ ctx[11](p);
			current = true;
		},
		p(ctx, dirty) {
			if (/*form*/ ctx[2]?.icon) {
				if (if_block) {
					if (dirty & /*form*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$4();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(t1.$$.fragment, local);
			transition_in(t3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(t1.$$.fragment, local);
			transition_out(t3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(h1);
			destroy_component(t1);
			if (detaching) detach(t2);
			if (detaching) detach(p);
			destroy_component(t3);
			/*p_binding*/ ctx[11](null);
		}
	};
}

// (46:4) {#if form?.icon}
function create_if_block_3$4(ctx) {
	let div;
	let newusericon;
	let current;

	newusericon = new New_user_icon({
			props: {
				classes: "tw_text-gray-400 tw_fill-current",
				size: "72px"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(newusericon.$$.fragment);
			attr(div, "class", "tw_flex tw_justify-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(newusericon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(newusericon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(newusericon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(newusericon);
		}
	};
}

// (62:2) {#if form.message}
function create_if_block_1$5(ctx) {
	let alert;
	let current;

	alert = new Alert({
			props: {
				id: "formFailureMessageAlert",
				needsFocus: /*alertNeedsFocus*/ ctx[6],
				type: "error",
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*alertNeedsFocus*/ 64) alert_changes.needsFocus = /*alertNeedsFocus*/ ctx[6];

			if (dirty & /*$$scope, formMessageKey, form*/ 65668) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
		}
	};
}

// (63:4) <Alert id="formFailureMessageAlert" needsFocus={alertNeedsFocus} type="error">
function create_default_slot_2$3(ctx) {
	let t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*formMessageKey, form*/ 132 && t_value !== (t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (68:2) {#each step?.callbacks as callback, idx}
function create_each_block$4(ctx) {
	let callbackmapper;
	let current;

	callbackmapper = new Callback_mapper({
			props: {
				props: {
					callback: /*callback*/ ctx[13],
					callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[15]],
					selfSubmitFunction: /*determineSubmission*/ ctx[10],
					stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
					style: /*$styleStore*/ ctx[9]
				}
			}
		});

	return {
		c() {
			create_component(callbackmapper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callbackmapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callbackmapper_changes = {};

			if (dirty & /*step, metadata, $styleStore*/ 560) callbackmapper_changes.props = {
				callback: /*callback*/ ctx[13],
				callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[15]],
				selfSubmitFunction: /*determineSubmission*/ ctx[10],
				stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
				style: /*$styleStore*/ ctx[9]
			};

			callbackmapper.$set(callbackmapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callbackmapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callbackmapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callbackmapper, detaching);
		}
	};
}

// (80:2) {#if metadata?.step?.derived.isUserInputOptional || !metadata?.step?.derived.isStepSelfSubmittable()}
function create_if_block$7(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				busy: /*journey*/ ctx[3]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*journey*/ 8) button_changes.busy = /*journey*/ ctx[3]?.loading;

			if (dirty & /*$$scope*/ 65536) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (81:4) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_1$6(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "registerButton" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (44:0) <Form bind:formEl ariaDescribedBy="formFailureMessageAlert" onSubmitWhenValid={form?.submit}>
function create_default_slot$7(ctx) {
	let t0;
	let t1;
	let t2;
	let show_if = /*metadata*/ ctx[4]?.step?.derived.isUserInputOptional || !/*metadata*/ ctx[4]?.step?.derived.isStepSelfSubmittable();
	let if_block2_anchor;
	let current;
	let if_block0 = /*componentStyle*/ ctx[1] !== 'inline' && create_if_block_2$4(ctx);
	let if_block1 = /*form*/ ctx[2].message && create_if_block_1$5(ctx);
	let each_value = /*step*/ ctx[5]?.callbacks;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block2 = show_if && create_if_block$7(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t2, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*componentStyle*/ ctx[1] !== 'inline') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*componentStyle*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*form*/ ctx[2].message) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*form*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*step, metadata, determineSubmission, $styleStore*/ 1584) {
				each_value = /*step*/ ctx[5]?.callbacks;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t2.parentNode, t2);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty & /*metadata*/ 16) show_if = /*metadata*/ ctx[4]?.step?.derived.isUserInputOptional || !/*metadata*/ ctx[4]?.step?.derived.isStepSelfSubmittable();

			if (show_if) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*metadata*/ 16) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$7(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t2);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

function create_fragment$c(ctx) {
	let form_1;
	let updating_formEl;
	let current;

	function form_1_formEl_binding(value) {
		/*form_1_formEl_binding*/ ctx[12](value);
	}

	let form_1_props = {
		ariaDescribedBy: "formFailureMessageAlert",
		onSubmitWhenValid: /*form*/ ctx[2]?.submit,
		$$slots: { default: [create_default_slot$7] },
		$$scope: { ctx }
	};

	if (/*formEl*/ ctx[0] !== void 0) {
		form_1_props.formEl = /*formEl*/ ctx[0];
	}

	form_1 = new Form({ props: form_1_props });
	binding_callbacks.push(() => bind(form_1, 'formEl', form_1_formEl_binding));

	return {
		c() {
			create_component(form_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const form_1_changes = {};
			if (dirty & /*form*/ 4) form_1_changes.onSubmitWhenValid = /*form*/ ctx[2]?.submit;

			if (dirty & /*$$scope, journey, metadata, step, $styleStore, alertNeedsFocus, formMessageKey, form, linkWrapper, componentStyle*/ 66558) {
				form_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_formEl && dirty & /*formEl*/ 1) {
				updating_formEl = true;
				form_1_changes.formEl = /*formEl*/ ctx[0];
				add_flush_callback(() => updating_formEl = false);
			}

			form_1.$set(form_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form_1, detaching);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let $styleStore;
	component_subscribe($$self, styleStore, $$value => $$invalidate(9, $styleStore = $$value));
	let { componentStyle } = $$props;
	let { form } = $$props;
	let { formEl = null } = $$props;
	let { journey } = $$props;
	let { metadata } = $$props;
	let { step } = $$props;
	let alertNeedsFocus = false;
	let formMessageKey = '';
	let linkWrapper;

	function determineSubmission() {
		// TODO: the below is more strict; all self-submitting cbs have to complete before submitting
		// if (stepMetadata.isStepSelfSubmittable && isStepReadyToSubmit(callbackMetadataArray)) {
		// The below variation is more liberal first self-submittable cb to call this wins.
		if (metadata?.step?.derived.isStepSelfSubmittable()) {
			form?.submit();
		}
	}

	afterUpdate(() => {
		$$invalidate(6, alertNeedsFocus = !!form?.message);
	});

	onMount(() => {
		if (componentStyle === 'modal') {
			captureLinks(linkWrapper, journey);
		}
	});

	function p_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			linkWrapper = $$value;
			$$invalidate(8, linkWrapper);
		});
	}

	function form_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(0, formEl);
	}

	$$self.$$set = $$props => {
		if ('componentStyle' in $$props) $$invalidate(1, componentStyle = $$props.componentStyle);
		if ('form' in $$props) $$invalidate(2, form = $$props.form);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('journey' in $$props) $$invalidate(3, journey = $$props.journey);
		if ('metadata' in $$props) $$invalidate(4, metadata = $$props.metadata);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*form*/ 4) {
			{
				$$invalidate(7, formMessageKey = convertStringToKey(form?.message));
			}
		}
	};

	return [
		formEl,
		componentStyle,
		form,
		journey,
		metadata,
		step,
		alertNeedsFocus,
		formMessageKey,
		linkWrapper,
		$styleStore,
		determineSubmission,
		p_binding,
		form_1_formEl_binding
	];
}

class Registration extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			componentStyle: 1,
			form: 2,
			formEl: 0,
			journey: 3,
			metadata: 4,
			step: 5
		});
	}
}

/* src/lib/journey/stages/login.svelte generated by Svelte v3.55.1 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[17] = i;
	return child_ctx;
}

// (45:2) {#if componentStyle !== 'inline'}
function create_if_block_3$3(ctx) {
	let t0;
	let h1;
	let t1;
	let current;
	let if_block = /*form*/ ctx[2]?.icon && create_if_block_4$2();
	t1 = new Locale_strings({ props: { key: "loginHeader" } });

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			h1 = element("h1");
			create_component(t1.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, h1, anchor);
			mount_component(t1, h1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*form*/ ctx[2]?.icon) {
				if (if_block) {
					if (dirty & /*form*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4$2();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(t1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(t1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(h1);
			destroy_component(t1);
		}
	};
}

// (46:4) {#if form?.icon}
function create_if_block_4$2(ctx) {
	let div;
	let keyicon;
	let current;

	keyicon = new Key_icon({
			props: {
				classes: "tw_text-gray-400 tw_fill-current",
				size: "72px"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(keyicon.$$.fragment);
			attr(div, "class", "tw_flex tw_justify-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(keyicon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(keyicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(keyicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(keyicon);
		}
	};
}

// (56:2) {#if form?.message}
function create_if_block_2$3(ctx) {
	let alert;
	let current;

	alert = new Alert({
			props: {
				id: "formFailureMessageAlert",
				needsFocus: /*alertNeedsFocus*/ ctx[6],
				type: "error",
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*alertNeedsFocus*/ 64) alert_changes.needsFocus = /*alertNeedsFocus*/ ctx[6];

			if (dirty & /*$$scope, formMessageKey, form*/ 262276) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
		}
	};
}

// (57:4) <Alert id="formFailureMessageAlert" needsFocus={alertNeedsFocus} type="error">
function create_default_slot_2$2(ctx) {
	let t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*formMessageKey, form*/ 132 && t_value !== (t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (62:2) {#each step?.callbacks as callback, idx}
function create_each_block$3(ctx) {
	let callbackmapper;
	let current;

	callbackmapper = new Callback_mapper({
			props: {
				props: {
					callback: /*callback*/ ctx[15],
					callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[17]],
					selfSubmitFunction: /*determineSubmission*/ ctx[10],
					stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
					style: /*$styleStore*/ ctx[9]
				}
			}
		});

	return {
		c() {
			create_component(callbackmapper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callbackmapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callbackmapper_changes = {};

			if (dirty & /*step, metadata, $styleStore*/ 560) callbackmapper_changes.props = {
				callback: /*callback*/ ctx[15],
				callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[17]],
				selfSubmitFunction: /*determineSubmission*/ ctx[10],
				stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
				style: /*$styleStore*/ ctx[9]
			};

			callbackmapper.$set(callbackmapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callbackmapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callbackmapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callbackmapper, detaching);
		}
	};
}

// (74:2) {#if metadata?.step?.derived.isUserInputOptional || !metadata?.step?.derived.isStepSelfSubmittable()}
function create_if_block_1$4(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				busy: /*journey*/ ctx[3]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*journey*/ 8) button_changes.busy = /*journey*/ ctx[3]?.loading;

			if (dirty & /*$$scope*/ 262144) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (75:4) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_1$5(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "loginButton" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (80:2) {#if componentStyle !== 'inline'}
function create_if_block$6(ctx) {
	let p0;
	let button0;
	let t1;
	let button1;
	let t3;
	let hr;
	let t4;
	let p1;
	let t5;
	let current;
	let mounted;
	let dispose;

	t5 = new Locale_strings({
			props: { key: "dontHaveAnAccount", html: true }
		});

	return {
		c() {
			p0 = element("p");
			button0 = element("button");
			button0.textContent = `${interpolate('forgotPassword', null, 'Forgot Password?')}`;
			t1 = text("\n       \n      ");
			button1 = element("button");
			button1.textContent = `${interpolate('forgotUsername', null, 'Forgot Username?')}`;
			t3 = space();
			hr = element("hr");
			t4 = space();
			p1 = element("p");
			create_component(t5.$$.fragment);
			attr(p0, "class", "tw_my-4 tw_text-base tw_text-center tw_text-link-dark dark:tw_text-link-light");
			attr(hr, "class", "tw_border-0 tw_border-b tw_border-secondary-light dark:tw_border-secondary-dark");
			attr(p1, "class", "tw_text-base tw_text-center tw_py-4 tw_text-secondary-dark dark:tw_text-secondary-light");
		},
		m(target, anchor) {
			insert(target, p0, anchor);
			append(p0, button0);
			append(p0, t1);
			append(p0, button1);
			insert(target, t3, anchor);
			insert(target, hr, anchor);
			insert(target, t4, anchor);
			insert(target, p1, anchor);
			mount_component(t5, p1, null);
			/*p1_binding*/ ctx[13](p1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", prevent_default(/*click_handler*/ ctx[11])),
					listen(button1, "click", prevent_default(/*click_handler_1*/ ctx[12]))
				];

				mounted = true;
			}
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t5.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t5.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p0);
			if (detaching) detach(t3);
			if (detaching) detach(hr);
			if (detaching) detach(t4);
			if (detaching) detach(p1);
			destroy_component(t5);
			/*p1_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (44:0) <Form bind:formEl ariaDescribedBy="formFailureMessageAlert" onSubmitWhenValid={form?.submit}>
function create_default_slot$6(ctx) {
	let t0;
	let t1;
	let t2;
	let show_if = /*metadata*/ ctx[4]?.step?.derived.isUserInputOptional || !/*metadata*/ ctx[4]?.step?.derived.isStepSelfSubmittable();
	let t3;
	let if_block3_anchor;
	let current;
	let if_block0 = /*componentStyle*/ ctx[1] !== 'inline' && create_if_block_3$3(ctx);
	let if_block1 = /*form*/ ctx[2]?.message && create_if_block_2$3(ctx);
	let each_value = /*step*/ ctx[5]?.callbacks;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block2 = show_if && create_if_block_1$4(ctx);
	let if_block3 = /*componentStyle*/ ctx[1] !== 'inline' && create_if_block$6(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			if_block3_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t2, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, if_block3_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*componentStyle*/ ctx[1] !== 'inline') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*componentStyle*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*form*/ ctx[2]?.message) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*form*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*step, metadata, determineSubmission, $styleStore*/ 1584) {
				each_value = /*step*/ ctx[5]?.callbacks;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t2.parentNode, t2);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty & /*metadata*/ 16) show_if = /*metadata*/ ctx[4]?.step?.derived.isUserInputOptional || !/*metadata*/ ctx[4]?.step?.derived.isStepSelfSubmittable();

			if (show_if) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*metadata*/ 16) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$4(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t3.parentNode, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*componentStyle*/ ctx[1] !== 'inline') {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*componentStyle*/ 2) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$6(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t2);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t3);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(if_block3_anchor);
		}
	};
}

function create_fragment$b(ctx) {
	let form_1;
	let updating_formEl;
	let current;

	function form_1_formEl_binding(value) {
		/*form_1_formEl_binding*/ ctx[14](value);
	}

	let form_1_props = {
		ariaDescribedBy: "formFailureMessageAlert",
		onSubmitWhenValid: /*form*/ ctx[2]?.submit,
		$$slots: { default: [create_default_slot$6] },
		$$scope: { ctx }
	};

	if (/*formEl*/ ctx[0] !== void 0) {
		form_1_props.formEl = /*formEl*/ ctx[0];
	}

	form_1 = new Form({ props: form_1_props });
	binding_callbacks.push(() => bind(form_1, 'formEl', form_1_formEl_binding));

	return {
		c() {
			create_component(form_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const form_1_changes = {};
			if (dirty & /*form*/ 4) form_1_changes.onSubmitWhenValid = /*form*/ ctx[2]?.submit;

			if (dirty & /*$$scope, linkWrapper, journey, componentStyle, metadata, step, $styleStore, alertNeedsFocus, formMessageKey, form*/ 263166) {
				form_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_formEl && dirty & /*formEl*/ 1) {
				updating_formEl = true;
				form_1_changes.formEl = /*formEl*/ ctx[0];
				add_flush_callback(() => updating_formEl = false);
			}

			form_1.$set(form_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form_1, detaching);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let $styleStore;
	component_subscribe($$self, styleStore, $$value => $$invalidate(9, $styleStore = $$value));
	let { componentStyle } = $$props;
	let { form } = $$props;
	let { formEl = null } = $$props;
	let { journey } = $$props;
	let { metadata } = $$props;
	let { step } = $$props;
	let alertNeedsFocus = false;
	let formMessageKey = '';
	let linkWrapper;

	function determineSubmission() {
		// TODO: the below is more strict; all self-submitting cbs have to complete before submitting
		// if (stepMetadata.isStepSelfSubmittable && isStepReadyToSubmit(callbackMetadataArray)) {
		// The below variation is more liberal first self-submittable cb to call this wins.
		if (metadata?.step?.derived.isStepSelfSubmittable()) {
			form?.submit();
		}
	}

	afterUpdate(() => {
		$$invalidate(6, alertNeedsFocus = !!form?.message);
	});

	onMount(() => {
		if (componentStyle === 'modal') {
			captureLinks(linkWrapper, journey);
		}
	});

	const click_handler = () => {
		journey.push({ tree: 'ResetPassword' });
	};

	const click_handler_1 = () => {
		journey.push({ tree: 'ForgottenUsername' });
	};

	function p1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			linkWrapper = $$value;
			$$invalidate(8, linkWrapper);
		});
	}

	function form_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(0, formEl);
	}

	$$self.$$set = $$props => {
		if ('componentStyle' in $$props) $$invalidate(1, componentStyle = $$props.componentStyle);
		if ('form' in $$props) $$invalidate(2, form = $$props.form);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('journey' in $$props) $$invalidate(3, journey = $$props.journey);
		if ('metadata' in $$props) $$invalidate(4, metadata = $$props.metadata);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*form*/ 4) {
			{
				$$invalidate(7, formMessageKey = convertStringToKey(form?.message));
			}
		}
	};

	return [
		formEl,
		componentStyle,
		form,
		journey,
		metadata,
		step,
		alertNeedsFocus,
		formMessageKey,
		linkWrapper,
		$styleStore,
		determineSubmission,
		click_handler,
		click_handler_1,
		p1_binding,
		form_1_formEl_binding
	];
}

class Login extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			componentStyle: 1,
			form: 2,
			formEl: 0,
			journey: 3,
			metadata: 4,
			step: 5
		});
	}
}

/* src/lib/components/icons/fingerprint-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$a(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			attr(path0, "d", "M8.06 6.5a.5.5 0 0 1 .5.5v.776a11.5 11.5 0 0 1-.552 3.519l-1.331 4.14a.5.5 0 0 1-.952-.305l1.33-4.141a10.5 10.5 0 0 0 .504-3.213V7a.5.5 0 0 1 .5-.5Z");
			attr(path1, "d", "M6.06 7a2 2 0 1 1 4 0 .5.5 0 1 1-1 0 1 1 0 1 0-2 0v.332c0 .409-.022.816-.066 1.221A.5.5 0 0 1 6 8.447c.04-.37.06-.742.06-1.115V7Zm3.509 1a.5.5 0 0 1 .487.513 11.5 11.5 0 0 1-.587 3.339l-1.266 3.8a.5.5 0 0 1-.949-.317l1.267-3.8a10.5 10.5 0 0 0 .535-3.048A.5.5 0 0 1 9.569 8Zm-3.356 2.115a.5.5 0 0 1 .33.626L5.24 14.939a.5.5 0 1 1-.955-.296l1.303-4.199a.5.5 0 0 1 .625-.329Z");
			attr(path2, "d", "M4.759 5.833A3.501 3.501 0 0 1 11.559 7a.5.5 0 0 1-1 0 2.5 2.5 0 0 0-4.857-.833.5.5 0 1 1-.943-.334Zm.3 1.67a.5.5 0 0 1 .449.546 10.72 10.72 0 0 1-.4 2.031l-1.222 4.072a.5.5 0 1 1-.958-.287L4.15 9.793a9.72 9.72 0 0 0 .363-1.842.5.5 0 0 1 .546-.449Zm6 .647a.5.5 0 0 1 .5.5c0 1.28-.213 2.552-.632 3.762l-1.09 3.145a.5.5 0 0 1-.944-.327l1.089-3.145c.382-1.105.578-2.266.578-3.435a.5.5 0 0 1 .5-.5Z");
			attr(path3, "d", "M3.902 4.222a4.996 4.996 0 0 1 5.202-2.113.5.5 0 0 1-.208.979 3.996 3.996 0 0 0-4.163 1.69.5.5 0 0 1-.831-.556Zm6.72-.955a.5.5 0 0 1 .705-.052A4.99 4.99 0 0 1 13.059 7v1.5a.5.5 0 1 1-1 0V7a3.99 3.99 0 0 0-1.386-3.028.5.5 0 0 1-.051-.705ZM3.68 5.842a.5.5 0 0 1 .422.568c-.029.192-.044.39-.044.59 0 .71-.1 1.417-.298 2.1l-1.14 3.923a.5.5 0 1 1-.96-.279L2.8 8.821A6.531 6.531 0 0 0 3.058 7c0-.25.019-.496.054-.736a.5.5 0 0 1 .568-.422Zm8.882 3.66a.5.5 0 0 1 .456.54c-.084 1-.298 1.986-.64 2.934l-.744 2.068a.5.5 0 0 1-.941-.338l.745-2.07a10.51 10.51 0 0 0 .584-2.678.5.5 0 0 1 .54-.456Z");
			attr(path4, "d", "M4.81 1.37A6.5 6.5 0 0 1 14.56 7a.5.5 0 1 1-1 0 5.5 5.5 0 0 0-8.25-4.765.5.5 0 0 1-.5-.865Zm-.89 1.257a.5.5 0 0 1 .04.706A5.478 5.478 0 0 0 2.56 7a.5.5 0 0 1-1 0c0-1.664.626-3.184 1.655-4.333a.5.5 0 0 1 .706-.04ZM1.915 8.02a.5.5 0 0 1 .346.616l-.779 2.767a.5.5 0 1 1-.962-.27l.778-2.767a.5.5 0 0 1 .617-.346Zm12.15.481a.5.5 0 0 1 .49.51c-.03 1.499-.161 3.025-.727 4.533l-.07.187a.5.5 0 0 1-.936-.351l.07-.187c.506-1.35.634-2.74.663-4.202a.5.5 0 0 1 .51-.49Z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 16 16");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
		},
		p(ctx, [dirty]) {
			if (dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
	};

	return [classes, size];
}

class Fingerprint_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/stages/webauthn.svelte generated by Svelte v3.55.1 */

function create_if_block_4$1(ctx) {
	let div;
	let fingerprinticon;
	let current;

	fingerprinticon = new Fingerprint_icon({
			props: {
				classes: "tw_text-gray-400 tw_fill-current",
				size: "72px"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(fingerprinticon.$$.fragment);
			attr(div, "class", "tw_flex tw_justify-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(fingerprinticon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(fingerprinticon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fingerprinticon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(fingerprinticon);
		}
	};
}

// (101:2) {#if waitingForWebAuthnAPI}
function create_if_block_3$2(ctx) {
	let div;
	let spinner;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-28 tw_w-28"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(spinner.$$.fragment);
			attr(div, "class", "tw_text-center tw_w-full tw_py-4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(spinner, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(spinner);
		}
	};
}

// (106:2) {#if form?.message}
function create_if_block_2$2(ctx) {
	let alert;
	let current;

	alert = new Alert({
			props: {
				id: formFailureMessageId$2,
				needsFocus: /*alertNeedsFocus*/ ctx[4],
				type: "error",
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*alertNeedsFocus*/ 16) alert_changes.needsFocus = /*alertNeedsFocus*/ ctx[4];

			if (dirty & /*$$scope, formMessageKey, form*/ 262212) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
		}
	};
}

// (107:4) <Alert id={formFailureMessageId} needsFocus={alertNeedsFocus} type="error">
function create_default_slot_2$1(ctx) {
	let t_value = interpolate(/*formMessageKey*/ ctx[6], null, /*form*/ ctx[2]?.message) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*formMessageKey, form*/ 68 && t_value !== (t_value = interpolate(/*formMessageKey*/ ctx[6], null, /*form*/ ctx[2]?.message) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (126:2) {:else}
function create_else_block$2(ctx) {
	let header;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_1$3, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*requestsDeviceName*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			header = element("header");
			if_block.c();
			attr(header, "class", `tw_input-spacing`);
			attr(header, "id", formHeaderId$2);
		},
		m(target, anchor) {
			insert(target, header, anchor);
			if_blocks[current_block_type_index].m(header, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(header, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(header);
			if_blocks[current_block_type_index].d();
		}
	};
}

// (112:2) {#if webAuthnType === WebAuthnStepType.Authentication}
function create_if_block$5(ctx) {
	let header;
	let div;
	let spinner;
	let t0;
	let h1;
	let t1;
	let t2;
	let p;
	let t3;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-28 tw_w-28"
			}
		});

	t1 = new Locale_strings({ props: { key: "verifyYourIdentity" } });

	t3 = new Locale_strings({
			props: { key: "useDeviceForIdentityVerification" }
		});

	return {
		c() {
			header = element("header");
			div = element("div");
			create_component(spinner.$$.fragment);
			t0 = space();
			h1 = element("h1");
			create_component(t1.$$.fragment);
			t2 = space();
			p = element("p");
			create_component(t3.$$.fragment);
			attr(div, "class", "tw_text-center tw_w-full tw_py-4");
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
			attr(p, "class", "tw_text-center tw_-mt-5 tw_mb-2 tw_py-4 tw_text-secondary-dark dark:tw_text-secondary-light");
			attr(header, "id", formHeaderId$2);
		},
		m(target, anchor) {
			insert(target, header, anchor);
			append(header, div);
			mount_component(spinner, div, null);
			append(header, t0);
			append(header, h1);
			mount_component(t1, h1, null);
			append(header, t2);
			append(header, p);
			mount_component(t3, p, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			transition_in(t1.$$.fragment, local);
			transition_in(t3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			transition_out(t1.$$.fragment, local);
			transition_out(t3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(header);
			destroy_component(spinner);
			destroy_component(t1);
			destroy_component(t3);
		}
	};
}

// (151:6) {:else}
function create_else_block_1(ctx) {
	let h1;
	let t0;
	let t1;
	let p;
	let t2;
	let current;

	t0 = new Locale_strings({
			props: {
				key: "registerYourDevice",
				values: {
					name: /*deviceName*/ ctx[5].length > 0
					? /*deviceName*/ ctx[5]
					: interpolate('yourDevice')
				}
			}
		});

	t2 = new Locale_strings({
			props: {
				key: "chooseYourDeviceForIdentityVerification"
			}
		});

	return {
		c() {
			h1 = element("h1");
			create_component(t0.$$.fragment);
			t1 = space();
			p = element("p");
			create_component(t2.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
			attr(p, "class", "tw_text-center tw_-mt-5 tw_mb-2 tw_py-4 tw_text-secondary-dark dark:tw_text-secondary-light");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			mount_component(t0, h1, null);
			insert(target, t1, anchor);
			insert(target, p, anchor);
			mount_component(t2, p, null);
			current = true;
		},
		p(ctx, dirty) {
			const t0_changes = {};

			if (dirty & /*deviceName*/ 32) t0_changes.values = {
				name: /*deviceName*/ ctx[5].length > 0
				? /*deviceName*/ ctx[5]
				: interpolate('yourDevice')
			};

			t0.$set(t0_changes);
		},
		i(local) {
			if (current) return;
			transition_in(t0.$$.fragment, local);
			transition_in(t2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t0.$$.fragment, local);
			transition_out(t2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			destroy_component(t0);
			if (detaching) detach(t1);
			if (detaching) detach(p);
			destroy_component(t2);
		}
	};
}

// (128:6) {#if requestsDeviceName}
function create_if_block_1$3(ctx) {
	let h1;
	let t0;
	let t1;
	let input;
	let t2;
	let button;
	let current;
	t0 = new Locale_strings({ props: { key: "nameYourDevice" } });

	input = new Floating_label({
			props: {
				type: "text",
				isRequired: false,
				isFirstInvalidInput: false,
				key: "devicename",
				onChange: /*updateDeviceName*/ ctx[11],
				label: interpolate('optionallyNameDevice')
			}
		});

	button = new Button({
			props: {
				style: "primary",
				type: "submit",
				width: "full",
				onClick: /*func*/ ctx[15],
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			h1 = element("h1");
			create_component(t0.$$.fragment);
			t1 = space();
			create_component(input.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			mount_component(t0, h1, null);
			insert(target, t1, anchor);
			mount_component(input, target, anchor);
			insert(target, t2, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*requestsDeviceName, waitingForWebAuthnAPI*/ 520) button_changes.onClick = /*func*/ ctx[15];

			if (dirty & /*$$scope*/ 262144) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(t0.$$.fragment, local);
			transition_in(input.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t0.$$.fragment, local);
			transition_out(input.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			destroy_component(t0);
			if (detaching) detach(t1);
			destroy_component(input, detaching);
			if (detaching) detach(t2);
			destroy_component(button, detaching);
		}
	};
}

// (140:8) <Button           style="primary"           type="submit"           width="full"           onClick={() => {             requestsDeviceName = false;             waitingForWebAuthnAPI = true;           }}         >
function create_default_slot_1$4(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "nextButton" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (89:0) <Form   bind:formEl   ariaDescribedBy={formAriaDescriptor}   id={formElementId}   needsFocus={formNeedsFocus} >
function create_default_slot$5(ctx) {
	let t0;
	let t1;
	let t2;
	let current_block_type_index;
	let if_block3;
	let if_block3_anchor;
	let current;
	let if_block0 = /*form*/ ctx[2]?.icon && /*componentStyle*/ ctx[1] !== 'inline' && create_if_block_4$1();
	let if_block1 = /*waitingForWebAuthnAPI*/ ctx[9] && create_if_block_3$2();
	let if_block2 = /*form*/ ctx[2]?.message && create_if_block_2$2(ctx);
	const if_block_creators = [create_if_block$5, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*webAuthnType*/ ctx[10] === i.Authentication) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if_block3.c();
			if_block3_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t2, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block3_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*form*/ ctx[2]?.icon && /*componentStyle*/ ctx[1] !== 'inline') {
				if (if_block0) {
					if (dirty & /*form, componentStyle*/ 6) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$1();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*waitingForWebAuthnAPI*/ ctx[9]) {
				if (if_block1) {
					if (dirty & /*waitingForWebAuthnAPI*/ 512) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$2();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*form*/ ctx[2]?.message) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*form*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2$2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t2.parentNode, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if_block3.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t2);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block3_anchor);
		}
	};
}

function create_fragment$9(ctx) {
	let form_1;
	let updating_formEl;
	let current;

	function form_1_formEl_binding(value) {
		/*form_1_formEl_binding*/ ctx[16](value);
	}

	let form_1_props = {
		ariaDescribedBy: /*formAriaDescriptor*/ ctx[7],
		id: formElementId$2,
		needsFocus: /*formNeedsFocus*/ ctx[8],
		$$slots: { default: [create_default_slot$5] },
		$$scope: { ctx }
	};

	if (/*formEl*/ ctx[0] !== void 0) {
		form_1_props.formEl = /*formEl*/ ctx[0];
	}

	form_1 = new Form({ props: form_1_props });
	binding_callbacks.push(() => bind(form_1, 'formEl', form_1_formEl_binding));

	return {
		c() {
			create_component(form_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const form_1_changes = {};
			if (dirty & /*formAriaDescriptor*/ 128) form_1_changes.ariaDescribedBy = /*formAriaDescriptor*/ ctx[7];
			if (dirty & /*formNeedsFocus*/ 256) form_1_changes.needsFocus = /*formNeedsFocus*/ ctx[8];

			if (dirty & /*$$scope, requestsDeviceName, waitingForWebAuthnAPI, deviceName, alertNeedsFocus, formMessageKey, form, componentStyle*/ 262782) {
				form_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_formEl && dirty & /*formEl*/ 1) {
				updating_formEl = true;
				form_1_changes.formEl = /*formEl*/ ctx[0];
				add_flush_callback(() => updating_formEl = false);
			}

			form_1.$set(form_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form_1, detaching);
		}
	};
}

const formFailureMessageId$2 = 'genericStepFailureMessage';
const formHeaderId$2 = 'genericStepHeader';
const formElementId$2 = 'genericStepForm';

function instance$9($$self, $$props, $$invalidate) {
	let { allowWebAuthn = true } = $$props;
	let { componentStyle } = $$props;
	let { form } = $$props;
	let { formEl = null } = $$props;
	let { step } = $$props;
	let alertNeedsFocus = false;
	let deviceName = '';
	let noDeviceRegistered = false;
	let formMessageKey = '';
	let formAriaDescriptor = 'genericStepHeader';
	let formNeedsFocus = false;
	let requestsDeviceName = true;
	let waitingForWebAuthnAPI = false;
	let webAuthnType = T.getWebAuthnStepType(step);

	function updateDeviceName(event) {
		const target = event.target;
		$$invalidate(5, deviceName = target.value);
	}

	afterUpdate(() => {
		if (form?.message) {
			$$invalidate(7, formAriaDescriptor = formFailureMessageId$2);
			$$invalidate(4, alertNeedsFocus = true);
			$$invalidate(8, formNeedsFocus = false);
		} else {
			$$invalidate(7, formAriaDescriptor = formHeaderId$2);
			$$invalidate(4, alertNeedsFocus = false);
			$$invalidate(8, formNeedsFocus = true);
		}
	});

	/**
 * Determine a WebAuthn step
 */
	async function callWebAuthnApi() {
		try {
			switch (webAuthnType) {
				case i.Registration:
					{
						try {
							await T.register(step, deviceName);
							$$invalidate(14, noDeviceRegistered = true);
						} catch(err) {
							
						} // TODO: handle error

						break;
					}
				case i.Authentication:
					{
						await T.authenticate(step);
						break;
					}
				default:
					break;
			}
		} catch(err) {
			
		} // TODO: handle error

		form.submit();
	}

	const func = () => {
		$$invalidate(3, requestsDeviceName = false);
		$$invalidate(9, waitingForWebAuthnAPI = true);
	};

	function form_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(0, formEl);
	}

	$$self.$$set = $$props => {
		if ('allowWebAuthn' in $$props) $$invalidate(12, allowWebAuthn = $$props.allowWebAuthn);
		if ('componentStyle' in $$props) $$invalidate(1, componentStyle = $$props.componentStyle);
		if ('form' in $$props) $$invalidate(2, form = $$props.form);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('step' in $$props) $$invalidate(13, step = $$props.step);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*form, allowWebAuthn, noDeviceRegistered, requestsDeviceName*/ 20492) {
			{
				$$invalidate(6, formMessageKey = convertStringToKey(form?.message));

				// Call the WebAuthn API without await
				if (allowWebAuthn && !noDeviceRegistered) {
					if (i.Registration === webAuthnType && !requestsDeviceName || i.Authentication === webAuthnType) {
						callWebAuthnApi();
					}
				}
			}
		}
	};

	return [
		formEl,
		componentStyle,
		form,
		requestsDeviceName,
		alertNeedsFocus,
		deviceName,
		formMessageKey,
		formAriaDescriptor,
		formNeedsFocus,
		waitingForWebAuthnAPI,
		webAuthnType,
		updateDeviceName,
		allowWebAuthn,
		step,
		noDeviceRegistered,
		func,
		form_1_formEl_binding
	];
}

class Webauthn extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			allowWebAuthn: 12,
			componentStyle: 1,
			form: 2,
			formEl: 0,
			step: 13
		});
	}
}

/* src/lib/components/icons/shield-check-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$8(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "fill-rule", "evenodd");
			attr(path, "d", "M8 0c-.69 0-1.843.265-2.928.56-1.11.3-2.229.655-2.887.87a1.54 1.54 0 0 0-1.044 1.262c-.596 4.477.787 7.795 2.465 9.99a11.777 11.777 0 0 0 2.517 2.453c.386.273.744.482 1.048.625.28.132.581.24.829.24s.548-.108.829-.24a7.159 7.159 0 0 0 1.048-.625 11.775 11.775 0 0 0 2.517-2.453c1.678-2.195 3.061-5.513 2.465-9.99a1.541 1.541 0 0 0-1.044-1.263 62.467 62.467 0 0 0-2.887-.87C9.843.266 8.69 0 8 0zm2.146 5.146a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7.5 7.793l2.646-2.647z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "fill", "currentColor");
			attr(svg, "viewBox", "0 0 16 18");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}

			if (dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
	};

	return [classes, size];
}

class Shield_check_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/stages/recovery-codes.svelte generated by Svelte v3.55.1 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (44:2) {#if form?.icon && componentStyle !== 'inline'}
function create_if_block$4(ctx) {
	let div;
	let clipboardicon;
	let current;

	clipboardicon = new Shield_check_icon({
			props: {
				classes: "tw_text-gray-400 tw_fill-current",
				size: "72px"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(clipboardicon.$$.fragment);
			attr(div, "class", "tw_flex tw_justify-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(clipboardicon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(clipboardicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(clipboardicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(clipboardicon);
		}
	};
}

// (74:4) {#each codes as code}
function create_each_block$2(ctx) {
	let li;
	let span;
	let t0_value = /*code*/ ctx[11] + "";
	let t0;
	let t1;

	return {
		c() {
			li = element("li");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			attr(span, "class", "tw_text-secondary-dark dark:tw_text-secondary-light");
			attr(li, "class", "tw_text-center");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, span);
			append(span, t0);
			append(li, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*codes*/ 64 && t0_value !== (t0_value = /*code*/ ctx[11] + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (86:2) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_1$3(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "nextButton" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (37:0) <Form   bind:formEl   ariaDescribedBy={formAriaDescriptor}   id={formElementId}   needsFocus={formNeedsFocus}   onSubmitWhenValid={() => form.submit()} >
function create_default_slot$4(ctx) {
	let t0;
	let header;
	let h1;
	let t1;
	let t2;
	let p0;
	let t3;
	let t4;
	let hr;
	let t5;
	let h2;
	let t6;
	let t7;
	let p1;
	let t8;
	let t9;
	let ol;
	let t10;
	let p2;
	let t11;
	let t12;
	let button;
	let current;
	let if_block = /*form*/ ctx[2]?.icon && /*componentStyle*/ ctx[1] !== 'inline' && create_if_block$4();

	t1 = new Locale_strings({
			props: { key: "yourMultiFactorAuthIsEnabled" }
		});

	t3 = new Locale_strings({
			props: {
				key: "useThisNewMfaToHelpVerifyYourIdentity"
			}
		});

	t6 = new Locale_strings({ props: { key: "dontGetLockedOut" } });

	t8 = new Locale_strings({
			props: {
				html: true,
				key: "yourRecoveryCodesToAccessAccountForLostDevice"
			}
		});

	let each_value = /*codes*/ ctx[6];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	t11 = new Locale_strings({
			props: {
				html: true,
				key: "useOneOfTheseCodes",
				values: { name: /*name*/ ctx[7] }
			}
		});

	button = new Button({
			props: {
				busy: /*journey*/ ctx[3]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			header = element("header");
			h1 = element("h1");
			create_component(t1.$$.fragment);
			t2 = space();
			p0 = element("p");
			create_component(t3.$$.fragment);
			t4 = space();
			hr = element("hr");
			t5 = space();
			h2 = element("h2");
			create_component(t6.$$.fragment);
			t7 = space();
			p1 = element("p");
			create_component(t8.$$.fragment);
			t9 = space();
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t10 = space();
			p2 = element("p");
			create_component(t11.$$.fragment);
			t12 = space();
			create_component(button.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
			attr(p0, "class", "tw_-mt-5 tw_mb-2 tw_py-4 tw_text-sm tw_text-secondary-dark dark:tw_text-secondary-light");
			attr(header, "id", formHeaderId$1);
			attr(hr, "class", "tw_border-collapse tw_border-secondary-light dark:tw_border-secondary-dark tw_mb-8");
			attr(h2, "class", "tw_secondary-header dark:tw_secondary-header_dark tw_text-lg");
			attr(p1, "class", "tw_text-sm tw_text-secondary-dark dark:tw_text-secondary-light tw_my-6");
			attr(ol, "class", "tw_font-mono tw_border tw_border-secondary-light dark:tw_border-secondary-dark tw_bg-white dark:tw_bg-body-dark tw_list-decimal tw_text-secondary-light dark:tw_text-secondary-light tw_py-4 tw_list-inside tw_rounded-md tw_mb-4 tw_columns-2");
			attr(p2, "class", "tw_text-sm tw_text-secondary-dark dark:tw_text-secondary-light tw_my-6");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, header, anchor);
			append(header, h1);
			mount_component(t1, h1, null);
			append(header, t2);
			append(header, p0);
			mount_component(t3, p0, null);
			insert(target, t4, anchor);
			insert(target, hr, anchor);
			insert(target, t5, anchor);
			insert(target, h2, anchor);
			mount_component(t6, h2, null);
			insert(target, t7, anchor);
			insert(target, p1, anchor);
			mount_component(t8, p1, null);
			insert(target, t9, anchor);
			insert(target, ol, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}

			insert(target, t10, anchor);
			insert(target, p2, anchor);
			mount_component(t11, p2, null);
			insert(target, t12, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*form*/ ctx[2]?.icon && /*componentStyle*/ ctx[1] !== 'inline') {
				if (if_block) {
					if (dirty & /*form, componentStyle*/ 6) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*codes*/ 64) {
				each_value = /*codes*/ ctx[6];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ol, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const t11_changes = {};
			if (dirty & /*name*/ 128) t11_changes.values = { name: /*name*/ ctx[7] };
			t11.$set(t11_changes);
			const button_changes = {};
			if (dirty & /*journey*/ 8) button_changes.busy = /*journey*/ ctx[3]?.loading;

			if (dirty & /*$$scope*/ 16384) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(t1.$$.fragment, local);
			transition_in(t3.$$.fragment, local);
			transition_in(t6.$$.fragment, local);
			transition_in(t8.$$.fragment, local);
			transition_in(t11.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(t1.$$.fragment, local);
			transition_out(t3.$$.fragment, local);
			transition_out(t6.$$.fragment, local);
			transition_out(t8.$$.fragment, local);
			transition_out(t11.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(header);
			destroy_component(t1);
			destroy_component(t3);
			if (detaching) detach(t4);
			if (detaching) detach(hr);
			if (detaching) detach(t5);
			if (detaching) detach(h2);
			destroy_component(t6);
			if (detaching) detach(t7);
			if (detaching) detach(p1);
			destroy_component(t8);
			if (detaching) detach(t9);
			if (detaching) detach(ol);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t10);
			if (detaching) detach(p2);
			destroy_component(t11);
			if (detaching) detach(t12);
			destroy_component(button, detaching);
		}
	};
}

function create_fragment$7(ctx) {
	let form_1;
	let updating_formEl;
	let current;

	function form_1_formEl_binding(value) {
		/*form_1_formEl_binding*/ ctx[10](value);
	}

	let form_1_props = {
		ariaDescribedBy: /*formAriaDescriptor*/ ctx[4],
		id: formElementId$1,
		needsFocus: /*formNeedsFocus*/ ctx[5],
		onSubmitWhenValid: /*func*/ ctx[9],
		$$slots: { default: [create_default_slot$4] },
		$$scope: { ctx }
	};

	if (/*formEl*/ ctx[0] !== void 0) {
		form_1_props.formEl = /*formEl*/ ctx[0];
	}

	form_1 = new Form({ props: form_1_props });
	binding_callbacks.push(() => bind(form_1, 'formEl', form_1_formEl_binding));

	return {
		c() {
			create_component(form_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const form_1_changes = {};
			if (dirty & /*formAriaDescriptor*/ 16) form_1_changes.ariaDescribedBy = /*formAriaDescriptor*/ ctx[4];
			if (dirty & /*formNeedsFocus*/ 32) form_1_changes.needsFocus = /*formNeedsFocus*/ ctx[5];
			if (dirty & /*form*/ 4) form_1_changes.onSubmitWhenValid = /*func*/ ctx[9];

			if (dirty & /*$$scope, journey, name, codes, form, componentStyle*/ 16590) {
				form_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_formEl && dirty & /*formEl*/ 1) {
				updating_formEl = true;
				form_1_changes.formEl = /*formEl*/ ctx[0];
				add_flush_callback(() => updating_formEl = false);
			}

			form_1.$set(form_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form_1, detaching);
		}
	};
}

const formFailureMessageId$1 = 'genericStepFailureMessage';
const formHeaderId$1 = 'genericStepHeader';
const formElementId$1 = 'genericStepForm';

function instance$7($$self, $$props, $$invalidate) {
	let { componentStyle } = $$props;
	let { form } = $$props;
	let { formEl = null } = $$props;
	let { journey } = $$props;
	let { step } = $$props;
	let formAriaDescriptor = 'genericStepHeader';
	let formNeedsFocus = false;
	let codes = [];
	let name = 'New Security Key';

	afterUpdate(() => {
		if (form?.message) {
			$$invalidate(4, formAriaDescriptor = formFailureMessageId$1);
			$$invalidate(5, formNeedsFocus = false);
		} else {
			$$invalidate(4, formAriaDescriptor = formHeaderId$1);
			$$invalidate(5, formNeedsFocus = true);
		}
	});

	const func = () => form.submit();

	function form_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(0, formEl);
	}

	$$self.$$set = $$props => {
		if ('componentStyle' in $$props) $$invalidate(1, componentStyle = $$props.componentStyle);
		if ('form' in $$props) $$invalidate(2, form = $$props.form);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('journey' in $$props) $$invalidate(3, journey = $$props.journey);
		if ('step' in $$props) $$invalidate(8, step = $$props.step);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*step*/ 256) {
			{
				$$invalidate(6, codes = p$1.getCodes(step));
				$$invalidate(7, name = p$1.getDeviceName(step));
			}
		}
	};

	return [
		formEl,
		componentStyle,
		form,
		journey,
		formAriaDescriptor,
		formNeedsFocus,
		codes,
		name,
		step,
		func,
		form_1_formEl_binding
	];
}

class Recovery_codes extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			componentStyle: 1,
			form: 2,
			formEl: 0,
			journey: 3,
			step: 8
		});
	}
}

/* src/lib/components/icons/clipboard-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$6(ctx) {
	let svg;
	let path;
	let title;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			title = svg_element("title");
			if (default_slot) default_slot.c();
			attr(path, "fill-rule", "evenodd");
			attr(path, "d", "M10 1.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-1Zm-5 0A1.5 1.5 0 0 1 6.5 0h3A1.5 1.5 0 0 1 11 1.5v1A1.5 1.5 0 0 1 9.5 4h-3A1.5 1.5 0 0 1 5 2.5v-1Zm-2 0h1v1A2.5 2.5 0 0 0 6.5 5h3A2.5 2.5 0 0 0 12 2.5v-1h1a2 2 0 0 1 2 2V14a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3.5a2 2 0 0 1 2-2Z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 16 16");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, title);

			if (default_slot) {
				default_slot.m(title, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [classes, size, $$scope, slots];
}

class Clipboard_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/components/icons/mobile-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$5(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M3 2a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V2zm6 11a1 1 0 1 0-2 0 1 1 0 0 0 2 0z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 16 16");
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
	};

	return [classes, size];
}

class Mobile_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/stages/qr-code.svelte generated by Svelte v3.55.1 */

function get_if_ctx(ctx) {
	const child_ctx = ctx.slice();

	const constants_0 = {
		callback: /*pollingWaitCb*/ child_ctx[10],
		callbackMetadata: /*metadata*/ child_ctx[1]?.callbacks[/*pollingWaitIdx*/ child_ctx[15]],
		options: { inline: true },
		selfSubmitFunction: /*determineSubmission*/ child_ctx[16],
		style: /*$style*/ child_ctx[14]
	};

	child_ctx[22] = constants_0;
	return child_ctx;
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

// (114:2) {#if componentStyle !== 'inline'}
function create_if_block_4(ctx) {
	let t0;
	let h1;
	let t1;
	let t2;
	let p;
	let t3;
	let current;
	let if_block = /*form*/ ctx[0]?.icon && create_if_block_5();

	t1 = new Locale_strings({
			props: { key: "twoFactorAuthentication" }
		});

	t3 = new Locale_strings({
			props: { key: "scanQrCodeWithAuthenticator" }
		});

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			h1 = element("h1");
			create_component(t1.$$.fragment);
			t2 = space();
			p = element("p");
			create_component(t3.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
			attr(p, "class", "tw_text-center tw_text-sm tw_-mt-5 tw_mb-2 tw_py-4 tw_text-secondary-dark dark:tw_text-secondary-light");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, h1, anchor);
			mount_component(t1, h1, null);
			insert(target, t2, anchor);
			insert(target, p, anchor);
			mount_component(t3, p, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*form*/ ctx[0]?.icon) {
				if (if_block) {
					if (dirty & /*form*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_5();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(t1.$$.fragment, local);
			transition_in(t3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(t1.$$.fragment, local);
			transition_out(t3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(h1);
			destroy_component(t1);
			if (detaching) detach(t2);
			if (detaching) detach(p);
			destroy_component(t3);
		}
	};
}

// (115:4) {#if form?.icon}
function create_if_block_5(ctx) {
	let div;
	let mobileicon;
	let current;

	mobileicon = new Mobile_icon({
			props: {
				classes: "tw_text-gray-400 tw_fill-current",
				size: "72px"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(mobileicon.$$.fragment);
			attr(div, "class", "tw_flex tw_justify-center tw_mb-6");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(mobileicon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(mobileicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(mobileicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(mobileicon);
		}
	};
}

// (130:2) {#if form?.message}
function create_if_block_3$1(ctx) {
	let alert;
	let current;

	alert = new Alert({
			props: {
				id: "formFailureMessageAlert",
				needsFocus: /*alertNeedsFocus*/ ctx[5],
				type: "error",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*alertNeedsFocus*/ 32) alert_changes.needsFocus = /*alertNeedsFocus*/ ctx[5];

			if (dirty & /*$$scope, formMessageKey, form*/ 67108993) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
		}
	};
}

// (131:4) <Alert id="formFailureMessageAlert" needsFocus={alertNeedsFocus} type="error">
function create_default_slot_4(ctx) {
	let t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[0]?.message) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*formMessageKey, form*/ 129 && t_value !== (t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[0]?.message) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (136:2) {#if !moduleLoaded}
function create_if_block_2$1(ctx) {
	let div;
	let spinner;
	let t0;
	let p;
	let t1;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-24 tw_my-6 tw_w-24"
			}
		});

	t1 = new Locale_strings({ props: { key: "loading" } });

	return {
		c() {
			div = element("div");
			create_component(spinner.$$.fragment);
			t0 = space();
			p = element("p");
			create_component(t1.$$.fragment);
			attr(p, "class", "tw_text-secondary-dark dark:tw_text-secondary-light");
			attr(div, "class", "tw_text-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(spinner, div, null);
			append(div, t0);
			append(div, p);
			mount_component(t1, p, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			transition_in(t1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			transition_out(t1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(spinner);
			destroy_component(t1);
		}
	};
}

// (144:2) {#each modifiedCallbacks as callback, idx}
function create_each_block$1(ctx) {
	let callbackmapper;
	let current;

	callbackmapper = new Callback_mapper({
			props: {
				props: {
					callback: /*callback*/ ctx[23],
					callbackMetadata: /*metadata*/ ctx[1]?.callbacks[/*idx*/ ctx[25]],
					selfSubmitFunction: /*determineSubmission*/ ctx[16],
					stepMetadata: /*metadata*/ ctx[1]?.step && { .../*metadata*/ ctx[1].step },
					style: /*$style*/ ctx[14]
				}
			}
		});

	return {
		c() {
			create_component(callbackmapper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callbackmapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callbackmapper_changes = {};

			if (dirty & /*modifiedCallbacks, metadata, $style*/ 16642) callbackmapper_changes.props = {
				callback: /*callback*/ ctx[23],
				callbackMetadata: /*metadata*/ ctx[1]?.callbacks[/*idx*/ ctx[25]],
				selfSubmitFunction: /*determineSubmission*/ ctx[16],
				stepMetadata: /*metadata*/ ctx[1]?.step && { .../*metadata*/ ctx[1].step },
				style: /*$style*/ ctx[14]
			};

			callbackmapper.$set(callbackmapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callbackmapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callbackmapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callbackmapper, detaching);
		}
	};
}

// (156:2) {#if pollingWaitCb}
function create_if_block_1$2(ctx) {
	let pollingwait;
	let current;
	const pollingwait_spread_levels = [/*newProps*/ ctx[22]];
	let pollingwait_props = {};

	for (let i = 0; i < pollingwait_spread_levels.length; i += 1) {
		pollingwait_props = assign(pollingwait_props, pollingwait_spread_levels[i]);
	}

	pollingwait = new Polling_wait({ props: pollingwait_props });

	return {
		c() {
			create_component(pollingwait.$$.fragment);
		},
		m(target, anchor) {
			mount_component(pollingwait, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const pollingwait_changes = (dirty & /*pollingWaitCb, metadata, pollingWaitIdx, determineSubmission, $style*/ 115714)
			? get_spread_update(pollingwait_spread_levels, [get_spread_object(/*newProps*/ ctx[22])])
			: {};

			pollingwait.$set(pollingwait_changes);
		},
		i(local) {
			if (current) return;
			transition_in(pollingwait.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(pollingwait.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(pollingwait, detaching);
		}
	};
}

// (170:6) <Link href={qrCodeUrl} classes="tw_block tw_my-6" target="_self">
function create_default_slot_3(ctx) {
	let t;
	let current;

	t = new Locale_strings({
			props: { key: "onMobileOpenInAuthenticator" }
		});

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (181:10) <ClipboardIcon classes="tw_fill-current tw_inline-block tw_align-top" size="16">
function create_default_slot_2(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "copyUrl" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (195:2) {#if buttons?.length}
function create_if_block$3(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				busy: /*journey*/ ctx[4]?.loading,
				style: "primary",
				type: "submit",
				width: "full",
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*journey*/ 16) button_changes.busy = /*journey*/ ctx[4]?.loading;

			if (dirty & /*$$scope, buttons*/ 67108928) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (196:4) <Button busy={journey?.loading} style="primary" type="submit" width="full">
function create_default_slot_1$2(ctx) {
	let t;
	let current;

	t = new Locale_strings({
			props: { key: /*buttons*/ ctx[6][0].text }
		});

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const t_changes = {};
			if (dirty & /*buttons*/ 64) t_changes.key = /*buttons*/ ctx[6][0].text;
			t.$set(t_changes);
		},
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (113:0) <Form bind:formEl ariaDescribedBy="formFailureMessageAlert" onSubmitWhenValid={form?.submit}>
function create_default_slot$3(ctx) {
	let t0;
	let t1;
	let t2;
	let canvas;
	let t3;
	let t4;
	let t5;
	let details;
	let summary;
	let t6;
	let t7;
	let div1;
	let link;
	let t8;
	let p;
	let t9;
	let t10;
	let div0;
	let label;
	let t11;
	let t12;
	let button;
	let clipboardicon;
	let t13;
	let input;
	let t14;
	let if_block4_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*componentStyle*/ ctx[3] !== 'inline' && create_if_block_4(ctx);
	let if_block1 = /*form*/ ctx[0]?.message && create_if_block_3$1(ctx);
	let if_block2 = !/*moduleLoaded*/ ctx[9] && create_if_block_2$1();
	let each_value = /*modifiedCallbacks*/ ctx[8];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block3 = /*pollingWaitCb*/ ctx[10] && create_if_block_1$2(get_if_ctx(ctx));
	t6 = new Locale_strings({ props: { key: "qrCodeNotWorking" } });

	link = new Link({
			props: {
				href: /*qrCodeUrl*/ ctx[12],
				classes: "tw_block tw_my-6",
				target: "_self",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	t9 = new Locale_strings({ props: { key: "copyAndPasteUrlBelow" } });
	t11 = new Locale_strings({ props: { key: "url" } });

	clipboardicon = new Clipboard_icon({
			props: {
				classes: "tw_fill-current tw_inline-block tw_align-top",
				size: "16",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	let if_block4 = /*buttons*/ ctx[6]?.length && create_if_block$3(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			canvas = element("canvas");
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			details = element("details");
			summary = element("summary");
			create_component(t6.$$.fragment);
			t7 = space();
			div1 = element("div");
			create_component(link.$$.fragment);
			t8 = space();
			p = element("p");
			create_component(t9.$$.fragment);
			t10 = space();
			div0 = element("div");
			label = element("label");
			create_component(t11.$$.fragment);
			t12 = space();
			button = element("button");
			create_component(clipboardicon.$$.fragment);
			t13 = space();
			input = element("input");
			t14 = space();
			if (if_block4) if_block4.c();
			if_block4_anchor = empty();
			attr(canvas, "class", "tw_m-auto tw_mb-6");
			attr(canvas, "data-testid", "qr-code-canvas");
			attr(p, "class", "tw_text-base tw_my-6");
			attr(label, "for", "mfa-registration-url");
			attr(button, "class", "tw_absolute tw_h-4 tw_bg-background-dark tw_right-1 tw_top-1 tw_shadow-[0_0_1rem_2rem_black] tw_shadow-background-light dark:tw_shadow-background-dark tw_text-secondary-dark dark:tw_text-secondary-light");
			attr(input, "class", "tw_bg-transparent tw_border-none focus-visible:tw_outline-none tw_font-mono tw_w-full");
			attr(input, "id", "mfa-registration-url");
			input.value = /*qrCodeUrl*/ ctx[12];
			attr(div0, "class", "tw_relative tw_overflow-hidden");
			attr(div1, "class", "tw_overflow-hidden");
			attr(details, "class", "tw_my-6 tw_text-secondary-dark dark:tw_text-secondary-light");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t2, anchor);
			insert(target, canvas, anchor);
			/*canvas_binding*/ ctx[19](canvas);
			insert(target, t3, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, t5, anchor);
			insert(target, details, anchor);
			append(details, summary);
			mount_component(t6, summary, null);
			append(details, t7);
			append(details, div1);
			mount_component(link, div1, null);
			append(div1, t8);
			append(div1, p);
			mount_component(t9, p, null);
			append(div1, t10);
			append(div1, div0);
			append(div0, label);
			mount_component(t11, label, null);
			append(div0, t12);
			append(div0, button);
			mount_component(clipboardicon, button, null);
			append(div0, t13);
			append(div0, input);
			/*input_binding*/ ctx[20](input);
			insert(target, t14, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert(target, if_block4_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*copyUrl*/ ctx[17]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*componentStyle*/ ctx[3] !== 'inline') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*componentStyle*/ 8) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*form*/ ctx[0]?.message) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*form*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!/*moduleLoaded*/ ctx[9]) {
				if (if_block2) {
					if (dirty & /*moduleLoaded*/ 512) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2$1();
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t2.parentNode, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty & /*modifiedCallbacks, metadata, determineSubmission, $style*/ 82178) {
				each_value = /*modifiedCallbacks*/ ctx[8];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t4.parentNode, t4);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*pollingWaitCb*/ ctx[10]) {
				if (if_block3) {
					if_block3.p(get_if_ctx(ctx), dirty);

					if (dirty & /*pollingWaitCb*/ 1024) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_1$2(get_if_ctx(ctx));
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			const link_changes = {};
			if (dirty & /*qrCodeUrl*/ 4096) link_changes.href = /*qrCodeUrl*/ ctx[12];

			if (dirty & /*$$scope*/ 67108864) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
			const clipboardicon_changes = {};

			if (dirty & /*$$scope*/ 67108864) {
				clipboardicon_changes.$$scope = { dirty, ctx };
			}

			clipboardicon.$set(clipboardicon_changes);

			if (!current || dirty & /*qrCodeUrl*/ 4096 && input.value !== /*qrCodeUrl*/ ctx[12]) {
				input.value = /*qrCodeUrl*/ ctx[12];
			}

			if (/*buttons*/ ctx[6]?.length) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty & /*buttons*/ 64) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block$3(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block3);
			transition_in(t6.$$.fragment, local);
			transition_in(link.$$.fragment, local);
			transition_in(t9.$$.fragment, local);
			transition_in(t11.$$.fragment, local);
			transition_in(clipboardicon.$$.fragment, local);
			transition_in(if_block4);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block3);
			transition_out(t6.$$.fragment, local);
			transition_out(link.$$.fragment, local);
			transition_out(t9.$$.fragment, local);
			transition_out(t11.$$.fragment, local);
			transition_out(clipboardicon.$$.fragment, local);
			transition_out(if_block4);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t2);
			if (detaching) detach(canvas);
			/*canvas_binding*/ ctx[19](null);
			if (detaching) detach(t3);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t5);
			if (detaching) detach(details);
			destroy_component(t6);
			destroy_component(link);
			destroy_component(t9);
			destroy_component(t11);
			destroy_component(clipboardicon);
			/*input_binding*/ ctx[20](null);
			if (detaching) detach(t14);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(if_block4_anchor);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$4(ctx) {
	let form_1;
	let updating_formEl;
	let current;

	function form_1_formEl_binding(value) {
		/*form_1_formEl_binding*/ ctx[21](value);
	}

	let form_1_props = {
		ariaDescribedBy: "formFailureMessageAlert",
		onSubmitWhenValid: /*form*/ ctx[0]?.submit,
		$$slots: { default: [create_default_slot$3] },
		$$scope: { ctx }
	};

	if (/*formEl*/ ctx[2] !== void 0) {
		form_1_props.formEl = /*formEl*/ ctx[2];
	}

	form_1 = new Form({ props: form_1_props });
	binding_callbacks.push(() => bind(form_1, 'formEl', form_1_formEl_binding));

	return {
		c() {
			create_component(form_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const form_1_changes = {};
			if (dirty & /*form*/ 1) form_1_changes.onSubmitWhenValid = /*form*/ ctx[0]?.submit;

			if (dirty & /*$$scope, journey, buttons, qrCodeUrl, qrCodeEl, pollingWaitCb, metadata, $style, modifiedCallbacks, qrCodeCanvas, moduleLoaded, alertNeedsFocus, formMessageKey, form, componentStyle*/ 67141627) {
				form_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_formEl && dirty & /*formEl*/ 4) {
				updating_formEl = true;
				form_1_changes.formEl = /*formEl*/ ctx[2];
				add_flush_callback(() => updating_formEl = false);
			}

			form_1.$set(form_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form_1, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $style;
	component_subscribe($$self, styleStore, $$value => $$invalidate(14, $style = $$value));
	let { componentStyle } = $$props;
	let { form } = $$props;
	let { formEl = null } = $$props;
	let { journey } = $$props;
	let { metadata } = $$props;
	let { step } = $$props;
	let alertNeedsFocus = false;
	let buttons;
	let formMessageKey = '';
	let modifiedCallbacks = [];
	let moduleLoaded = false;
	let pollingWaitCb;
	let pollingWaitIdx;
	let qrCodeCanvas;
	let qrCodeUrl = '';
	let qrCodeEl;

	function determineSubmission() {
		// TODO: the below is more strict; all self-submitting cbs have to complete before submitting
		// if (stepMetadata.isStepSelfSubmittable && isStepReadyToSubmit(callbackMetadataArray)) {
		// The below variation is more liberal first self-submittable cb to call this wins.
		if (metadata?.step?.derived.isStepSelfSubmittable()) {
			form?.submit();
		}
	}

	async function copyUrl() {
		qrCodeEl.select();
		document.execCommand('copy');
	}

	afterUpdate(() => {
		$$invalidate(5, alertNeedsFocus = !!form?.message);
	});

	onMount(() => {
		async function renderQrCodeImage() {
			try {
				// Dynamically import QR Code module to reduce initial load when not needed
				const qrCodeModule = await Promise.resolve().then(function () { return browser; });

				$$invalidate(9, moduleLoaded = true);
				$$invalidate(12, qrCodeUrl = i$2.getQRCodeData(step).uri);

				qrCodeModule.toCanvas(
					qrCodeCanvas,
					qrCodeUrl,
					// Properties required for ForgeRock QR Codes
					{
						errorCorrectionLevel: 'L',
						version: 20,
						width: 400
					},
					function (error) {
						if (error) {
							$$invalidate(0, form.message = interpolate('qrCodeFailedToRender'), form);
							console.error(error);
						}
					}
				);
			} catch(err) {
				$$invalidate(0, form.message = interpolate('qrCodeImportFailure'), form);
				console.error('Failed to import QR Code library');
			}
		}

		renderQrCodeImage();
	});

	function canvas_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			qrCodeCanvas = $$value;
			$$invalidate(11, qrCodeCanvas);
		});
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			qrCodeEl = $$value;
			$$invalidate(13, qrCodeEl);
		});
	}

	function form_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(2, formEl);
	}

	$$self.$$set = $$props => {
		if ('componentStyle' in $$props) $$invalidate(3, componentStyle = $$props.componentStyle);
		if ('form' in $$props) $$invalidate(0, form = $$props.form);
		if ('formEl' in $$props) $$invalidate(2, formEl = $$props.formEl);
		if ('journey' in $$props) $$invalidate(4, journey = $$props.journey);
		if ('metadata' in $$props) $$invalidate(1, metadata = $$props.metadata);
		if ('step' in $$props) $$invalidate(18, step = $$props.step);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*metadata, step, form*/ 262147) {
			{
				// Assign stage value to `QRCode`
				if (metadata) {
					$$invalidate(1, metadata.step.derived.stageName = 'QRCode', metadata);
				}

				const confirmationCallbacks = step.getCallbacksOfType(l.ConfirmationCallback);

				if (confirmationCallbacks.length) {
					const confirmationCb = confirmationCallbacks[0];
					$$invalidate(6, buttons = confirmationCb.getOptions().map((option, index) => ({ value: `${index}`, text: option })));
				}

				step.callbacks.forEach((callback, idx) => {
					if (callback.getType() === l.PollingWaitCallback) {
						$$invalidate(10, pollingWaitCb = callback);
					}
				});

				$$invalidate(7, formMessageKey = convertStringToKey(form?.message));

				/**
 * Filter out ConfirmationCallbacks; we'll use them seperately.
 * Also, we'll filter out TextOutputCallbacks as we won't use the script
 * text for rendering the QR Code, but our own QR Code module.
 * Lastly, filter out PollingWaitCallback as we'll call that separately.
 */
				$$invalidate(8, modifiedCallbacks = step.callbacks.filter(callback => {
					if (callback.getType() === l.TextOutputCallback) {
						return false;
					} else if (callback.getType() === l.ConfirmationCallback) {
						return false;
					} else if (callback.getType() === l.PollingWaitCallback) {
						return false;
					}

					return true;
				}));
			}
		}
	};

	return [
		form,
		metadata,
		formEl,
		componentStyle,
		journey,
		alertNeedsFocus,
		buttons,
		formMessageKey,
		modifiedCallbacks,
		moduleLoaded,
		pollingWaitCb,
		qrCodeCanvas,
		qrCodeUrl,
		qrCodeEl,
		$style,
		pollingWaitIdx,
		determineSubmission,
		copyUrl,
		step,
		canvas_binding,
		input_binding,
		form_1_formEl_binding
	];
}

class Qr_code extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			componentStyle: 3,
			form: 0,
			formEl: 2,
			journey: 4,
			metadata: 1,
			step: 18
		});
	}
}

/* src/lib/components/icons/email-icon.svelte generated by Svelte v3.55.1 */

function create_fragment$3(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M.05 3.555A2 2 0 0 1 2 2h12a2 2 0 0 1 1.95 1.555L8 8.414.05 3.555ZM0 4.697v7.104l5.803-3.558L0 4.697ZM6.761 8.83l-6.57 4.027A2 2 0 0 0 2 14h12a2 2 0 0 0 1.808-1.144l-6.57-4.027L8 9.586l-1.239-.757Zm3.436-.586L16 11.801V4.697l-5.803 3.546Z");
			attr(svg, "class", /*classes*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[1]);
			attr(svg, "width", /*size*/ ctx[1]);
			attr(svg, "viewBox", "0 0 16 16");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p(ctx, [dirty]) {
			if (dirty & /*classes*/ 1) {
				attr(svg, "class", /*classes*/ ctx[0]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "height", /*size*/ ctx[1]);
			}

			if (dirty & /*size*/ 2) {
				attr(svg, "width", /*size*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { classes = '' } = $$props;
	let { size = '24px' } = $$props;

	$$self.$$set = $$props => {
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('size' in $$props) $$invalidate(1, size = $$props.size);
	};

	return [classes, size];
}

class Email_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { classes: 0, size: 1 });
	}
}

/* src/lib/journey/stages/email-suspend.svelte generated by Svelte v3.55.1 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

// (68:2) {#if form?.icon && componentStyle !== 'inline'}
function create_if_block_1$1(ctx) {
	let div;
	let emailicon;
	let current;

	emailicon = new Email_icon({
			props: {
				classes: "tw_text-gray-400 tw_fill-current",
				size: "72px"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(emailicon.$$.fragment);
			attr(div, "class", "tw_flex tw_justify-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(emailicon, div, null);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(emailicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(emailicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(emailicon);
		}
	};
}

// (80:2) {#if form?.message}
function create_if_block$2(ctx) {
	let alert;
	let current;

	alert = new Alert({
			props: {
				id: formFailureMessageId,
				needsFocus: /*alertNeedsFocus*/ ctx[6],
				type: "error",
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*alertNeedsFocus*/ 64) alert_changes.needsFocus = /*alertNeedsFocus*/ ctx[6];

			if (dirty & /*$$scope, formMessageKey, form*/ 524420) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
		}
	};
}

// (81:4) <Alert id={formFailureMessageId} needsFocus={alertNeedsFocus} type="error">
function create_default_slot_1$1(ctx) {
	let t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*formMessageKey, form*/ 132 && t_value !== (t_value = interpolate(/*formMessageKey*/ ctx[7], null, /*form*/ ctx[2]?.message) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (86:2) {#each step?.callbacks as callback, idx}
function create_each_block(ctx) {
	let callbackmapper;
	let current;

	callbackmapper = new Callback_mapper({
			props: {
				props: {
					callback: /*callback*/ ctx[16],
					callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[18]],
					selfSubmitFunction: /*determineSubmission*/ ctx[12],
					stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
					style: /*$styleStore*/ ctx[11]
				}
			}
		});

	return {
		c() {
			create_component(callbackmapper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callbackmapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callbackmapper_changes = {};

			if (dirty & /*step, metadata, $styleStore*/ 2096) callbackmapper_changes.props = {
				callback: /*callback*/ ctx[16],
				callbackMetadata: /*metadata*/ ctx[4]?.callbacks[/*idx*/ ctx[18]],
				selfSubmitFunction: /*determineSubmission*/ ctx[12],
				stepMetadata: /*metadata*/ ctx[4]?.step && { .../*metadata*/ ctx[4].step },
				style: /*$styleStore*/ ctx[11]
			};

			callbackmapper.$set(callbackmapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callbackmapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callbackmapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callbackmapper, detaching);
		}
	};
}

// (61:0) <Form   bind:formEl   ariaDescribedBy={formAriaDescriptor}   id={formElementId}   needsFocus={formNeedsFocus}   onSubmitWhenValid={submitFormWrapper} >
function create_default_slot$2(ctx) {
	let t0;
	let header;
	let h1;
	let sanitize;
	let t1;
	let t2;
	let t3;
	let backto;
	let current;
	let if_block0 = /*form*/ ctx[2]?.icon && /*componentStyle*/ ctx[1] !== 'inline' && create_if_block_1$1();

	sanitize = new Server_strings({
			props: {
				html: true,
				string: /*step*/ ctx[5]?.getHeader() || interpolate('checkYourEmail')
			}
		});

	let if_block1 = /*form*/ ctx[2]?.message && create_if_block$2(ctx);
	let each_value = /*step*/ ctx[5]?.callbacks;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	backto = new Back_to({ props: { journey: /*journey*/ ctx[3] } });

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			header = element("header");
			h1 = element("h1");
			create_component(sanitize.$$.fragment);
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			create_component(backto.$$.fragment);
			attr(h1, "class", "tw_primary-header dark:tw_primary-header_dark");
			attr(header, "id", formHeaderId);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, header, anchor);
			append(header, h1);
			mount_component(sanitize, h1, null);
			/*header_binding*/ ctx[14](header);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t2, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t3, anchor);
			mount_component(backto, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*form*/ ctx[2]?.icon && /*componentStyle*/ ctx[1] !== 'inline') {
				if (if_block0) {
					if (dirty & /*form, componentStyle*/ 6) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$1();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const sanitize_changes = {};
			if (dirty & /*step*/ 32) sanitize_changes.string = /*step*/ ctx[5]?.getHeader() || interpolate('checkYourEmail');
			sanitize.$set(sanitize_changes);

			if (/*form*/ ctx[2]?.message) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*form*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t2.parentNode, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*step, metadata, determineSubmission, $styleStore*/ 6192) {
				each_value = /*step*/ ctx[5]?.callbacks;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t3.parentNode, t3);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const backto_changes = {};
			if (dirty & /*journey*/ 8) backto_changes.journey = /*journey*/ ctx[3];
			backto.$set(backto_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(sanitize.$$.fragment, local);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(backto.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(sanitize.$$.fragment, local);
			transition_out(if_block1);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(backto.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(header);
			destroy_component(sanitize);
			/*header_binding*/ ctx[14](null);
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t2);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t3);
			destroy_component(backto, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let form_1;
	let updating_formEl;
	let current;

	function form_1_formEl_binding(value) {
		/*form_1_formEl_binding*/ ctx[15](value);
	}

	let form_1_props = {
		ariaDescribedBy: /*formAriaDescriptor*/ ctx[8],
		id: formElementId,
		needsFocus: /*formNeedsFocus*/ ctx[9],
		onSubmitWhenValid: /*submitFormWrapper*/ ctx[13],
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	if (/*formEl*/ ctx[0] !== void 0) {
		form_1_props.formEl = /*formEl*/ ctx[0];
	}

	form_1 = new Form({ props: form_1_props });
	binding_callbacks.push(() => bind(form_1, 'formEl', form_1_formEl_binding));

	return {
		c() {
			create_component(form_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const form_1_changes = {};
			if (dirty & /*formAriaDescriptor*/ 256) form_1_changes.ariaDescribedBy = /*formAriaDescriptor*/ ctx[8];
			if (dirty & /*formNeedsFocus*/ 512) form_1_changes.needsFocus = /*formNeedsFocus*/ ctx[9];

			if (dirty & /*$$scope, journey, step, metadata, $styleStore, alertNeedsFocus, formMessageKey, form, linkWrapper, componentStyle*/ 527614) {
				form_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_formEl && dirty & /*formEl*/ 1) {
				updating_formEl = true;
				form_1_changes.formEl = /*formEl*/ ctx[0];
				add_flush_callback(() => updating_formEl = false);
			}

			form_1.$set(form_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form_1, detaching);
		}
	};
}

const formFailureMessageId = 'genericStepFailureMessage';
const formHeaderId = 'genericStepHeader';
const formElementId = 'genericStepForm';

function instance$2($$self, $$props, $$invalidate) {
	let $styleStore;
	component_subscribe($$self, styleStore, $$value => $$invalidate(11, $styleStore = $$value));
	let { componentStyle } = $$props;
	let { form } = $$props;
	let { formEl = null } = $$props;
	let { journey } = $$props;
	let { metadata } = $$props;
	let { step } = $$props;
	let alertNeedsFocus = false;
	let formMessageKey = '';
	let formAriaDescriptor = 'genericStepHeader';
	let formNeedsFocus = false;
	let linkWrapper;

	function determineSubmission() {
		// TODO: the below is more strict; all self-submitting cbs have to complete before submitting
		// if (stepMetadata.isStepSelfSubmittable && isStepReadyToSubmit(callbackMetadataArray)) {
		// The below variation is more liberal, first self-submittable cb to call this wins.
		if (metadata?.step?.derived.isStepSelfSubmittable()) {
			submitFormWrapper();
		}
	}

	function submitFormWrapper() {
		$$invalidate(6, alertNeedsFocus = false);
		$$invalidate(9, formNeedsFocus = false);
		form?.submit();
	}

	afterUpdate(() => {
		if (form?.message) {
			$$invalidate(8, formAriaDescriptor = formFailureMessageId);
			$$invalidate(6, alertNeedsFocus = true);
			$$invalidate(9, formNeedsFocus = false);
		} else {
			$$invalidate(8, formAriaDescriptor = formHeaderId);
			$$invalidate(6, alertNeedsFocus = false);
			$$invalidate(9, formNeedsFocus = true);
		}
	});

	onMount(() => captureLinks(linkWrapper, journey));

	function header_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			linkWrapper = $$value;
			$$invalidate(10, linkWrapper);
		});
	}

	function form_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(0, formEl);
	}

	$$self.$$set = $$props => {
		if ('componentStyle' in $$props) $$invalidate(1, componentStyle = $$props.componentStyle);
		if ('form' in $$props) $$invalidate(2, form = $$props.form);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('journey' in $$props) $$invalidate(3, journey = $$props.journey);
		if ('metadata' in $$props) $$invalidate(4, metadata = $$props.metadata);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*step, form*/ 36) {
			{
				shouldRedirectFromStep(step) && f$1.redirect(step);
				$$invalidate(7, formMessageKey = convertStringToKey(form?.message));
			}
		}
	};

	return [
		formEl,
		componentStyle,
		form,
		journey,
		metadata,
		step,
		alertNeedsFocus,
		formMessageKey,
		formAriaDescriptor,
		formNeedsFocus,
		linkWrapper,
		$styleStore,
		determineSubmission,
		submitFormWrapper,
		header_binding,
		form_1_formEl_binding
	];
}

class Email_suspend extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			componentStyle: 1,
			form: 2,
			formEl: 0,
			journey: 3,
			metadata: 4,
			step: 5
		});
	}
}

/**
 * @function mapStepToStage - Maps the current step to the proper stage component.
 * @param {object} currentStep - The current step to check
 * @returns {object} - The stage Svelte component
 */
function mapStepToStage(currentStep) {
    // Handle unlikely error state
    if (!currentStep || currentStep.type !== 'Step') {
        return Generic;
    }
    // Prioritize stage value if present
    switch (currentStep?.getStage && currentStep.getStage()) {
        case 'OneTimePassword':
            return One_time_password;
        case 'DefaultRegistration':
            return Registration;
        case 'DefaultLogin':
            return Login;
    }
    // getWebAuthnStepType will return 0 if not a WebAuthn step
    if (T.getWebAuthnStepType(currentStep)) {
        return Webauthn;
    }
    if (p$1.isDisplayStep(currentStep)) {
        return Recovery_codes;
    }
    if (i$2.isQRCodeStep(currentStep)) {
        return Qr_code;
    }
    const suspendedTextOutput = currentStep.getCallbacksOfType(l.SuspendedTextOutputCallback);
    if (suspendedTextOutput.length > 0) {
        return Email_suspend;
    }
    return Generic;
}

/* src/lib/journey/journey.svelte generated by Svelte v3.55.1 */

function create_else_block$1(ctx) {
	let alert;
	let t;
	let button;
	let current;

	alert = new Alert({
			props: {
				id: "unrecoverableStepError",
				needsFocus: /*alertNeedsFocus*/ ctx[4],
				type: "error",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	button = new Button({
			props: {
				style: "secondary",
				onClick: /*tryAgain*/ ctx[7],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(alert.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(alert, target, anchor);
			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const alert_changes = {};
			if (dirty & /*alertNeedsFocus*/ 16) alert_changes.needsFocus = /*alertNeedsFocus*/ ctx[4];

			if (dirty & /*$$scope*/ 512) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 512) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(alert.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(alert.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(alert, detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (56:52) 
function create_if_block_3(ctx) {
	let div;
	let spinner;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-28 tw_w-28"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(spinner.$$.fragment);
			attr(div, "class", "tw_text-center tw_w-full tw_py-4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(spinner, div, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(spinner);
		}
	};
}

// (30:0) {#if $journeyStore && !$journeyStore.completed}
function create_if_block$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*$journeyStore*/ ctx[5] && !/*$journeyStore*/ ctx[5].step) return 0;
		if (/*$journeyStore*/ ctx[5].step?.type === r$a.Step) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (61:2) <Alert id="unrecoverableStepError" needsFocus={alertNeedsFocus} type="error">
function create_default_slot_1(ctx) {
	let t;
	let current;

	t = new Locale_strings({
			props: { html: true, key: "unrecoverableError" }
		});

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (64:2) <Button style="secondary" onClick={tryAgain}>
function create_default_slot$1(ctx) {
	let t;
	let current;
	t = new Locale_strings({ props: { key: "tryAgain" } });

	return {
		c() {
			create_component(t.$$.fragment);
		},
		m(target, anchor) {
			mount_component(t, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(t.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(t.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(t, detaching);
		}
	};
}

// (35:55) 
function create_if_block_2(ctx) {
	let switch_instance;
	let updating_formEl;
	let switch_instance_anchor;
	let current;

	function switch_instance_formEl_binding(value) {
		/*switch_instance_formEl_binding*/ ctx[8](value);
	}

	var switch_value = mapStepToStage(/*$journeyStore*/ ctx[5].step);

	function switch_props(ctx) {
		let switch_instance_props = {
			componentStyle: /*componentStyle*/ ctx[1],
			form: {
				icon: /*displayIcon*/ ctx[2],
				message: /*$journeyStore*/ ctx[5].error?.message || '',
				status: (/*$journeyStore*/ ctx[5].error?.code) ? 'error' : 'ok',
				submit: /*submitForm*/ ctx[6]
			},
			journey: {
				loading: /*$journeyStore*/ ctx[5].loading,
				pop: /*journeyStore*/ ctx[3].pop,
				push: /*journeyStore*/ ctx[3].push,
				stack
			},
			metadata: /*$journeyStore*/ ctx[5].metadata,
			step: /*$journeyStore*/ ctx[5].step
		};

		if (/*formEl*/ ctx[0] !== void 0) {
			switch_instance_props.formEl = /*formEl*/ ctx[0];
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		binding_callbacks.push(() => bind(switch_instance, 'formEl', switch_instance_formEl_binding));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty & /*componentStyle*/ 2) switch_instance_changes.componentStyle = /*componentStyle*/ ctx[1];

			if (dirty & /*displayIcon, $journeyStore*/ 36) switch_instance_changes.form = {
				icon: /*displayIcon*/ ctx[2],
				message: /*$journeyStore*/ ctx[5].error?.message || '',
				status: (/*$journeyStore*/ ctx[5].error?.code) ? 'error' : 'ok',
				submit: /*submitForm*/ ctx[6]
			};

			if (dirty & /*$journeyStore, journeyStore*/ 40) switch_instance_changes.journey = {
				loading: /*$journeyStore*/ ctx[5].loading,
				pop: /*journeyStore*/ ctx[3].pop,
				push: /*journeyStore*/ ctx[3].push,
				stack
			};

			if (dirty & /*$journeyStore*/ 32) switch_instance_changes.metadata = /*$journeyStore*/ ctx[5].metadata;
			if (dirty & /*$journeyStore*/ 32) switch_instance_changes.step = /*$journeyStore*/ ctx[5].step;

			if (!updating_formEl && dirty & /*formEl*/ 1) {
				updating_formEl = true;
				switch_instance_changes.formEl = /*formEl*/ ctx[0];
				add_flush_callback(() => updating_formEl = false);
			}

			if (switch_value !== (switch_value = mapStepToStage(/*$journeyStore*/ ctx[5].step))) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
					binding_callbacks.push(() => bind(switch_instance, 'formEl', switch_instance_formEl_binding));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (31:2) {#if $journeyStore && !$journeyStore.step}
function create_if_block_1(ctx) {
	let div;
	let spinner;
	let current;

	spinner = new Spinner({
			props: {
				colorClass: "tw_text-primary-light",
				layoutClasses: "tw_h-28 tw_w-28"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(spinner.$$.fragment);
			attr(div, "class", "tw_text-center tw_w-full tw_py-4");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(spinner, div, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(spinner);
		}
	};
}

function create_fragment$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_if_block_3, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$journeyStore*/ ctx[5] && !/*$journeyStore*/ ctx[5].completed) return 0;
		if (/*$journeyStore*/ ctx[5] && /*$journeyStore*/ ctx[5].successful) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $journeyStore,
		$$unsubscribe_journeyStore = noop,
		$$subscribe_journeyStore = () => ($$unsubscribe_journeyStore(), $$unsubscribe_journeyStore = subscribe(journeyStore, $$value => $$invalidate(5, $journeyStore = $$value)), journeyStore);

	$$self.$$.on_destroy.push(() => $$unsubscribe_journeyStore());
	let { componentStyle } = $$props;
	let { displayIcon } = $$props;
	let { formEl = null } = $$props;
	let { journeyStore } = $$props;
	$$subscribe_journeyStore();

	if (!$journeyStore) {
		console.error('Widget missing configuration. Import and call `configuration()`, then use `set()` to configure.');
	}

	let alertNeedsFocus = false;

	function submitForm() {
		// Get next step, passing previous step with new data
		journeyStore?.next($journeyStore.step);
	}

	function tryAgain() {
		journeyStore?.reset();
		journeyStore?.next();
	}

	afterUpdate(() => {
		$$invalidate(4, alertNeedsFocus = $journeyStore && !$journeyStore.successful);
	});

	function switch_instance_formEl_binding(value) {
		formEl = value;
		$$invalidate(0, formEl);
	}

	$$self.$$set = $$props => {
		if ('componentStyle' in $$props) $$invalidate(1, componentStyle = $$props.componentStyle);
		if ('displayIcon' in $$props) $$invalidate(2, displayIcon = $$props.displayIcon);
		if ('formEl' in $$props) $$invalidate(0, formEl = $$props.formEl);
		if ('journeyStore' in $$props) $$subscribe_journeyStore($$invalidate(3, journeyStore = $$props.journeyStore));
	};

	return [
		formEl,
		componentStyle,
		displayIcon,
		journeyStore,
		alertNeedsFocus,
		$journeyStore,
		submitForm,
		tryAgain,
		switch_instance_formEl_binding
	];
}

class Journey extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			componentStyle: 1,
			displayIcon: 2,
			formEl: 0,
			journeyStore: 3
		});
	}
}

/* src/lib/widget/index.svelte generated by Svelte v3.55.1 */

function create_else_block(ctx) {
	let div;
	let journey_1;
	let updating_formEl;
	let current;

	function journey_1_formEl_binding_1(value) {
		/*journey_1_formEl_binding_1*/ ctx[9](value);
	}

	let journey_1_props = {
		componentStyle: "inline",
		displayIcon: /*$styleStore*/ ctx[4]?.stage?.icon ?? true,
		journeyStore: /*journeyStore*/ ctx[5]
	};

	if (/*formEl*/ ctx[3] !== void 0) {
		journey_1_props.formEl = /*formEl*/ ctx[3];
	}

	journey_1 = new Journey({ props: journey_1_props });
	binding_callbacks.push(() => bind(journey_1, 'formEl', journey_1_formEl_binding_1));

	return {
		c() {
			div = element("div");
			create_component(journey_1.$$.fragment);
			attr(div, "class", "fr_widget-root");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(journey_1, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const journey_1_changes = {};
			if (dirty & /*$styleStore*/ 16) journey_1_changes.displayIcon = /*$styleStore*/ ctx[4]?.stage?.icon ?? true;

			if (!updating_formEl && dirty & /*formEl*/ 8) {
				updating_formEl = true;
				journey_1_changes.formEl = /*formEl*/ ctx[3];
				add_flush_callback(() => updating_formEl = false);
			}

			journey_1.$set(journey_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(journey_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(journey_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(journey_1);
		}
	};
}

// (29:0) {#if type === 'modal'}
function create_if_block(ctx) {
	let div;
	let dialog;
	let updating_dialogEl;
	let current;

	function dialog_dialogEl_binding(value) {
		/*dialog_dialogEl_binding*/ ctx[7](value);
	}

	let dialog_props = {
		dialogId: "sampleDialog",
		withHeader: /*$styleStore*/ ctx[4]?.sections?.header,
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*dialogEl*/ ctx[2] !== void 0) {
		dialog_props.dialogEl = /*dialogEl*/ ctx[2];
	}

	dialog = new Dialog({ props: dialog_props });
	binding_callbacks.push(() => bind(dialog, 'dialogEl', dialog_dialogEl_binding));
	/*dialog_binding*/ ctx[8](dialog);

	return {
		c() {
			div = element("div");
			create_component(dialog.$$.fragment);
			attr(div, "class", "fr_widget-root");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(dialog, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const dialog_changes = {};
			if (dirty & /*$styleStore*/ 16) dialog_changes.withHeader = /*$styleStore*/ ctx[4]?.sections?.header;

			if (dirty & /*$$scope, $styleStore, formEl*/ 1048) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_dialogEl && dirty & /*dialogEl*/ 4) {
				updating_dialogEl = true;
				dialog_changes.dialogEl = /*dialogEl*/ ctx[2];
				add_flush_callback(() => updating_dialogEl = false);
			}

			dialog.$set(dialog_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*dialog_binding*/ ctx[8](null);
			destroy_component(dialog);
		}
	};
}

// (31:4) <Dialog       bind:dialogEl       bind:this={dialogComp}       dialogId="sampleDialog"       withHeader={$styleStore?.sections?.header}     >
function create_default_slot(ctx) {
	let journey_1;
	let updating_formEl;
	let current;

	function journey_1_formEl_binding(value) {
		/*journey_1_formEl_binding*/ ctx[6](value);
	}

	let journey_1_props = {
		componentStyle: "modal",
		displayIcon: /*$styleStore*/ ctx[4]?.stage?.icon ?? !/*$styleStore*/ ctx[4]?.logo,
		journeyStore: /*journeyStore*/ ctx[5]
	};

	if (/*formEl*/ ctx[3] !== void 0) {
		journey_1_props.formEl = /*formEl*/ ctx[3];
	}

	journey_1 = new Journey({ props: journey_1_props });
	binding_callbacks.push(() => bind(journey_1, 'formEl', journey_1_formEl_binding));

	return {
		c() {
			create_component(journey_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(journey_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const journey_1_changes = {};
			if (dirty & /*$styleStore*/ 16) journey_1_changes.displayIcon = /*$styleStore*/ ctx[4]?.stage?.icon ?? !/*$styleStore*/ ctx[4]?.logo;

			if (!updating_formEl && dirty & /*formEl*/ 8) {
				updating_formEl = true;
				journey_1_changes.formEl = /*formEl*/ ctx[3];
				add_flush_callback(() => updating_formEl = false);
			}

			journey_1.$set(journey_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(journey_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(journey_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(journey_1, detaching);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[0] === 'modal') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const api = widgetApiFactory(componentApi());
const configuration = api.configuration;
const journey = api.journey;
const component = componentApi;
const request = api.request;
const user = api.user;
const protect = api.protect;

function instance($$self, $$props, $$invalidate) {
	let $styleStore;
	component_subscribe($$self, styleStore, $$value => $$invalidate(4, $styleStore = $$value));
	let { type = 'modal' } = $$props;
	const { journeyStore } = api.getStores();

	// Variables that reference the Svelte component and the DOM elements
	let dialogComp;

	let dialogEl;
	let formEl;

	onMount(() => {
		mount(dialogComp, dialogEl);
	});

	function journey_1_formEl_binding(value) {
		formEl = value;
		$$invalidate(3, formEl);
	}

	function dialog_dialogEl_binding(value) {
		dialogEl = value;
		$$invalidate(2, dialogEl);
	}

	function dialog_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dialogComp = $$value;
			$$invalidate(1, dialogComp);
		});
	}

	function journey_1_formEl_binding_1(value) {
		formEl = value;
		$$invalidate(3, formEl);
	}

	$$self.$$set = $$props => {
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
	};

	return [
		type,
		dialogComp,
		dialogEl,
		formEl,
		$styleStore,
		journeyStore,
		journey_1_formEl_binding,
		dialog_dialogEl_binding,
		dialog_binding,
		journey_1_formEl_binding_1
	];
}

class Widget extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { type: 0 });
	}
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

if (typeof window < "u") {
  var M;
  ((function(s, h) {
    typeof s.CustomEvent != "function" && (s.CustomEvent = /* @__PURE__ */ function() {
      return function(r, t) {
        t = t || { bubbles: !1, cancelable: !1, detail: null };
        var e = document.createEvent("CustomEvent");
        return e.initCustomEvent(r, t.bubbles, t.cancelable, t.detail), e;
      };
    }());
  }))(window), function() {
    var s = "st-ping-div";
    function h(u) {
      document.readyState !== "loading" ? u() : document.addEventListener("DOMContentLoaded", u);
    }
    function r(u) {
      h(function() {
        if (u) {
          var c = (l = document.getElementById(s)) || ((l = document.createElement("div")).style.border = "none", l.style.position = "absolute", l.style.top = "-999px", l.style.left = "-999px", l.style.width = "0", l.style.height = "0", l.style.visibility = "hidden", l.style.overflow = "hidden", l.id = s, document.body.appendChild(l), l);
          window._pingOneSignalsToken = getComputedStyle(c, "::after").content.replace(
            /['"]+/g,
            ""
          ), document.dispatchEvent(new CustomEvent("PingOneSignalsTokenReadyEvent"));
        }
        var l, d;
        d = "Finished - " + (u ? "success" : "failure"), window["enable-logs-pingOneSignals"] && console.log(d);
      });
    }
    var t, e, n, i, a = document.querySelector("script[data-pingOneSignalsSkipToken]");
    if (a && a.getAttribute("data-pingOneSignalsSkipToken") === "true")
      return window._pingOneSignalsToken = "skipped_token_" + (/* @__PURE__ */ new Date()).getTime(), h(function() {
        document.dispatchEvent(new CustomEvent("PingOneSignalsTokenSkippedEvent"));
      });
    window._pingOneSignalsToken || (window._pingOneSignalsToken = "uninitialized_token_" + (/* @__PURE__ */ new Date()).getTime()), t = window._pingOneSignalsCustomHost || "apps.pingone.com", e = { sdkVersion: "5.3.5w", platform: navigator.platform || "" }, n = encodeURIComponent(
      function(u) {
        var c, l, d, p, m, k, x, y = "", C = 0, A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        for (u = function(P) {
          P = P.replace(/\r\n/g, `
`);
          for (var D = "", j = 0; j < P.length; j++) {
            var z = P.charCodeAt(j);
            z < 128 ? D += String.fromCharCode(z) : (127 < z && z < 2048 ? D += String.fromCharCode(z >> 6 | 192) : (D += String.fromCharCode(z >> 12 | 224), D += String.fromCharCode(z >> 6 & 63 | 128)), D += String.fromCharCode(63 & z | 128));
          }
          return D;
        }(u); C < u.length; )
          p = (c = u.charCodeAt(C++)) >> 2, m = (3 & c) << 4 | (l = u.charCodeAt(C++)) >> 4, k = (15 & l) << 2 | (d = u.charCodeAt(C++)) >> 6, x = 63 & d, isNaN(l) ? k = x = 64 : isNaN(d) && (x = 64), y = y + A.charAt(p) + A.charAt(m) + A.charAt(k) + A.charAt(x);
        return y;
      }(
        function(u, c) {
          for (var l = [], d = 0; d < u.length; d++) {
            var p = u.charCodeAt(d) ^ c.charCodeAt(d % c.length);
            l.push(String.fromCharCode(p));
          }
          return l.join("");
        }(JSON.stringify(e), "dkiBm42")
      )
    ), (i = document.createElement("link")).type = "text/css", i.rel = "stylesheet", i.href = "https://" + t + "/signals/sdk/pong.css?body=" + n + "&e=2", (document.head || document.getElementsByTagName("head")[0]).appendChild(i), i.onload = function() {
      r(!0);
    }, i.onerror = function() {
      r(!1);
    };
  }(), function(s) {
    s._POSignalsEntities || (s._POSignalsEntities = {}), s._pingOneSignals && console.warn("PingOne Signals script was imported multiple times");
  }(window), function(s) {
    function h(d) {
      var p = this.constructor;
      return this.then(
        function(m) {
          return p.resolve(d()).then(function() {
            return m;
          });
        },
        function(m) {
          return p.resolve(d()).then(function() {
            return p.reject(m);
          });
        }
      );
    }
    var r = setTimeout;
    function t(d) {
      return !!(d && d.length !== void 0);
    }
    function e() {
    }
    function n(d) {
      if (!(this instanceof n))
        throw new TypeError("Promises must be constructed via new");
      if (typeof d != "function")
        throw new TypeError("not a function");
      this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], l(d, this);
    }
    function i(d, p) {
      for (; d._state === 3; )
        d = d._value;
      d._state !== 0 ? (d._handled = !0, n._immediateFn(function() {
        var m = d._state === 1 ? p.onFulfilled : p.onRejected;
        if (m !== null) {
          var k;
          try {
            k = m(d._value);
          } catch (x) {
            return void u(p.promise, x);
          }
          a(p.promise, k);
        } else
          (d._state === 1 ? a : u)(p.promise, d._value);
      })) : d._deferreds.push(p);
    }
    function a(d, p) {
      try {
        if (p === d)
          throw new TypeError("A promise cannot be resolved with itself.");
        if (p && (typeof p == "object" || typeof p == "function")) {
          var m = p.then;
          if (p instanceof n)
            return d._state = 3, d._value = p, void c(d);
          if (typeof m == "function")
            return void l(
              (k = m, x = p, function() {
                k.apply(x, arguments);
              }),
              d
            );
        }
        d._state = 1, d._value = p, c(d);
      } catch (y) {
        u(d, y);
      }
      var k, x;
    }
    function u(d, p) {
      d._state = 2, d._value = p, c(d);
    }
    function c(d) {
      d._state === 2 && d._deferreds.length === 0 && n._immediateFn(function() {
        d._handled || n._unhandledRejectionFn(d._value);
      });
      for (var p = 0, m = d._deferreds.length; p < m; p++)
        i(d, d._deferreds[p]);
      d._deferreds = null;
    }
    function l(d, p) {
      var m = !1;
      try {
        d(
          function(k) {
            m || (m = !0, a(p, k));
          },
          function(k) {
            m || (m = !0, u(p, k));
          }
        );
      } catch (k) {
        if (m)
          return;
        m = !0, u(p, k);
      }
    }
    n.prototype.catch = function(d) {
      return this.then(null, d);
    }, n.prototype.then = function(d, p) {
      var m = new this.constructor(e);
      return i(
        this,
        new function(k, x, y) {
          this.onFulfilled = typeof k == "function" ? k : null, this.onRejected = typeof x == "function" ? x : null, this.promise = y;
        }(d, p, m)
      ), m;
    }, n.prototype.finally = h, n.all = function(d) {
      return new n(function(p, m) {
        if (!t(d))
          return m(new TypeError("Promise.all accepts an array"));
        var k = Array.prototype.slice.call(d);
        if (k.length === 0)
          return p([]);
        var x = k.length;
        function y(A, P) {
          try {
            if (P && (typeof P == "object" || typeof P == "function")) {
              var D = P.then;
              if (typeof D == "function")
                return void D.call(
                  P,
                  function(j) {
                    y(A, j);
                  },
                  m
                );
            }
            k[A] = P, --x == 0 && p(k);
          } catch (j) {
            m(j);
          }
        }
        for (var C = 0; C < k.length; C++)
          y(C, k[C]);
      });
    }, n.resolve = function(d) {
      return d && typeof d == "object" && d.constructor === n ? d : new n(function(p) {
        p(d);
      });
    }, n.reject = function(d) {
      return new n(function(p, m) {
        m(d);
      });
    }, n.race = function(d) {
      return new n(function(p, m) {
        if (!t(d))
          return m(new TypeError("Promise.race accepts an array"));
        for (var k = 0, x = d.length; k < x; k++)
          n.resolve(d[k]).then(p, m);
      });
    }, n._immediateFn = typeof setImmediate == "function" && function(d) {
      setImmediate(d);
    } || function(d) {
      r(d, 0);
    }, n._unhandledRejectionFn = function(d) {
      typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", d);
    }, typeof s.Promise != "function" ? s.Promise = n : s.Promise.prototype.finally || (s.Promise.prototype.finally = h);
  }(window), function(s, h) {
    (M || (M = {})).PromiseQueue = function() {
      var r = function() {
      };
      function t(e, n, i) {
        this.options = i = i || {}, this.pendingPromises = 0, this.maxPendingPromises = e !== void 0 ? e : 1 / 0, this.maxQueuedPromises = n !== void 0 ? n : 1 / 0, this.queue = [];
      }
      return t.prototype.add = function(e) {
        var n = this;
        return new Promise(function(i, a, u) {
          n.queue.length >= n.maxQueuedPromises ? a(new Error("Queue limit reached")) : (n.queue.push({ promiseGenerator: e, resolve: i, reject: a, notify: u || r }), n._dequeue());
        });
      }, t.prototype.getPendingLength = function() {
        return this.pendingPromises;
      }, t.prototype.getQueueLength = function() {
        return this.queue.length;
      }, t.prototype._dequeue = function() {
        var e = this;
        if (this.pendingPromises >= this.maxPendingPromises)
          return !1;
        var n, i = this.queue.shift();
        if (!i)
          return this.options.onEmpty && this.options.onEmpty(), !1;
        try {
          this.pendingPromises++, (n = i.promiseGenerator(), n && typeof n.then == "function" ? n : new Promise(function(a) {
            a(n);
          })).then(
            function(a) {
              e.pendingPromises--, i.resolve(a), e._dequeue();
            },
            function(a) {
              e.pendingPromises--, i.reject(a), e._dequeue();
            },
            function(a) {
              i.notify(a);
            }
          );
        } catch (a) {
          e.pendingPromises--, i.reject(a), e._dequeue();
        }
        return !0;
      }, t;
    }();
  }(), function(s) {
    var h = "input is invalid type", r = !s.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", t = "0123456789abcdef".split(""), e = [-2147483648, 8388608, 32768, 128], n = [24, 16, 8, 0], i = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ], a = ["hex", "array", "digest", "arrayBuffer"], u = [];
    !s.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(y) {
      return Object.prototype.toString.call(y) === "[object Array]";
    }), !r || !s.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(y) {
      return typeof y == "object" && y.buffer && y.buffer.constructor === ArrayBuffer;
    });
    var c = function(y, C) {
      return function(A) {
        return new m(C, !0).update(A)[y]();
      };
    }, l = function(y) {
      var C = c("hex", y);
      C.create = function() {
        return new m(y);
      }, C.update = function(D) {
        return C.create().update(D);
      };
      for (var A = 0; A < a.length; ++A) {
        var P = a[A];
        C[P] = c(P, y);
      }
      return C;
    }, d = function(y, C) {
      return function(A, P) {
        return new k(A, C, !0).update(P)[y]();
      };
    }, p = function(y) {
      var C = d("hex", y);
      C.create = function(D) {
        return new k(D, y);
      }, C.update = function(D, j) {
        return C.create(D).update(j);
      };
      for (var A = 0; A < a.length; ++A) {
        var P = a[A];
        C[P] = d(P, y);
      }
      return C;
    };
    function m(y, C) {
      C ? (u[0] = u[16] = u[1] = u[2] = u[3] = u[4] = u[5] = u[6] = u[7] = u[8] = u[9] = u[10] = u[11] = u[12] = u[13] = u[14] = u[15] = 0, this.blocks = u) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], y ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = y;
    }
    function k(y, C, A) {
      var P, D = typeof y;
      if (D === "string") {
        var j, z = [], B = y.length, T = 0;
        for (P = 0; P < B; ++P)
          (j = y.charCodeAt(P)) < 128 ? z[T++] = j : j < 2048 ? (z[T++] = 192 | j >> 6, z[T++] = 128 | 63 & j) : j < 55296 || j >= 57344 ? (z[T++] = 224 | j >> 12, z[T++] = 128 | j >> 6 & 63, z[T++] = 128 | 63 & j) : (j = 65536 + ((1023 & j) << 10 | 1023 & y.charCodeAt(++P)), z[T++] = 240 | j >> 18, z[T++] = 128 | j >> 12 & 63, z[T++] = 128 | j >> 6 & 63, z[T++] = 128 | 63 & j);
        y = z;
      } else {
        if (D !== "object")
          throw new Error(h);
        if (y === null)
          throw new Error(h);
        if (r && y.constructor === ArrayBuffer)
          y = new Uint8Array(y);
        else if (!(Array.isArray(y) || r && ArrayBuffer.isView(y)))
          throw new Error(h);
      }
      y.length > 64 && (y = new m(C, !0).update(y).array());
      var L = [], E = [];
      for (P = 0; P < 64; ++P) {
        var H = y[P] || 0;
        L[P] = 92 ^ H, E[P] = 54 ^ H;
      }
      m.call(this, C, A), this.update(E), this.oKeyPad = L, this.inner = !0, this.sharedMemory = A;
    }
    m.prototype.update = function(y) {
      if (!this.finalized) {
        var C, A = typeof y;
        if (A !== "string") {
          if (A !== "object")
            throw new Error(h);
          if (y === null)
            throw new Error(h);
          if (r && y.constructor === ArrayBuffer)
            y = new Uint8Array(y);
          else if (!(Array.isArray(y) || r && ArrayBuffer.isView(y)))
            throw new Error(h);
          C = !0;
        }
        for (var P, D, j = 0, z = y.length, B = this.blocks; j < z; ) {
          if (this.hashed && (this.hashed = !1, B[0] = this.block, B[16] = B[1] = B[2] = B[3] = B[4] = B[5] = B[6] = B[7] = B[8] = B[9] = B[10] = B[11] = B[12] = B[13] = B[14] = B[15] = 0), C)
            for (D = this.start; j < z && D < 64; ++j)
              B[D >> 2] |= y[j] << n[3 & D++];
          else
            for (D = this.start; j < z && D < 64; ++j)
              (P = y.charCodeAt(j)) < 128 ? B[D >> 2] |= P << n[3 & D++] : P < 2048 ? (B[D >> 2] |= (192 | P >> 6) << n[3 & D++], B[D >> 2] |= (128 | 63 & P) << n[3 & D++]) : P < 55296 || P >= 57344 ? (B[D >> 2] |= (224 | P >> 12) << n[3 & D++], B[D >> 2] |= (128 | P >> 6 & 63) << n[3 & D++], B[D >> 2] |= (128 | 63 & P) << n[3 & D++]) : (P = 65536 + ((1023 & P) << 10 | 1023 & y.charCodeAt(++j)), B[D >> 2] |= (240 | P >> 18) << n[3 & D++], B[D >> 2] |= (128 | P >> 12 & 63) << n[3 & D++], B[D >> 2] |= (128 | P >> 6 & 63) << n[3 & D++], B[D >> 2] |= (128 | 63 & P) << n[3 & D++]);
          this.lastByteIndex = D, this.bytes += D - this.start, D >= 64 ? (this.block = B[16], this.start = D - 64, this.hash(), this.hashed = !0) : this.start = D;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, m.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var y = this.blocks, C = this.lastByteIndex;
        y[16] = this.block, y[C >> 2] |= e[3 & C], this.block = y[16], C >= 56 && (this.hashed || this.hash(), y[0] = this.block, y[16] = y[1] = y[2] = y[3] = y[4] = y[5] = y[6] = y[7] = y[8] = y[9] = y[10] = y[11] = y[12] = y[13] = y[14] = y[15] = 0), y[14] = this.hBytes << 3 | this.bytes >>> 29, y[15] = this.bytes << 3, this.hash();
      }
    }, m.prototype.hash = function() {
      var y, C, A, P, D, j, z, B, T, L = this.h0, E = this.h1, H = this.h2, S = this.h3, U = this.h4, W = this.h5, J = this.h6, Q = this.h7, oe = this.blocks;
      for (y = 16; y < 64; ++y)
        C = ((D = oe[y - 15]) >>> 7 | D << 25) ^ (D >>> 18 | D << 14) ^ D >>> 3, A = ((D = oe[y - 2]) >>> 17 | D << 15) ^ (D >>> 19 | D << 13) ^ D >>> 10, oe[y] = oe[y - 16] + C + oe[y - 7] + A << 0;
      for (T = E & H, y = 0; y < 64; y += 4)
        this.first ? (this.is224 ? (j = 300032, Q = (D = oe[0] - 1413257819) - 150054599 << 0, S = D + 24177077 << 0) : (j = 704751109, Q = (D = oe[0] - 210244248) - 1521486534 << 0, S = D + 143694565 << 0), this.first = !1) : (C = (L >>> 2 | L << 30) ^ (L >>> 13 | L << 19) ^ (L >>> 22 | L << 10), P = (j = L & E) ^ L & H ^ T, Q = S + (D = Q + (A = (U >>> 6 | U << 26) ^ (U >>> 11 | U << 21) ^ (U >>> 25 | U << 7)) + (U & W ^ ~U & J) + i[y] + oe[y]) << 0, S = D + (C + P) << 0), C = (S >>> 2 | S << 30) ^ (S >>> 13 | S << 19) ^ (S >>> 22 | S << 10), P = (z = S & L) ^ S & E ^ j, J = H + (D = J + (A = (Q >>> 6 | Q << 26) ^ (Q >>> 11 | Q << 21) ^ (Q >>> 25 | Q << 7)) + (Q & U ^ ~Q & W) + i[y + 1] + oe[y + 1]) << 0, C = ((H = D + (C + P) << 0) >>> 2 | H << 30) ^ (H >>> 13 | H << 19) ^ (H >>> 22 | H << 10), P = (B = H & S) ^ H & L ^ z, W = E + (D = W + (A = (J >>> 6 | J << 26) ^ (J >>> 11 | J << 21) ^ (J >>> 25 | J << 7)) + (J & Q ^ ~J & U) + i[y + 2] + oe[y + 2]) << 0, C = ((E = D + (C + P) << 0) >>> 2 | E << 30) ^ (E >>> 13 | E << 19) ^ (E >>> 22 | E << 10), P = (T = E & H) ^ E & S ^ B, U = L + (D = U + (A = (W >>> 6 | W << 26) ^ (W >>> 11 | W << 21) ^ (W >>> 25 | W << 7)) + (W & J ^ ~W & Q) + i[y + 3] + oe[y + 3]) << 0, L = D + (C + P) << 0;
      this.h0 = this.h0 + L << 0, this.h1 = this.h1 + E << 0, this.h2 = this.h2 + H << 0, this.h3 = this.h3 + S << 0, this.h4 = this.h4 + U << 0, this.h5 = this.h5 + W << 0, this.h6 = this.h6 + J << 0, this.h7 = this.h7 + Q << 0;
    }, m.prototype.hex = function() {
      this.finalize();
      var y = this.h0, C = this.h1, A = this.h2, P = this.h3, D = this.h4, j = this.h5, z = this.h6, B = this.h7, T = t[y >> 28 & 15] + t[y >> 24 & 15] + t[y >> 20 & 15] + t[y >> 16 & 15] + t[y >> 12 & 15] + t[y >> 8 & 15] + t[y >> 4 & 15] + t[15 & y] + t[C >> 28 & 15] + t[C >> 24 & 15] + t[C >> 20 & 15] + t[C >> 16 & 15] + t[C >> 12 & 15] + t[C >> 8 & 15] + t[C >> 4 & 15] + t[15 & C] + t[A >> 28 & 15] + t[A >> 24 & 15] + t[A >> 20 & 15] + t[A >> 16 & 15] + t[A >> 12 & 15] + t[A >> 8 & 15] + t[A >> 4 & 15] + t[15 & A] + t[P >> 28 & 15] + t[P >> 24 & 15] + t[P >> 20 & 15] + t[P >> 16 & 15] + t[P >> 12 & 15] + t[P >> 8 & 15] + t[P >> 4 & 15] + t[15 & P] + t[D >> 28 & 15] + t[D >> 24 & 15] + t[D >> 20 & 15] + t[D >> 16 & 15] + t[D >> 12 & 15] + t[D >> 8 & 15] + t[D >> 4 & 15] + t[15 & D] + t[j >> 28 & 15] + t[j >> 24 & 15] + t[j >> 20 & 15] + t[j >> 16 & 15] + t[j >> 12 & 15] + t[j >> 8 & 15] + t[j >> 4 & 15] + t[15 & j] + t[z >> 28 & 15] + t[z >> 24 & 15] + t[z >> 20 & 15] + t[z >> 16 & 15] + t[z >> 12 & 15] + t[z >> 8 & 15] + t[z >> 4 & 15] + t[15 & z];
      return this.is224 || (T += t[B >> 28 & 15] + t[B >> 24 & 15] + t[B >> 20 & 15] + t[B >> 16 & 15] + t[B >> 12 & 15] + t[B >> 8 & 15] + t[B >> 4 & 15] + t[15 & B]), T;
    }, m.prototype.toString = m.prototype.hex, m.prototype.digest = function() {
      this.finalize();
      var y = this.h0, C = this.h1, A = this.h2, P = this.h3, D = this.h4, j = this.h5, z = this.h6, B = this.h7, T = [
        y >> 24 & 255,
        y >> 16 & 255,
        y >> 8 & 255,
        255 & y,
        C >> 24 & 255,
        C >> 16 & 255,
        C >> 8 & 255,
        255 & C,
        A >> 24 & 255,
        A >> 16 & 255,
        A >> 8 & 255,
        255 & A,
        P >> 24 & 255,
        P >> 16 & 255,
        P >> 8 & 255,
        255 & P,
        D >> 24 & 255,
        D >> 16 & 255,
        D >> 8 & 255,
        255 & D,
        j >> 24 & 255,
        j >> 16 & 255,
        j >> 8 & 255,
        255 & j,
        z >> 24 & 255,
        z >> 16 & 255,
        z >> 8 & 255,
        255 & z
      ];
      return this.is224 || T.push(B >> 24 & 255, B >> 16 & 255, B >> 8 & 255, 255 & B), T;
    }, m.prototype.array = m.prototype.digest, m.prototype.arrayBuffer = function() {
      this.finalize();
      var y = new ArrayBuffer(this.is224 ? 28 : 32), C = new DataView(y);
      return C.setUint32(0, this.h0), C.setUint32(4, this.h1), C.setUint32(8, this.h2), C.setUint32(12, this.h3), C.setUint32(16, this.h4), C.setUint32(20, this.h5), C.setUint32(24, this.h6), this.is224 || C.setUint32(28, this.h7), y;
    }, k.prototype = new m(), k.prototype.finalize = function() {
      if (m.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var y = this.array();
        m.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(y), m.prototype.finalize.call(this);
      }
    };
    var x = l();
    x.sha256 = x, x.sha224 = l(!0), x.sha256.hmac = p(), x.sha224.hmac = p(!0), s.sha256 = x.sha256, s.sha224 = x.sha224;
  }(M || (M = {})), (M || (M = {})).FingerprintJS = function(s) {
    function h(_, O) {
      _ = [_[0] >>> 16, 65535 & _[0], _[1] >>> 16, 65535 & _[1]], O = [O[0] >>> 16, 65535 & O[0], O[1] >>> 16, 65535 & O[1]];
      var w = [0, 0, 0, 0];
      return w[3] += _[3] + O[3], w[2] += w[3] >>> 16, w[3] &= 65535, w[2] += _[2] + O[2], w[1] += w[2] >>> 16, w[2] &= 65535, w[1] += _[1] + O[1], w[0] += w[1] >>> 16, w[1] &= 65535, w[0] += _[0] + O[0], w[0] &= 65535, [w[0] << 16 | w[1], w[2] << 16 | w[3]];
    }
    function r(_, O) {
      _ = [_[0] >>> 16, 65535 & _[0], _[1] >>> 16, 65535 & _[1]], O = [O[0] >>> 16, 65535 & O[0], O[1] >>> 16, 65535 & O[1]];
      var w = [0, 0, 0, 0];
      return w[3] += _[3] * O[3], w[2] += w[3] >>> 16, w[3] &= 65535, w[2] += _[2] * O[3], w[1] += w[2] >>> 16, w[2] &= 65535, w[2] += _[3] * O[2], w[1] += w[2] >>> 16, w[2] &= 65535, w[1] += _[1] * O[3], w[0] += w[1] >>> 16, w[1] &= 65535, w[1] += _[2] * O[2], w[0] += w[1] >>> 16, w[1] &= 65535, w[1] += _[3] * O[1], w[0] += w[1] >>> 16, w[1] &= 65535, w[0] += _[0] * O[3] + _[1] * O[2] + _[2] * O[1] + _[3] * O[0], w[0] &= 65535, [w[0] << 16 | w[1], w[2] << 16 | w[3]];
    }
    function t(_, O) {
      return (O %= 64) == 32 ? [_[1], _[0]] : O < 32 ? [_[0] << O | _[1] >>> 32 - O, _[1] << O | _[0] >>> 32 - O] : (O -= 32, [_[1] << O | _[0] >>> 32 - O, _[0] << O | _[1] >>> 32 - O]);
    }
    function e(_, O) {
      return (O %= 64) == 0 ? _ : O < 32 ? [_[0] << O | _[1] >>> 32 - O, _[1] << O] : [_[1] << O - 32, 0];
    }
    function n(_, O) {
      return [_[0] ^ O[0], _[1] ^ O[1]];
    }
    function i(_) {
      return _ = n(
        _ = r(
          _ = n(_ = r(_ = n(_, [0, _[0] >>> 1]), [4283543511, 3981806797]), [
            0,
            _[0] >>> 1
          ]),
          [3301882366, 444984403]
        ),
        [0, _[0] >>> 1]
      );
    }
    function a(_, O) {
      _ = _ || "", O = O || 0;
      var w, K = _.length % 16, V = _.length - K, o = [0, O], g = [0, O], v = [0, 0], f = [0, 0], b = [2277735313, 289559509], I = [1291169091, 658871167];
      for (w = 0; w < V; w += 16)
        v = [
          255 & _.charCodeAt(w + 4) | (255 & _.charCodeAt(w + 5)) << 8 | (255 & _.charCodeAt(w + 6)) << 16 | (255 & _.charCodeAt(w + 7)) << 24,
          255 & _.charCodeAt(w) | (255 & _.charCodeAt(w + 1)) << 8 | (255 & _.charCodeAt(w + 2)) << 16 | (255 & _.charCodeAt(w + 3)) << 24
        ], f = [
          255 & _.charCodeAt(w + 12) | (255 & _.charCodeAt(w + 13)) << 8 | (255 & _.charCodeAt(w + 14)) << 16 | (255 & _.charCodeAt(w + 15)) << 24,
          255 & _.charCodeAt(w + 8) | (255 & _.charCodeAt(w + 9)) << 8 | (255 & _.charCodeAt(w + 10)) << 16 | (255 & _.charCodeAt(w + 11)) << 24
        ], o = h(
          r(
            o = h(o = t(o = n(o, v = r(v = t(v = r(v, b), 31), I)), 27), g),
            [0, 5]
          ),
          [0, 1390208809]
        ), g = h(
          r(
            g = h(g = t(g = n(g, f = r(f = t(f = r(f, I), 33), b)), 31), o),
            [0, 5]
          ),
          [0, 944331445]
        );
      switch (v = [0, 0], f = [0, 0], K) {
        case 15:
          f = n(f, e([0, _.charCodeAt(w + 14)], 48));
        case 14:
          f = n(f, e([0, _.charCodeAt(w + 13)], 40));
        case 13:
          f = n(f, e([0, _.charCodeAt(w + 12)], 32));
        case 12:
          f = n(f, e([0, _.charCodeAt(w + 11)], 24));
        case 11:
          f = n(f, e([0, _.charCodeAt(w + 10)], 16));
        case 10:
          f = n(f, e([0, _.charCodeAt(w + 9)], 8));
        case 9:
          g = n(g, f = r(f = t(f = r(f = n(f, [0, _.charCodeAt(w + 8)]), I), 33), b));
        case 8:
          v = n(v, e([0, _.charCodeAt(w + 7)], 56));
        case 7:
          v = n(v, e([0, _.charCodeAt(w + 6)], 48));
        case 6:
          v = n(v, e([0, _.charCodeAt(w + 5)], 40));
        case 5:
          v = n(v, e([0, _.charCodeAt(w + 4)], 32));
        case 4:
          v = n(v, e([0, _.charCodeAt(w + 3)], 24));
        case 3:
          v = n(v, e([0, _.charCodeAt(w + 2)], 16));
        case 2:
          v = n(v, e([0, _.charCodeAt(w + 1)], 8));
        case 1:
          o = n(o, v = r(v = t(v = r(v = n(v, [0, _.charCodeAt(w)]), b), 31), I));
      }
      return o = n(o, [0, _.length]), g = h(g = n(g, [0, _.length]), o = h(o, g)), o = i(o), g = h(g = i(g), o = h(o, g)), ("00000000" + (o[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (o[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (g[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (g[1] >>> 0).toString(16)).slice(-8);
    }
    var u = function() {
      return (u = Object.assign || function(_) {
        for (var O, w = 1, K = arguments.length; w < K; w++)
          for (var V in O = arguments[w])
            Object.prototype.hasOwnProperty.call(O, V) && (_[V] = O[V]);
        return _;
      }).apply(this, arguments);
    };
    function c(_, O, w, K) {
      return new (w || (w = Promise))(function(V, o) {
        function g(b) {
          try {
            f(K.next(b));
          } catch (I) {
            o(I);
          }
        }
        function v(b) {
          try {
            f(K.throw(b));
          } catch (I) {
            o(I);
          }
        }
        function f(b) {
          var I;
          b.done ? V(b.value) : (I = b.value, I instanceof w ? I : new w(function(F) {
            F(I);
          })).then(g, v);
        }
        f((K = K.apply(_, O || [])).next());
      });
    }
    function l(_, O) {
      var w, K, V, o, g = {
        label: 0,
        sent: function() {
          if (1 & V[0])
            throw V[1];
          return V[1];
        },
        trys: [],
        ops: []
      };
      return o = { next: v(0), throw: v(1), return: v(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this;
      }), o;
      function v(f) {
        return function(b) {
          return function(I) {
            if (w)
              throw new TypeError("Generator is already executing.");
            for (; g; )
              try {
                if (w = 1, K && (V = 2 & I[0] ? K.return : I[0] ? K.throw || ((V = K.return) && V.call(K), 0) : K.next) && !(V = V.call(K, I[1])).done)
                  return V;
                switch (K = 0, V && (I = [2 & I[0], V.value]), I[0]) {
                  case 0:
                  case 1:
                    V = I;
                    break;
                  case 4:
                    return g.label++, { value: I[1], done: !1 };
                  case 5:
                    g.label++, K = I[1], I = [0];
                    continue;
                  case 7:
                    I = g.ops.pop(), g.trys.pop();
                    continue;
                  default:
                    if (!(V = (V = g.trys).length > 0 && V[V.length - 1]) && (I[0] === 6 || I[0] === 2)) {
                      g = 0;
                      continue;
                    }
                    if (I[0] === 3 && (!V || I[1] > V[0] && I[1] < V[3])) {
                      g.label = I[1];
                      break;
                    }
                    if (I[0] === 6 && g.label < V[1]) {
                      g.label = V[1], V = I;
                      break;
                    }
                    if (V && g.label < V[2]) {
                      g.label = V[2], g.ops.push(I);
                      break;
                    }
                    V[2] && g.ops.pop(), g.trys.pop();
                    continue;
                }
                I = O.call(_, g);
              } catch (F) {
                I = [6, F], K = 0;
              } finally {
                w = V = 0;
              }
            if (5 & I[0])
              throw I[1];
            return { value: I[0] ? I[1] : void 0, done: !0 };
          }([f, b]);
        };
      }
    }
    var d = window;
    function p(_) {
      return parseInt(_);
    }
    function m(_) {
      return parseFloat(_);
    }
    function k(_) {
      return _.reduce(function(O, w) {
        return O + (w ? 1 : 0);
      }, 0);
    }
    var x = window, y = navigator, C = document;
    function A() {
      return k([
        "MSCSSMatrix" in x,
        "msSetImmediate" in x,
        "msIndexedDB" in x,
        "msMaxTouchPoints" in y,
        "msPointerEnabled" in y
      ]) >= 4;
    }
    function P() {
      return k(["msWriteProfilerMark" in x, "MSStream" in x, "msLaunchUri" in y, "msSaveBlob" in y]) >= 3 && !A();
    }
    function D() {
      return k([
        "webkitPersistentStorage" in y,
        "webkitTemporaryStorage" in y,
        y.vendor.indexOf("Google") === 0,
        "webkitResolveLocalFileSystemURL" in x,
        "BatteryManager" in x,
        "webkitMediaStream" in x,
        "webkitSpeechGrammar" in x
      ]) >= 5;
    }
    function j() {
      return k([
        "ApplePayError" in x,
        "CSSPrimitiveValue" in x,
        "Counter" in x,
        y.vendor.indexOf("Apple") === 0,
        "getStorageUpdates" in y,
        "WebKitMediaKeys" in x
      ]) >= 4;
    }
    function z() {
      return k([
        "safari" in x,
        !("DeviceMotionEvent" in x),
        !("ongestureend" in x),
        !("standalone" in y)
      ]) >= 3;
    }
    var B = window, T = document;
    function L(_, O, w) {
      (function(K) {
        return K && typeof K.setValueAtTime == "function";
      })(O) && O.setValueAtTime(w, _.currentTime);
    }
    function E(_) {
      var O = new Error(_);
      return O.name = _, O;
    }
    var H = document, S = "mmMwWLliI0O&1", U = ["monospace", "sans-serif", "serif"], W = [
      "sans-serif-thin",
      "ARNO PRO",
      "Agency FB",
      "Arabic Typesetting",
      "Arial Unicode MS",
      "AvantGarde Bk BT",
      "BankGothic Md BT",
      "Batang",
      "Bitstream Vera Sans Mono",
      "Calibri",
      "Century",
      "Century Gothic",
      "Clarendon",
      "EUROSTILE",
      "Franklin Gothic",
      "Futura Bk BT",
      "Futura Md BT",
      "GOTHAM",
      "Gill Sans",
      "HELV",
      "Haettenschweiler",
      "Helvetica Neue",
      "Humanst521 BT",
      "Leelawadee",
      "Letter Gothic",
      "Levenim MT",
      "Lucida Bright",
      "Lucida Sans",
      "Menlo",
      "MS Mincho",
      "MS Outlook",
      "MS Reference Specialty",
      "MS UI Gothic",
      "MT Extra",
      "MYRIAD PRO",
      "Marlett",
      "Meiryo UI",
      "Microsoft Uighur",
      "Minion Pro",
      "Monotype Corsiva",
      "PMingLiU",
      "Pristina",
      "SCRIPTINA",
      "Segoe UI Light",
      "Serifa",
      "SimHei",
      "Small Fonts",
      "Staccato222 BT",
      "TRAJAN PRO",
      "Univers CE 55 Medium",
      "Vrinda",
      "ZWAdobeF"
    ], J = {
      fontStyle: "normal",
      fontWeight: "normal",
      letterSpacing: "normal",
      lineBreak: "auto",
      lineHeight: "normal",
      textTransform: "none",
      textAlign: "left",
      textDecoration: "none",
      textShadow: "none",
      whiteSpace: "normal",
      wordBreak: "normal",
      wordSpacing: "normal",
      position: "absolute",
      left: "-9999px",
      fontSize: "48px"
    }, Q = navigator, oe = window, q = navigator, fe = window, N = window, G = window, Y = document, te = {
      osCpu: function() {
        return navigator.oscpu;
      },
      languages: function() {
        var _ = [], O = q.language || q.userLanguage || q.browserLanguage || q.systemLanguage;
        if (O !== void 0 && _.push([O]), Array.isArray(q.languages))
          D() && k([
            !("MediaSettingsRange" in x),
            "RTCEncodedAudioFrame" in x,
            "" + x.Intl == "[object Intl]",
            "" + x.Reflect == "[object Reflect]"
          ]) >= 3 || _.push(q.languages);
        else if (typeof q.languages == "string") {
          var w = q.languages;
          w && _.push(w.split(","));
        }
        return _;
      },
      colorDepth: function() {
        return window.screen.colorDepth;
      },
      deviceMemory: function() {
        return _ = m(navigator.deviceMemory), O = void 0, typeof _ == "number" && isNaN(_) ? O : _;
        var _, O;
      },
      screenResolution: function() {
        var _ = [p(fe.screen.width), p(fe.screen.height)];
        return _.sort().reverse(), _;
      },
      availableScreenResolution: function() {
        if (N.screen.availWidth && N.screen.availHeight) {
          var _ = [p(N.screen.availWidth), p(N.screen.availHeight)];
          return _.sort().reverse(), _;
        }
      },
      hardwareConcurrency: function() {
        try {
          var _ = p(navigator.hardwareConcurrency);
          return isNaN(_) ? 1 : _;
        } catch {
          return 1;
        }
      },
      timezoneOffset: function() {
        var _ = (/* @__PURE__ */ new Date()).getFullYear();
        return Math.max(
          m(new Date(_, 0, 1).getTimezoneOffset()),
          m(new Date(_, 6, 1).getTimezoneOffset())
        );
      },
      timezone: function() {
        var _;
        if (!((_ = G.Intl) === null || _ === void 0) && _.DateTimeFormat)
          return new G.Intl.DateTimeFormat().resolvedOptions().timeZone;
      },
      sessionStorage: function() {
        try {
          return !!window.sessionStorage;
        } catch {
          return !0;
        }
      },
      localStorage: function() {
        try {
          return !!window.localStorage;
        } catch {
          return !0;
        }
      },
      indexedDB: function() {
        if (!A() && !P())
          try {
            return !!window.indexedDB;
          } catch {
            return !0;
          }
      },
      openDatabase: function() {
        return !!window.openDatabase;
      },
      cpuClass: function() {
        return navigator.cpuClass;
      },
      platform: function() {
        return navigator.platform;
      },
      plugins: function() {
        if (A())
          return [];
        if (navigator.plugins) {
          for (var _ = [], O = 0; O < navigator.plugins.length; ++O) {
            var w = navigator.plugins[O];
            if (w) {
              for (var K = [], V = 0; V < w.length; ++V) {
                var o = w[V];
                K.push({ type: o.type, suffixes: o.suffixes });
              }
              _.push({ name: w.name, description: w.description, mimeTypes: K });
            }
          }
          return _;
        }
      },
      canvas: function() {
        var _ = function() {
          var V = document.createElement("canvas");
          return V.width = 240, V.height = 140, V.style.display = "inline", [V, V.getContext("2d")];
        }(), O = _[0], w = _[1];
        if (!function(V, o) {
          return !(!o || !V.toDataURL);
        }(O, w))
          return { winding: !1, data: "" };
        w.rect(0, 0, 10, 10), w.rect(2, 2, 6, 6);
        var K = !w.isPointInPath(5, 5, "evenodd");
        return w.textBaseline = "alphabetic", w.fillStyle = "#f60", w.fillRect(125, 1, 62, 20), w.fillStyle = "#069", w.font = "11pt no-real-font-123", w.fillText("Cwm fjordbank ðŸ˜ƒ gly", 2, 15), w.fillStyle = "rgba(102, 204, 0, 0.2)", w.font = "18pt Arial", w.fillText("Cwm fjordbank ðŸ˜ƒ gly", 4, 45), w.globalCompositeOperation = "multiply", w.fillStyle = "rgb(255,0,255)", w.beginPath(), w.arc(50, 50, 50, 0, 2 * Math.PI, !0), w.closePath(), w.fill(), w.fillStyle = "rgb(0,255,255)", w.beginPath(), w.arc(100, 50, 50, 0, 2 * Math.PI, !0), w.closePath(), w.fill(), w.fillStyle = "rgb(255,255,0)", w.beginPath(), w.arc(75, 100, 50, 0, 2 * Math.PI, !0), w.closePath(), w.fill(), w.fillStyle = "rgb(255,0,255)", w.arc(75, 75, 75, 0, 2 * Math.PI, !0), w.arc(75, 75, 25, 0, 2 * Math.PI, !0), w.fill("evenodd"), {
          winding: K,
          data: function(V) {
            return V.toDataURL();
          }(O)
        };
      },
      touchSupport: function() {
        var _, O = 0;
        Q.maxTouchPoints !== void 0 ? O = p(Q.maxTouchPoints) : Q.msMaxTouchPoints !== void 0 && (O = Q.msMaxTouchPoints);
        try {
          document.createEvent("TouchEvent"), _ = !0;
        } catch {
          _ = !1;
        }
        return { maxTouchPoints: O, touchEvent: _, touchStart: "ontouchstart" in oe };
      },
      fonts: function() {
        var _ = H.body, O = H.createElement("div"), w = H.createElement("div"), K = {}, V = {}, o = function() {
          var X = H.createElement("span");
          X.textContent = S;
          for (var ie = 0, de = Object.keys(J); ie < de.length; ie++) {
            var pe = de[ie];
            X.style[pe] = J[pe];
          }
          return X;
        }, g = function(X) {
          return U.some(function(ie, de) {
            return X[de].offsetWidth !== K[ie] || X[de].offsetHeight !== V[ie];
          });
        }, v = U.map(function(X) {
          var ie = o();
          return ie.style.fontFamily = X, O.appendChild(ie), ie;
        });
        _.appendChild(O);
        for (var f = 0, b = U.length; f < b; f++)
          K[U[f]] = v[f].offsetWidth, V[U[f]] = v[f].offsetHeight;
        var I = function() {
          for (var X = {}, ie = function(ge) {
            X[ge] = U.map(function(ye) {
              var he = function(be, we) {
                var me = o();
                return me.style.fontFamily = "'" + be + "'," + we, me;
              }(ge, ye);
              return w.appendChild(he), he;
            });
          }, de = 0, pe = W; de < pe.length; de++)
            ie(pe[de]);
          return X;
        }();
        _.appendChild(w);
        for (var F = [], R = 0, ne = W.length; R < ne; R++)
          g(I[W[R]]) && F.push(W[R]);
        return _.removeChild(w), _.removeChild(O), F;
      },
      audio: function() {
        return c(this, void 0, void 0, function() {
          var _, O, w, K, V, o;
          return l(this, function(g) {
            switch (g.label) {
              case 0:
                if (!(_ = B.OfflineAudioContext || B.webkitOfflineAudioContext))
                  return [2, -2];
                if (j() && !z() && !(k([
                  "DOMRectList" in x,
                  "RTCPeerConnectionIceEvent" in x,
                  "SVGGeometryElement" in x,
                  "ontransitioncancel" in x
                ]) >= 3))
                  return [2, -1];
                O = new _(1, 44100, 44100), (w = O.createOscillator()).type = "triangle", L(O, w.frequency, 1e4), K = O.createDynamicsCompressor(), L(O, K.threshold, -50), L(O, K.knee, 40), L(O, K.ratio, 12), L(O, K.reduction, -20), L(O, K.attack, 0), L(O, K.release, 0.25), w.connect(K), K.connect(O.destination), w.start(0), g.label = 1;
              case 1:
                return g.trys.push([1, 3, 4, 5]), [
                  4,
                  function(v) {
                    return new Promise(function(f, b) {
                      v.oncomplete = function(R) {
                        return f(R.renderedBuffer);
                      };
                      var I = 3, F = function() {
                        switch (v.startRendering(), v.state) {
                          case "running":
                            setTimeout(function() {
                              return b(E("timeout"));
                            }, 1e3);
                            break;
                          case "suspended":
                            T.hidden || I--, I > 0 ? setTimeout(F, 500) : b(E("suspended"));
                        }
                      };
                      F();
                    });
                  }(O)
                ];
              case 2:
                return V = g.sent(), [3, 5];
              case 3:
                if ((o = g.sent()).name === "timeout" || o.name === "suspended")
                  return [2, -3];
                throw o;
              case 4:
                return w.disconnect(), K.disconnect(), [7];
              case 5:
                return [
                  2,
                  function(v) {
                    for (var f = 0, b = 4500; b < 5e3; ++b)
                      f += Math.abs(v[b]);
                    return f;
                  }(V.getChannelData(0))
                ];
            }
          });
        });
      },
      pluginsSupport: function() {
        return navigator.plugins !== void 0;
      },
      productSub: function() {
        return navigator.productSub;
      },
      emptyEvalLength: function() {
        return eval.toString().length;
      },
      errorFF: function() {
        try {
          throw "a";
        } catch (_) {
          try {
            return _.toSource(), !0;
          } catch {
            return !1;
          }
        }
      },
      vendor: function() {
        return navigator.vendor;
      },
      chrome: function() {
        return window.chrome !== void 0;
      },
      cookiesEnabled: function() {
        try {
          Y.cookie = "cookietest=1; SameSite=Strict;";
          var _ = Y.cookie.indexOf("cookietest=") !== -1;
          return Y.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", _;
        } catch {
          return !1;
        }
      }
    };
    function ae(_, O, w) {
      return c(this, void 0, void 0, function() {
        var K, V, o, g, v, f, b, I, F;
        return l(this, function(R) {
          switch (R.label) {
            case 0:
              K = Date.now(), V = {}, o = 0, g = Object.keys(_), R.label = 1;
            case 1:
              if (!(o < g.length))
                return [3, 7];
              if (v = g[o], function(ne, X) {
                for (var ie = 0, de = ne.length; ie < de; ++ie)
                  if (ne[ie] === X)
                    return !0;
                return !1;
              }(w, v))
                return [3, 6];
              f = void 0, R.label = 2;
            case 2:
              return R.trys.push([2, 4, , 5]), F = {}, [4, _[v](O)];
            case 3:
              return F.value = R.sent(), f = F, [3, 5];
            case 4:
              return b = R.sent(), f = b && typeof b == "object" && "message" in b ? { error: b } : { error: { message: b } }, [3, 5];
            case 5:
              I = Date.now(), V[v] = u(u({}, f), { duration: I - K }), K = I, R.label = 6;
            case 6:
              return o++, [3, 1];
            case 7:
              return [2, V];
          }
        });
      });
    }
    function se(_) {
      return JSON.stringify(
        _,
        function(O, w) {
          return w instanceof Error ? u(
            {
              name: (K = w).name,
              message: K.message,
              stack: (V = K.stack) === null || V === void 0 ? void 0 : V.split(`
`)
            },
            K
          ) : w;
          var K, V;
        },
        2
      );
    }
    function le(_) {
      return a(
        function(O) {
          for (var w = "", K = 0, V = Object.keys(O); K < V.length; K++) {
            var o = V[K], g = O[o], v = g.error ? "error" : JSON.stringify(g.value);
            w += (w ? "|" : "") + o.replace(/([:|\\])/g, "\\$1") + ":" + v;
          }
          return w;
        }(_)
      );
    }
    var ee = function() {
      function _() {
      }
      return _.prototype.get = function(O) {
        return O === void 0 && (O = {}), c(this, void 0, void 0, function() {
          var w, K;
          return l(this, function(V) {
            switch (V.label) {
              case 0:
                return [4, ae(te, void 0, [])];
              case 1:
                return w = V.sent(), K = /* @__PURE__ */ function(o) {
                  var g;
                  return {
                    components: o,
                    get visitorId() {
                      return g === void 0 && (g = le(this.components)), g;
                    },
                    set visitorId(v) {
                      g = v;
                    }
                  };
                }(w), O.debug && console.log(
                  `Copy the text below to get the debug data:

\`\`\`
version: 3.0.5
userAgent: ` + navigator.userAgent + `
getOptions: ` + JSON.stringify(O, void 0, 2) + `
visitorId: ` + K.visitorId + `
components: ` + se(w) + "\n```"
                ), [2, K];
            }
          });
        });
      }, _;
    }();
    function ue(_) {
      var O = (_ === void 0 ? {} : _).delayFallback, w = O === void 0 ? 50 : O;
      return c(this, void 0, void 0, function() {
        return l(this, function(K) {
          switch (K.label) {
            case 0:
              return [
                4,
                (V = w, o = 2 * w, o === void 0 && (o = 1 / 0), new Promise(function(g) {
                  d.requestIdleCallback ? d.requestIdleCallback(
                    function() {
                      return g();
                    },
                    { timeout: o }
                  ) : setTimeout(g, Math.min(V, o));
                }))
              ];
            case 1:
              return K.sent(), [2, new ee()];
          }
          var V, o;
        });
      });
    }
    var re = { load: ue, hashComponents: le, componentsToDebugString: se }, ce = a;
    return s.componentsToDebugString = se, s.default = re, s.getComponents = ae, s.hashComponents = le, s.isChromium = D, s.isDesktopSafari = z, s.isEdgeHTML = P, s.isGecko = function() {
      var _;
      return k([
        "buildID" in y,
        ((_ = C.documentElement) === null || _ === void 0 ? void 0 : _.style) && "MozAppearance" in C.documentElement.style,
        "MediaRecorderErrorEvent" in x,
        "mozInnerScreenX" in x,
        "CSSMozDocumentRule" in x,
        "CanvasCaptureMediaStream" in x
      ]) >= 4;
    }, s.isTrident = A, s.isWebKit = j, s.load = ue, s.murmurX64Hash128 = ce, s;
  }({}), function(s) {
    var h, r, t = function(T, L) {
      var E = typeof Symbol == "function" && T[Symbol.iterator];
      if (!E)
        return T;
      var H, S, U = E.call(T), W = [];
      try {
        for (; (L === void 0 || L-- > 0) && !(H = U.next()).done; )
          W.push(H.value);
      } catch (J) {
        S = { error: J };
      } finally {
        try {
          H && !H.done && (E = U.return) && E.call(U);
        } finally {
          if (S)
            throw S.error;
        }
      }
      return W;
    }, e = function(T, L, E) {
      if (E || arguments.length === 2)
        for (var H, S = 0, U = L.length; S < U; S++)
          !H && S in L || (H || (H = Array.prototype.slice.call(L, 0, S)), H[S] = L[S]);
      return T.concat(H || Array.prototype.slice.call(L));
    }, n = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), l = {
      get: function(T, L, E) {
        if (T instanceof IDBTransaction) {
          if (L === "done")
            return i.get(T);
          if (L === "objectStoreNames")
            return T.objectStoreNames || a.get(T);
          if (L === "store")
            return E.objectStoreNames[1] ? void 0 : E.objectStore(E.objectStoreNames[0]);
        }
        return m(T[L]);
      },
      set: function(T, L, E) {
        return T[L] = E, !0;
      },
      has: function(T, L) {
        return T instanceof IDBTransaction && (L === "done" || L === "store") || L in T;
      }
    };
    function d(T) {
      return T !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (r || (r = [
        IDBCursor.prototype.advance,
        IDBCursor.prototype.continue,
        IDBCursor.prototype.continuePrimaryKey
      ])).includes(T) ? function() {
        for (var L = [], E = 0; E < arguments.length; E++)
          L[E] = arguments[E];
        return T.apply(k(this), L), m(n.get(this));
      } : function() {
        for (var L = [], E = 0; E < arguments.length; E++)
          L[E] = arguments[E];
        return m(T.apply(k(this), L));
      } : function(L) {
        for (var E = [], H = 1; H < arguments.length; H++)
          E[H - 1] = arguments[H];
        var S = T.call.apply(T, e([k(this), L], t(E), !1));
        return a.set(S, L.sort ? L.sort() : [L]), m(S);
      };
    }
    function p(T) {
      return typeof T == "function" ? d(T) : (T instanceof IDBTransaction && function(E) {
        if (!i.has(E)) {
          var H = new Promise(function(S, U) {
            var W = function() {
              E.removeEventListener("complete", J), E.removeEventListener("error", Q), E.removeEventListener("abort", Q);
            }, J = function() {
              S(), W();
            }, Q = function() {
              U(E.error || new DOMException("AbortError", "AbortError")), W();
            };
            E.addEventListener("complete", J), E.addEventListener("error", Q), E.addEventListener("abort", Q);
          });
          i.set(E, H);
        }
      }(T), L = T, (h || (h = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])).some(
        function(E) {
          return L instanceof E;
        }
      ) ? new Proxy(T, l) : T);
      var L;
    }
    function m(T) {
      if (T instanceof IDBRequest)
        return L = T, (E = new Promise(function(S, U) {
          var W = function() {
            L.removeEventListener("success", J), L.removeEventListener("error", Q);
          }, J = function() {
            S(m(L.result)), W();
          }, Q = function() {
            U(L.error), W();
          };
          L.addEventListener("success", J), L.addEventListener("error", Q);
        })).then(function(S) {
          S instanceof IDBCursor && n.set(S, L);
        }).catch(function() {
        }), c.set(E, L), E;
      var L, E;
      if (u.has(T))
        return u.get(T);
      var H = p(T);
      return H !== T && (u.set(T, H), c.set(H, T)), H;
    }
    var k = function(T) {
      return c.get(T);
    }, x = function() {
      return (x = Object.assign || function(T) {
        for (var L, E = 1, H = arguments.length; E < H; E++)
          for (var S in L = arguments[E])
            Object.prototype.hasOwnProperty.call(L, S) && (T[S] = L[S]);
        return T;
      }).apply(this, arguments);
    }, y = function(T, L, E, H) {
      return new (E || (E = Promise))(function(S, U) {
        function W(oe) {
          try {
            Q(H.next(oe));
          } catch (q) {
            U(q);
          }
        }
        function J(oe) {
          try {
            Q(H.throw(oe));
          } catch (q) {
            U(q);
          }
        }
        function Q(oe) {
          var q;
          oe.done ? S(oe.value) : (q = oe.value, q instanceof E ? q : new E(function(fe) {
            fe(q);
          })).then(W, J);
        }
        Q((H = H.apply(T, L || [])).next());
      });
    }, C = function(T, L) {
      var E, H, S, U, W = {
        label: 0,
        sent: function() {
          if (1 & S[0])
            throw S[1];
          return S[1];
        },
        trys: [],
        ops: []
      };
      return U = { next: J(0), throw: J(1), return: J(2) }, typeof Symbol == "function" && (U[Symbol.iterator] = function() {
        return this;
      }), U;
      function J(Q) {
        return function(oe) {
          return function(q) {
            if (E)
              throw new TypeError("Generator is already executing.");
            for (; W; )
              try {
                if (E = 1, H && (S = 2 & q[0] ? H.return : q[0] ? H.throw || ((S = H.return) && S.call(H), 0) : H.next) && !(S = S.call(H, q[1])).done)
                  return S;
                switch (H = 0, S && (q = [2 & q[0], S.value]), q[0]) {
                  case 0:
                  case 1:
                    S = q;
                    break;
                  case 4:
                    return W.label++, { value: q[1], done: !1 };
                  case 5:
                    W.label++, H = q[1], q = [0];
                    continue;
                  case 7:
                    q = W.ops.pop(), W.trys.pop();
                    continue;
                  default:
                    if (!((S = (S = W.trys).length > 0 && S[S.length - 1]) || q[0] !== 6 && q[0] !== 2)) {
                      W = 0;
                      continue;
                    }
                    if (q[0] === 3 && (!S || q[1] > S[0] && q[1] < S[3])) {
                      W.label = q[1];
                      break;
                    }
                    if (q[0] === 6 && W.label < S[1]) {
                      W.label = S[1], S = q;
                      break;
                    }
                    if (S && W.label < S[2]) {
                      W.label = S[2], W.ops.push(q);
                      break;
                    }
                    S[2] && W.ops.pop(), W.trys.pop();
                    continue;
                }
                q = L.call(T, W);
              } catch (fe) {
                q = [6, fe], H = 0;
              } finally {
                E = S = 0;
              }
            if (5 & q[0])
              throw q[1];
            return { value: q[0] ? q[1] : void 0, done: !0 };
          }([Q, oe]);
        };
      }
    }, A = function(T, L) {
      var E = typeof Symbol == "function" && T[Symbol.iterator];
      if (!E)
        return T;
      var H, S, U = E.call(T), W = [];
      try {
        for (; (L === void 0 || L-- > 0) && !(H = U.next()).done; )
          W.push(H.value);
      } catch (J) {
        S = { error: J };
      } finally {
        try {
          H && !H.done && (E = U.return) && E.call(U);
        } finally {
          if (S)
            throw S.error;
        }
      }
      return W;
    }, P = function(T, L, E) {
      if (E || arguments.length === 2)
        for (var H, S = 0, U = L.length; S < U; S++)
          !H && S in L || (H || (H = Array.prototype.slice.call(L, 0, S)), H[S] = L[S]);
      return T.concat(H || Array.prototype.slice.call(L));
    }, D = ["get", "getKey", "getAll", "getAllKeys", "count"], j = ["put", "add", "delete", "clear"], z = /* @__PURE__ */ new Map();
    function B(T, L) {
      if (T instanceof IDBDatabase && !(L in T) && typeof L == "string") {
        if (z.get(L))
          return z.get(L);
        var E = L.replace(/FromIndex$/, ""), H = L !== E, S = j.includes(E);
        if (E in (H ? IDBIndex : IDBObjectStore).prototype && (S || D.includes(E))) {
          var U = function(W) {
            for (var J = [], Q = 1; Q < arguments.length; Q++)
              J[Q - 1] = arguments[Q];
            return y(this, void 0, void 0, function() {
              var oe, q, fe;
              return C(this, function(N) {
                switch (N.label) {
                  case 0:
                    return oe = this.transaction(W, S ? "readwrite" : "readonly"), q = oe.store, H && (q = q.index(J.shift())), [4, Promise.all([(fe = q)[E].apply(fe, P([], A(J), !1)), S && oe.done])];
                  case 1:
                    return [2, N.sent()[0]];
                }
              });
            });
          };
          return z.set(L, U), U;
        }
      }
    }
    l = function(T) {
      return x(x({}, T), {
        get: function(L, E, H) {
          return B(L, E) || T.get(L, E, H);
        },
        has: function(L, E) {
          return !!B(L, E) || T.has(L, E);
        }
      });
    }(l), s.deleteDB = function(T, L) {
      var E = (L === void 0 ? {} : L).blocked, H = indexedDB.deleteDatabase(T);
      return E && H.addEventListener("blocked", function(S) {
        return E(S.oldVersion, S);
      }), m(H).then(function() {
      });
    }, s.openDB = function(T, L, E) {
      var H = E === void 0 ? {} : E, S = H.blocked, U = H.upgrade, W = H.blocking, J = H.terminated, Q = indexedDB.open(T, L), oe = m(Q);
      return U && Q.addEventListener("upgradeneeded", function(q) {
        U(m(Q.result), q.oldVersion, q.newVersion, m(Q.transaction), q);
      }), S && Q.addEventListener("blocked", function(q) {
        return S(q.oldVersion, q.newVersion, q);
      }), oe.then(function(q) {
        J && q.addEventListener("close", function() {
          return J();
        }), W && q.addEventListener("versionchange", function(fe) {
          return W(fe.oldVersion, fe.newVersion, fe);
        });
      }).catch(function() {
      }), oe;
    }, s.unwrap = k, s.wrap = m;
  }(M || (M = {})), function(s) {
    function h(r, t) {
      var e;
      t = t || {}, this._id = h._generateUUID(), this._promise = t.promise || Promise, this._frameId = t.frameId || "CrossStorageClient-" + this._id, this._origin = h._getOrigin(r), this._requests = {}, this._connected = !1, this._closed = !1, this._count = 0, this._timeout = t.timeout || 5e3, this._listener = null, this._installListener(), t.frameId && (e = document.getElementById(t.frameId)), e && this._poll(), e = e || this._createFrame(r), this._hub = e.contentWindow;
    }
    h.frameStyle = {
      width: 0,
      height: 0,
      border: "none",
      display: "none",
      position: "absolute",
      top: "-999px",
      left: "-999px"
    }, h._getOrigin = function(r) {
      var t;
      return (t = document.createElement("a")).href = r, t.host || (t = window.location), ((t.protocol && t.protocol !== ":" ? t.protocol : window.location.protocol) + "//" + t.host).replace(/:80$|:443$/, "");
    }, h._generateUUID = function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
        var t = 16 * Math.random() | 0;
        return (r == "x" ? t : 3 & t | 8).toString(16);
      });
    }, h.prototype.onConnect = function() {
      var r = this;
      return this._connected ? this._promise.resolve() : this._closed ? this._promise.reject(new Error("CrossStorageClient has closed")) : (this._requests.connect || (this._requests.connect = []), new this._promise(function(t, e) {
        var n = setTimeout(function() {
          e(new Error("CrossStorageClient could not connect"));
        }, r._timeout);
        r._requests.connect.push(function(i) {
          if (clearTimeout(n), i)
            return e(i);
          t();
        });
      }));
    }, h.prototype.set = function(r, t) {
      return this._request("set", { key: r, value: t });
    }, h.prototype.getSignedPayload = function(r, t) {
      return console.log("sending payload: ", r, " deviceId: ", t), this._request("getSignedData", { payload: r, deviceId: t });
    }, h.prototype.getDeviceDetails = function(r) {
      return this._request("getDeviceDetails", { deviceName: r });
    }, h.prototype.setDeviceDetails = function(r, t) {
      return this._request("setDeviceDetails", { deviceName: r, deviceId: t });
    }, h.prototype.get = function(r) {
      var t = Array.prototype.slice.call(arguments);
      return this._request("get", { keys: t });
    }, h.prototype.del = function() {
      var r = Array.prototype.slice.call(arguments);
      return this._request("del", { keys: r });
    }, h.prototype.clear = function() {
      return this._request("clear");
    }, h.prototype.getKeys = function() {
      return this._request("getKeys");
    }, h.prototype.close = function(r) {
      const t = this._frameId, e = this;
      this._request("close").catch(function(n) {
      }).finally(function() {
        try {
          var n = document.getElementById(t);
          n && !r && n.parentNode.removeChild(n), window.removeEventListener ? window.removeEventListener("message", e._listener, !1) : window.detachEvent("onmessage", e._listener), e._connected = !1, e._closed = !0;
        } catch {
        }
      });
    }, h.prototype._installListener = function() {
      var r = this;
      this._listener = function(t) {
        var e, n, i;
        if (!r._closed && t.data && typeof t.data == "string" && (t.origin === "null" ? "file://" : t.origin) === r._origin)
          if (t.data !== "cross-storage:unavailable") {
            if (t.data.indexOf("cross-storage:") !== -1 && !r._connected) {
              if (r._connected = !0, !r._requests.connect)
                return;
              for (e = 0; e < r._requests.connect.length; e++)
                r._requests.connect[e](n);
              delete r._requests.connect;
            }
            if (t.data !== "cross-storage:ready") {
              try {
                i = JSON.parse(t.data);
              } catch {
                return;
              }
              i.id && r._requests[i.id] && r._requests[i.id](i.error, i.result);
            }
          } else {
            if (r._closed || r.close(), !r._requests.connect)
              return;
            for (n = new Error("Closing client. Could not access localStorage in hub."), e = 0; e < r._requests.connect.length; e++)
              r._requests.connect[e](n);
          }
      }, window.addEventListener ? window.addEventListener("message", this._listener, !1) : window.attachEvent("onmessage", this._listener);
    }, h.prototype._poll = function() {
      var r, t, e;
      e = (r = this)._origin === "file://" ? "*" : r._origin, t = setInterval(function() {
        if (r._connected)
          return clearInterval(t);
        r._hub && r._hub.postMessage("cross-storage:poll", e);
      }, 1e3);
    }, h.prototype._createFrame = function(r) {
      var t, e;
      for (e in (t = window.document.createElement("iframe")).id = this._frameId, h.frameStyle)
        h.frameStyle.hasOwnProperty(e) && (t.style[e] = h.frameStyle[e]);
      return window.document.body.appendChild(t), t.src = r, t;
    }, h.prototype._request = function(r, t) {
      var e, n;
      return this._closed ? this._promise.reject(new Error("CrossStorageClient has closed")) : ((n = this)._count++, e = { id: this._id + ":" + n._count, method: "cross-storage:" + r, params: t }, new this._promise(function(i, a) {
        var u, c, l;
        u = setTimeout(function() {
          n._requests[e.id] && (delete n._requests[e.id], a(new Error("Timeout: could not perform " + e.method)));
        }, n._timeout), n._requests[e.id] = function(d, p) {
          if (clearTimeout(u), delete n._requests[e.id], d)
            return a(new Error(d));
          i(p);
        }, Array.prototype.toJSON && (c = Array.prototype.toJSON, Array.prototype.toJSON = null), l = n._origin === "file://" ? "*" : n._origin, n._hub.postMessage(JSON.stringify(e), l), c && (Array.prototype.toJSON = c);
      }));
    }, s.CrossStorageClient = h;
  }(M || (M = {})), function() {
    typeof Object.assign != "function" && Object.defineProperty(Object, "assign", {
      value: function(s, h) {
        if (s == null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var r = Object(s), t = 1; t < arguments.length; t++) {
          var e = arguments[t];
          if (e != null)
            for (var n in e)
              Object.prototype.hasOwnProperty.call(e, n) && (r[n] = e[n]);
        }
        return r;
      },
      writable: !0,
      configurable: !0
    });
  }(), Array.from || (Array.from = function() {
    var s = Object.prototype.toString, h = function(e) {
      return typeof e == "function" || s.call(e) === "[object Function]";
    }, r = Math.pow(2, 53) - 1, t = function(e) {
      var n = function(i) {
        var a = Number(i);
        return isNaN(a) ? 0 : a !== 0 && isFinite(a) ? (a > 0 ? 1 : -1) * Math.floor(Math.abs(a)) : a;
      }(e);
      return Math.min(Math.max(n, 0), r);
    };
    return function(e) {
      var n = Object(e);
      if (e == null)
        throw new TypeError("Array.from requires an array-like object - not null or undefined");
      var i, a = arguments.length > 1 ? arguments[1] : void 0;
      if (a !== void 0) {
        if (!h(a))
          throw new TypeError(
            "Array.from: when provided, the second argument must be a function"
          );
        arguments.length > 2 && (i = arguments[2]);
      }
      for (var u, c = t(n.length), l = h(this) ? Object(new this(c)) : new Array(c), d = 0; d < c; )
        u = n[d], l[d] = a ? i === void 0 ? a(u, d) : a.call(i, u, d) : u, d += 1;
      return l.length = c, l;
    };
  }()), function() {
    String.prototype.endsWith || (String.prototype.endsWith = function(s, h) {
      return (h === void 0 || h > this.length) && (h = this.length), this.substring(h - s.length, h) === s;
    });
  }(), function() {
    Promise.allSettled = Promise.allSettled || function(s) {
      return Promise.all(
        s.map(function(h) {
          return h.then(function(r) {
            return { status: "fulfilled", value: r };
          }).catch(function(r) {
            return { status: "rejected", reason: r };
          });
        })
      );
    };
  }(), function(s, h) {
    var r = "model", t = "name", e = "type", n = "vendor", i = "version", a = "mobile", u = "tablet", c = "smarttv", l = function(P) {
      for (var D = {}, j = 0; j < P.length; j++)
        D[P[j].toUpperCase()] = P[j];
      return D;
    }, d = function(P, D) {
      return typeof P == "string" && p(D).indexOf(p(P)) !== -1;
    }, p = function(P) {
      return P.toLowerCase();
    }, m = function(P, D) {
      if (typeof P == "string")
        return P = P.replace(/^\s\s*/, "").replace(/\s\s*$/, ""), D === void 0 ? P : P.substring(0, 255);
    }, k = function(P, D) {
      for (var j, z, B, T, L, E, H = 0; H < D.length && !L; ) {
        var S = D[H], U = D[H + 1];
        for (j = z = 0; j < S.length && !L; )
          if (L = S[j++].exec(P))
            for (B = 0; B < U.length; B++)
              E = L[++z], typeof (T = U[B]) == "object" && T.length > 0 ? T.length === 2 ? typeof T[1] == "function" ? this[T[0]] = T[1].call(this, E) : this[T[0]] = T[1] : T.length === 3 ? typeof T[1] != "function" || T[1].exec && T[1].test ? this[T[0]] = E ? E.replace(T[1], T[2]) : void 0 : this[T[0]] = E ? T[1].call(this, E, T[2]) : void 0 : T.length === 4 && (this[T[0]] = E ? T[3].call(this, E.replace(T[1], T[2])) : void 0) : this[T] = E || void 0;
        H += 2;
      }
    }, x = function(P, D) {
      for (var j in D)
        if (typeof D[j] == "object" && D[j].length > 0) {
          for (var z = 0; z < D[j].length; z++)
            if (d(D[j][z], P))
              return j === "?" ? void 0 : j;
        } else if (d(D[j], P))
          return j === "?" ? void 0 : j;
      return P;
    }, y = {
      ME: "4.90",
      "NT 3.11": "NT3.51",
      "NT 4.0": "NT4.0",
      2e3: "NT 5.0",
      XP: ["NT 5.1", "NT 5.2"],
      Vista: "NT 6.0",
      7: "NT 6.1",
      8: "NT 6.2",
      8.1: "NT 6.3",
      10: ["NT 6.4", "NT 10.0"],
      RT: "ARM"
    }, C = {
      browser: [
        [/\b(?:crmo|crios)\/([\w\.]+)/i],
        [i, [t, "Chrome"]],
        [/edg(?:e|ios|a)?\/([\w\.]+)/i],
        [i, [t, "Edge"]],
        [
          /(opera mini)\/([-\w\.]+)/i,
          /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
          /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
        ],
        [t, i],
        [/opios[\/ ]+([\w\.]+)/i],
        [i, [t, "Opera Mini"]],
        [/\bopr\/([\w\.]+)/i],
        [i, [t, "Opera"]],
        [
          /(kindle)\/([\w\.]+)/i,
          /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
          /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
          /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
          /(?:ms|\()(ie) ([\w\.]+)/i,
          /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i,
          /(weibo)__([\d\.]+)/i
        ],
        [t, i],
        [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
        [i, [t, "UCBrowser"]],
        [/\bqbcore\/([\w\.]+)/i],
        [i, [t, "WeChat(Win) Desktop"]],
        [/micromessenger\/([\w\.]+)/i],
        [i, [t, "WeChat"]],
        [/konqueror\/([\w\.]+)/i],
        [i, [t, "Konqueror"]],
        [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
        [i, [t, "IE"]],
        [/yabrowser\/([\w\.]+)/i],
        [i, [t, "Yandex"]],
        [/(avast|avg)\/([\w\.]+)/i],
        [[t, /(.+)/, "$1 Secure Browser"], i],
        [/\bfocus\/([\w\.]+)/i],
        [i, [t, "Firefox Focus"]],
        [/\bopt\/([\w\.]+)/i],
        [i, [t, "Opera Touch"]],
        [/coc_coc\w+\/([\w\.]+)/i],
        [i, [t, "Coc Coc"]],
        [/dolfin\/([\w\.]+)/i],
        [i, [t, "Dolphin"]],
        [/coast\/([\w\.]+)/i],
        [i, [t, "Opera Coast"]],
        [/miuibrowser\/([\w\.]+)/i],
        [i, [t, "MIUI Browser"]],
        [/fxios\/([-\w\.]+)/i],
        [i, [t, "Firefox"]],
        [/\bqihu|(qi?ho?o?|360)browser/i],
        [[t, "360 Browser"]],
        [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i],
        [[t, /(.+)/, "$1 Browser"], i],
        [/(comodo_dragon)\/([\w\.]+)/i],
        [[t, /_/g, " "], i],
        [
          /(electron)\/([\w\.]+) safari/i,
          /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
          /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i
        ],
        [t, i],
        [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i],
        [t],
        [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
        [[t, "Facebook"], i],
        [
          /safari (line)\/([\w\.]+)/i,
          /\b(line)\/([\w\.]+)\/iab/i,
          /(chromium|instagram)[\/ ]([-\w\.]+)/i
        ],
        [t, i],
        [/\bgsa\/([\w\.]+) .*safari\//i],
        [i, [t, "GSA"]],
        [/headlesschrome(?:\/([\w\.]+)| )/i],
        [i, [t, "Chrome Headless"]],
        [/ wv\).+(chrome)\/([\w\.]+)/i],
        [[t, "Chrome WebView"], i],
        [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
        [i, [t, "Android Browser"]],
        [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
        [t, i],
        [/version\/([\w\.]+) .*mobile\/\w+ (safari)/i],
        [i, [t, "Mobile Safari"]],
        [/version\/([\w\.]+) .*(mobile ?safari|safari)/i],
        [i, t],
        [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
        [
          t,
          [
            i,
            x,
            {
              "1.0": "/8",
              1.2: "/1",
              1.3: "/3",
              "2.0": "/412",
              "2.0.2": "/416",
              "2.0.3": "/417",
              "2.0.4": "/419",
              "?": "/"
            }
          ]
        ],
        [/(webkit|khtml)\/([\w\.]+)/i],
        [t, i],
        [/(navigator|netscape\d?)\/([-\w\.]+)/i],
        [[t, "Netscape"], i],
        [/mobile vr; rv:([\w\.]+)\).+firefox/i],
        [i, [t, "Firefox Reality"]],
        [
          /ekiohf.+(flow)\/([\w\.]+)/i,
          /(swiftfox)/i,
          /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
          /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
          /(firefox)\/([\w\.]+)/i,
          /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
          /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
          /(links) \(([\w\.]+)/i
        ],
        [t, i]
      ],
      cpu: [
        [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
        [["architecture", "amd64"]],
        [/(ia32(?=;))/i],
        [["architecture", p]],
        [/((?:i[346]|x)86)[;\)]/i],
        [["architecture", "ia32"]],
        [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
        [["architecture", "arm64"]],
        [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
        [["architecture", "armhf"]],
        [/windows (ce|mobile); ppc;/i],
        [["architecture", "arm"]],
        [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
        [["architecture", /ower/, "", p]],
        [/(sun4\w)[;\)]/i],
        [["architecture", "sparc"]],
        [
          /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
        ],
        [["architecture", p]]
      ],
      device: [
        [/\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],
        [r, [n, "Samsung"], [e, u]],
        [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i],
        [r, [n, "Samsung"], [e, a]],
        [/\((ip(?:hone|od)[\w ]*);/i],
        [r, [n, "Apple"], [e, a]],
        [
          /\((ipad);[-\w\),; ]+apple/i,
          /applecoremedia\/[\w\.]+ \((ipad)/i,
          /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
        ],
        [r, [n, "Apple"], [e, u]],
        [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
        [r, [n, "Huawei"], [e, u]],
        [
          /(?:huawei|honor)([-\w ]+)[;\)]/i,
          /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i
        ],
        [r, [n, "Huawei"], [e, a]],
        [
          /\b(poco[\w ]+)(?: bui|\))/i,
          /\b; (\w+) build\/hm\1/i,
          /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
          /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
          /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
        ],
        [
          [r, /_/g, " "],
          [n, "Xiaomi"],
          [e, a]
        ],
        [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
        [
          [r, /_/g, " "],
          [n, "Xiaomi"],
          [e, u]
        ],
        [
          /; (\w+) bui.+ oppo/i,
          /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
        ],
        [r, [n, "OPPO"], [e, a]],
        [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
        [r, [n, "Vivo"], [e, a]],
        [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
        [r, [n, "Realme"], [e, a]],
        [
          /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
          /\bmot(?:orola)?[- ](\w*)/i,
          /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
        ],
        [r, [n, "Motorola"], [e, a]],
        [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
        [r, [n, "Motorola"], [e, u]],
        [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],
        [r, [n, "LG"], [e, u]],
        [
          /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
          /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
          /\blg-?([\d\w]+) bui/i
        ],
        [r, [n, "LG"], [e, a]],
        [
          /(ideatab[-\w ]+)/i,
          /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
        ],
        [r, [n, "Lenovo"], [e, u]],
        [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i],
        [
          [r, /_/g, " "],
          [n, "Nokia"],
          [e, a]
        ],
        [/(pixel c)\b/i],
        [r, [n, "Google"], [e, u]],
        [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
        [r, [n, "Google"], [e, a]],
        [
          /droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
        ],
        [r, [n, "Sony"], [e, a]],
        [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
        [
          [r, "Xperia Tablet"],
          [n, "Sony"],
          [e, u]
        ],
        [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],
        [r, [n, "OnePlus"], [e, a]],
        [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i],
        [r, [n, "Amazon"], [e, u]],
        [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
        [
          [r, /(.+)/g, "Fire Phone $1"],
          [n, "Amazon"],
          [e, a]
        ],
        [/(playbook);[-\w\),; ]+(rim)/i],
        [r, n, [e, u]],
        [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
        [r, [n, "BlackBerry"], [e, a]],
        [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],
        [r, [n, "ASUS"], [e, u]],
        [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
        [r, [n, "ASUS"], [e, a]],
        [/(nexus 9)/i],
        [r, [n, "HTC"], [e, u]],
        [
          /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
          /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
          /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i
        ],
        [n, [r, /_/g, " "], [e, a]],
        [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
        [r, [n, "Acer"], [e, u]],
        [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
        [r, [n, "Meizu"], [e, a]],
        [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
        [r, [n, "Sharp"], [e, a]],
        [
          /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
          /(hp) ([\w ]+\w)/i,
          /(asus)-?(\w+)/i,
          /(microsoft); (lumia[\w ]+)/i,
          /(lenovo)[-_ ]?([-\w]+)/i,
          /(jolla)/i,
          /(oppo) ?([\w ]+) bui/i
        ],
        [n, r, [e, a]],
        [
          /(archos) (gamepad2?)/i,
          /(hp).+(touchpad(?!.+tablet)|tablet)/i,
          /(kindle)\/([\w\.]+)/i,
          /(nook)[\w ]+build\/(\w+)/i,
          /(dell) (strea[kpr\d ]*[\dko])/i,
          /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
          /(trinity)[- ]*(t\d{3}) bui/i,
          /(gigaset)[- ]+(q\w{1,9}) bui/i,
          /(vodafone) ([\w ]+)(?:\)| bui)/i
        ],
        [n, r, [e, u]],
        [/(surface duo)/i],
        [r, [n, "Microsoft"], [e, u]],
        [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
        [r, [n, "Fairphone"], [e, a]],
        [/(u304aa)/i],
        [r, [n, "AT&T"], [e, a]],
        [/\bsie-(\w*)/i],
        [r, [n, "Siemens"], [e, a]],
        [/\b(rct\w+) b/i],
        [r, [n, "RCA"], [e, u]],
        [/\b(venue[\d ]{2,7}) b/i],
        [r, [n, "Dell"], [e, u]],
        [/\b(q(?:mv|ta)\w+) b/i],
        [r, [n, "Verizon"], [e, u]],
        [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
        [r, [n, "Barnes & Noble"], [e, u]],
        [/\b(tm\d{3}\w+) b/i],
        [r, [n, "NuVision"], [e, u]],
        [/\b(k88) b/i],
        [r, [n, "ZTE"], [e, u]],
        [/\b(nx\d{3}j) b/i],
        [r, [n, "ZTE"], [e, a]],
        [/\b(gen\d{3}) b.+49h/i],
        [r, [n, "Swiss"], [e, a]],
        [/\b(zur\d{3}) b/i],
        [r, [n, "Swiss"], [e, u]],
        [/\b((zeki)?tb.*\b) b/i],
        [r, [n, "Zeki"], [e, u]],
        [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
        [[n, "Dragon Touch"], r, [e, u]],
        [/\b(ns-?\w{0,9}) b/i],
        [r, [n, "Insignia"], [e, u]],
        [/\b((nxa|next)-?\w{0,9}) b/i],
        [r, [n, "NextBook"], [e, u]],
        [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
        [[n, "Voice"], r, [e, a]],
        [/\b(lvtel\-)?(v1[12]) b/i],
        [[n, "LvTel"], r, [e, a]],
        [/\b(ph-1) /i],
        [r, [n, "Essential"], [e, a]],
        [/\b(v(100md|700na|7011|917g).*\b) b/i],
        [r, [n, "Envizen"], [e, u]],
        [/\b(trio[-\w\. ]+) b/i],
        [r, [n, "MachSpeed"], [e, u]],
        [/\btu_(1491) b/i],
        [r, [n, "Rotor"], [e, u]],
        [/(shield[\w ]+) b/i],
        [r, [n, "Nvidia"], [e, u]],
        [/(sprint) (\w+)/i],
        [n, r, [e, a]],
        [/(kin\.[onetw]{3})/i],
        [
          [r, /\./g, " "],
          [n, "Microsoft"],
          [e, a]
        ],
        [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
        [r, [n, "Zebra"], [e, u]],
        [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
        [r, [n, "Zebra"], [e, a]],
        [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
        [n, r, [e, "console"]],
        [/droid.+; (shield) bui/i],
        [r, [n, "Nvidia"], [e, "console"]],
        [/(playstation [345portablevi]+)/i],
        [r, [n, "Sony"], [e, "console"]],
        [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
        [r, [n, "Microsoft"], [e, "console"]],
        [/smart-tv.+(samsung)/i],
        [n, [e, c]],
        [/hbbtv.+maple;(\d+)/i],
        [
          [r, /^/, "SmartTV"],
          [n, "Samsung"],
          [e, c]
        ],
        [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
        [
          [n, "LG"],
          [e, c]
        ],
        [/(apple) ?tv/i],
        [n, [r, "Apple TV"], [e, c]],
        [/crkey/i],
        [
          [r, "Chromecast"],
          [n, "Google"],
          [e, c]
        ],
        [/droid.+aft(\w)( bui|\))/i],
        [r, [n, "Amazon"], [e, c]],
        [/\(dtv[\);].+(aquos)/i],
        [r, [n, "Sharp"], [e, c]],
        [
          /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
          /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i
        ],
        [
          [n, m],
          [r, m],
          [e, c]
        ],
        [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
        [[e, c]],
        [/((pebble))app/i],
        [n, r, [e, "wearable"]],
        [/droid.+; (glass) \d/i],
        [r, [n, "Google"], [e, "wearable"]],
        [/droid.+; (wt63?0{2,3})\)/i],
        [r, [n, "Zebra"], [e, "wearable"]],
        [/(quest( 2)?)/i],
        [r, [n, "Facebook"], [e, "wearable"]],
        [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
        [n, [e, "embedded"]],
        [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
        [r, [e, a]],
        [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
        [r, [e, u]],
        [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
        [[e, u]],
        [/(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i],
        [[e, a]],
        [/(android[-\w\. ]{0,9});.+buil/i],
        [r, [n, "Generic"]]
      ],
      engine: [
        [/windows.+ edge\/([\w\.]+)/i],
        [i, [t, "EdgeHTML"]],
        [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
        [i, [t, "Blink"]],
        [
          /(presto)\/([\w\.]+)/i,
          /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
          /ekioh(flow)\/([\w\.]+)/i,
          /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
          /(icab)[\/ ]([23]\.[\d\.]+)/i
        ],
        [t, i],
        [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
        [i, t]
      ],
      os: [
        [/microsoft (windows) (vista|xp)/i],
        [t, i],
        [
          /(windows) nt 6\.2; (arm)/i,
          /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
          /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
        ],
        [t, [i, x, y]],
        [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
        [
          [t, "Windows"],
          [i, x, y]
        ],
        [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i],
        [
          [i, /_/g, "."],
          [t, "iOS"]
        ],
        [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i],
        [
          [t, "Mac OS"],
          [i, /_/g, "."]
        ],
        [/droid ([\w\.]+)\b.+(android[- ]x86)/i],
        [i, t],
        [
          /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
          /(blackberry)\w*\/([\w\.]*)/i,
          /(tizen|kaios)[\/ ]([\w\.]+)/i,
          /\((series40);/i
        ],
        [t, i],
        [/\(bb(10);/i],
        [i, [t, "BlackBerry"]],
        [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
        [i, [t, "Symbian"]],
        [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],
        [i, [t, "Firefox OS"]],
        [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
        [i, [t, "webOS"]],
        [/crkey\/([\d\.]+)/i],
        [i, [t, "Chromecast"]],
        [/(cros) [\w]+ ([\w\.]+\w)/i],
        [[t, "Chromium OS"], i],
        [
          /(nintendo|playstation) ([wids345portablevuch]+)/i,
          /(xbox); +xbox ([^\);]+)/i,
          /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
          /(mint)[\/\(\) ]?(\w*)/i,
          /(mageia|vectorlinux)[; ]/i,
          /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
          /(hurd|linux) ?([\w\.]*)/i,
          /(gnu) ?([\w\.]*)/i,
          /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
          /(haiku) (\w+)/i
        ],
        [t, i],
        [/(sunos) ?([\w\.\d]*)/i],
        [[t, "Solaris"], i],
        [
          /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
          /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
          /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
          /(unix) ?([\w\.]*)/i
        ],
        [t, i]
      ]
    }, A = function(P, D) {
      if (typeof P == "object" && (D = P, P = void 0), !(this instanceof A))
        return new A(P, D).getResult();
      var j = P || (typeof window < "u" && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : ""), z = D ? function(B, T) {
        var L = {};
        for (var E in B)
          T[E] && T[E].length % 2 == 0 ? L[E] = T[E].concat(B[E]) : L[E] = B[E];
        return L;
      }(C, D) : C;
      return this.getBrowser = function() {
        var B, T = {};
        return T.name = void 0, T.version = void 0, k.call(T, j, z.browser), T.major = typeof (B = T.version) == "string" ? B.replace(/[^\d\.]/g, "").split(".")[0] : void 0, T;
      }, this.getCPU = function() {
        var B = { architecture: void 0 };
        return k.call(B, j, z.cpu), B;
      }, this.getDevice = function() {
        var B = { vendor: void 0, model: void 0, type: void 0 };
        return k.call(B, j, z.device), B;
      }, this.getEngine = function() {
        var B = { name: void 0, version: void 0 };
        return k.call(B, j, z.engine), B;
      }, this.getOS = function() {
        var B = { name: void 0, version: void 0 };
        return k.call(B, j, z.os), B;
      }, this.getResult = function() {
        return {
          ua: this.getUA(),
          browser: this.getBrowser(),
          engine: this.getEngine(),
          os: this.getOS(),
          device: this.getDevice(),
          cpu: this.getCPU()
        };
      }, this.getUA = function() {
        return j;
      }, this.setUA = function(B) {
        return j = typeof B == "string" && B.length > 255 ? m(B, 255) : B, this;
      }, this.setUA(j), this;
    };
    A.VERSION = "1.0.2", A.BROWSER = l([t, i, "major"]), A.CPU = l(["architecture"]), A.DEVICE = l([r, n, e, "console", a, c, u, "wearable", "embedded"]), A.ENGINE = A.OS = l([t, i]), s.UAParser = A;
  }(M || (M = {})), (M || (M = {})).pako = function s(h, r, t) {
    function e(a, u) {
      if (!r[a]) {
        if (!h[a]) {
          var c = typeof commonjsRequire == "function" && commonjsRequire;
          if (!u && c)
            return c(a, !0);
          if (n)
            return n(a, !0);
          var l = new Error("Cannot find module '" + a + "'");
          throw l.code = "MODULE_NOT_FOUND", l;
        }
        var d = r[a] = { exports: {} };
        h[a][0].call(
          d.exports,
          function(p) {
            var m = h[a][1][p];
            return e(m || p);
          },
          d,
          d.exports,
          s,
          h,
          r,
          t
        );
      }
      return r[a].exports;
    }
    for (var n = typeof commonjsRequire == "function" && commonjsRequire, i = 0; i < t.length; i++)
      e(t[i]);
    return e;
  }(
    {
      1: [
        function(s, h, r) {
          function t(a, u) {
            return Object.prototype.hasOwnProperty.call(a, u);
          }
          var e = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
          r.assign = function(a) {
            for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
              var c = u.shift();
              if (c) {
                if (typeof c != "object")
                  throw new TypeError(c + "must be non-object");
                for (var l in c)
                  t(c, l) && (a[l] = c[l]);
              }
            }
            return a;
          }, r.shrinkBuf = function(a, u) {
            return a.length === u ? a : a.subarray ? a.subarray(0, u) : (a.length = u, a);
          };
          var n = {
            arraySet: function(a, u, c, l, d) {
              if (u.subarray && a.subarray)
                a.set(u.subarray(c, c + l), d);
              else
                for (var p = 0; p < l; p++)
                  a[d + p] = u[c + p];
            },
            flattenChunks: function(a) {
              var u, c, l, d, p, m;
              for (l = 0, u = 0, c = a.length; u < c; u++)
                l += a[u].length;
              for (m = new Uint8Array(l), d = 0, u = 0, c = a.length; u < c; u++)
                p = a[u], m.set(p, d), d += p.length;
              return m;
            }
          }, i = {
            arraySet: function(a, u, c, l, d) {
              for (var p = 0; p < l; p++)
                a[d + p] = u[c + p];
            },
            flattenChunks: function(a) {
              return [].concat.apply([], a);
            }
          };
          r.setTyped = function(a) {
            a ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, n)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, i));
          }, r.setTyped(e);
        },
        {}
      ],
      2: [
        function(s, h, r) {
          function t(c, l) {
            if (l < 65537 && (c.subarray && i || !c.subarray && n))
              return String.fromCharCode.apply(null, e.shrinkBuf(c, l));
            for (var d = "", p = 0; p < l; p++)
              d += String.fromCharCode(c[p]);
            return d;
          }
          var e = s("./common"), n = !0, i = !0;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch {
            n = !1;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch {
            i = !1;
          }
          for (var a = new e.Buf8(256), u = 0; u < 256; u++)
            a[u] = u >= 252 ? 6 : u >= 248 ? 5 : u >= 240 ? 4 : u >= 224 ? 3 : u >= 192 ? 2 : 1;
          a[254] = a[254] = 1, r.string2buf = function(c) {
            var l, d, p, m, k, x = c.length, y = 0;
            for (m = 0; m < x; m++)
              (64512 & (d = c.charCodeAt(m))) == 55296 && m + 1 < x && (64512 & (p = c.charCodeAt(m + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (p - 56320), m++), y += d < 128 ? 1 : d < 2048 ? 2 : d < 65536 ? 3 : 4;
            for (l = new e.Buf8(y), k = 0, m = 0; k < y; m++)
              (64512 & (d = c.charCodeAt(m))) == 55296 && m + 1 < x && (64512 & (p = c.charCodeAt(m + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (p - 56320), m++), d < 128 ? l[k++] = d : d < 2048 ? (l[k++] = 192 | d >>> 6, l[k++] = 128 | 63 & d) : d < 65536 ? (l[k++] = 224 | d >>> 12, l[k++] = 128 | d >>> 6 & 63, l[k++] = 128 | 63 & d) : (l[k++] = 240 | d >>> 18, l[k++] = 128 | d >>> 12 & 63, l[k++] = 128 | d >>> 6 & 63, l[k++] = 128 | 63 & d);
            return l;
          }, r.buf2binstring = function(c) {
            return t(c, c.length);
          }, r.binstring2buf = function(c) {
            for (var l = new e.Buf8(c.length), d = 0, p = l.length; d < p; d++)
              l[d] = c.charCodeAt(d);
            return l;
          }, r.buf2string = function(c, l) {
            var d, p, m, k, x = l || c.length, y = new Array(2 * x);
            for (p = 0, d = 0; d < x; )
              if ((m = c[d++]) < 128)
                y[p++] = m;
              else if ((k = a[m]) > 4)
                y[p++] = 65533, d += k - 1;
              else {
                for (m &= k === 2 ? 31 : k === 3 ? 15 : 7; k > 1 && d < x; )
                  m = m << 6 | 63 & c[d++], k--;
                k > 1 ? y[p++] = 65533 : m < 65536 ? y[p++] = m : (m -= 65536, y[p++] = 55296 | m >> 10 & 1023, y[p++] = 56320 | 1023 & m);
              }
            return t(y, p);
          }, r.utf8border = function(c, l) {
            var d;
            for ((l = l || c.length) > c.length && (l = c.length), d = l - 1; d >= 0 && (192 & c[d]) == 128; )
              d--;
            return d < 0 || d === 0 ? l : d + a[c[d]] > l ? d : l;
          };
        },
        { "./common": 1 }
      ],
      3: [
        function(s, h, r) {
          h.exports = function(t, e, n, i) {
            for (var a = 65535 & t | 0, u = t >>> 16 & 65535 | 0, c = 0; n !== 0; ) {
              n -= c = n > 2e3 ? 2e3 : n;
              do
                u = u + (a = a + e[i++] | 0) | 0;
              while (--c);
              a %= 65521, u %= 65521;
            }
            return a | u << 16 | 0;
          };
        },
        {}
      ],
      4: [
        function(s, h, r) {
          var t = function() {
            for (var e, n = [], i = 0; i < 256; i++) {
              e = i;
              for (var a = 0; a < 8; a++)
                e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
              n[i] = e;
            }
            return n;
          }();
          h.exports = function(e, n, i, a) {
            var u = t, c = a + i;
            e ^= -1;
            for (var l = a; l < c; l++)
              e = e >>> 8 ^ u[255 & (e ^ n[l])];
            return -1 ^ e;
          };
        },
        {}
      ],
      5: [
        function(s, h, r) {
          function t(o, g) {
            return o.msg = H[g], g;
          }
          function e(o) {
            return (o << 1) - (o > 4 ? 9 : 0);
          }
          function n(o) {
            for (var g = o.length; --g >= 0; )
              o[g] = 0;
          }
          function i(o) {
            var g = o.state, v = g.pending;
            v > o.avail_out && (v = o.avail_out), v !== 0 && (B.arraySet(o.output, g.pending_buf, g.pending_out, v, o.next_out), o.next_out += v, g.pending_out += v, o.total_out += v, o.avail_out -= v, g.pending -= v, g.pending === 0 && (g.pending_out = 0));
          }
          function a(o, g) {
            T._tr_flush_block(
              o,
              o.block_start >= 0 ? o.block_start : -1,
              o.strstart - o.block_start,
              g
            ), o.block_start = o.strstart, i(o.strm);
          }
          function u(o, g) {
            o.pending_buf[o.pending++] = g;
          }
          function c(o, g) {
            o.pending_buf[o.pending++] = g >>> 8 & 255, o.pending_buf[o.pending++] = 255 & g;
          }
          function l(o, g, v, f) {
            var b = o.avail_in;
            return b > f && (b = f), b === 0 ? 0 : (o.avail_in -= b, B.arraySet(g, o.input, o.next_in, b, v), o.state.wrap === 1 ? o.adler = L(o.adler, g, b, v) : o.state.wrap === 2 && (o.adler = E(o.adler, g, b, v)), o.next_in += b, o.total_in += b, b);
          }
          function d(o, g) {
            var v, f, b = o.max_chain_length, I = o.strstart, F = o.prev_length, R = o.nice_match, ne = o.strstart > o.w_size - re ? o.strstart - (o.w_size - re) : 0, X = o.window, ie = o.w_mask, de = o.prev, pe = o.strstart + ue, ge = X[I + F - 1], ye = X[I + F];
            o.prev_length >= o.good_match && (b >>= 2), R > o.lookahead && (R = o.lookahead);
            do
              if (X[(v = g) + F] === ye && X[v + F - 1] === ge && X[v] === X[I] && X[++v] === X[I + 1]) {
                I += 2, v++;
                do
                  ;
                while (X[++I] === X[++v] && X[++I] === X[++v] && X[++I] === X[++v] && X[++I] === X[++v] && X[++I] === X[++v] && X[++I] === X[++v] && X[++I] === X[++v] && X[++I] === X[++v] && I < pe);
                if (f = ue - (pe - I), I = pe - ue, f > F) {
                  if (o.match_start = g, F = f, f >= R)
                    break;
                  ge = X[I + F - 1], ye = X[I + F];
                }
              }
            while ((g = de[g & ie]) > ne && --b != 0);
            return F <= o.lookahead ? F : o.lookahead;
          }
          function p(o) {
            var g, v, f, b, I, F = o.w_size;
            do {
              if (b = o.window_size - o.lookahead - o.strstart, o.strstart >= F + (F - re)) {
                B.arraySet(o.window, o.window, F, F, 0), o.match_start -= F, o.strstart -= F, o.block_start -= F, g = v = o.hash_size;
                do
                  f = o.head[--g], o.head[g] = f >= F ? f - F : 0;
                while (--v);
                g = v = F;
                do
                  f = o.prev[--g], o.prev[g] = f >= F ? f - F : 0;
                while (--v);
                b += F;
              }
              if (o.strm.avail_in === 0)
                break;
              if (v = l(o.strm, o.window, o.strstart + o.lookahead, b), o.lookahead += v, o.lookahead + o.insert >= ee)
                for (I = o.strstart - o.insert, o.ins_h = o.window[I], o.ins_h = (o.ins_h << o.hash_shift ^ o.window[I + 1]) & o.hash_mask; o.insert && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[I + ee - 1]) & o.hash_mask, o.prev[I & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = I, I++, o.insert--, !(o.lookahead + o.insert < ee)); )
                  ;
            } while (o.lookahead < re && o.strm.avail_in !== 0);
          }
          function m(o, g) {
            for (var v, f; ; ) {
              if (o.lookahead < re) {
                if (p(o), o.lookahead < re && g === S)
                  return O;
                if (o.lookahead === 0)
                  break;
              }
              if (v = 0, o.lookahead >= ee && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + ee - 1]) & o.hash_mask, v = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart), v !== 0 && o.strstart - v <= o.w_size - re && (o.match_length = d(o, v)), o.match_length >= ee)
                if (f = T._tr_tally(o, o.strstart - o.match_start, o.match_length - ee), o.lookahead -= o.match_length, o.match_length <= o.max_lazy_match && o.lookahead >= ee) {
                  o.match_length--;
                  do
                    o.strstart++, o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + ee - 1]) & o.hash_mask, v = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart;
                  while (--o.match_length != 0);
                  o.strstart++;
                } else
                  o.strstart += o.match_length, o.match_length = 0, o.ins_h = o.window[o.strstart], o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + 1]) & o.hash_mask;
              else
                f = T._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++;
              if (f && (a(o, !1), o.strm.avail_out === 0))
                return O;
            }
            return o.insert = o.strstart < ee - 1 ? o.strstart : ee - 1, g === U ? (a(o, !0), o.strm.avail_out === 0 ? K : V) : o.last_lit && (a(o, !1), o.strm.avail_out === 0) ? O : w;
          }
          function k(o, g) {
            for (var v, f, b; ; ) {
              if (o.lookahead < re) {
                if (p(o), o.lookahead < re && g === S)
                  return O;
                if (o.lookahead === 0)
                  break;
              }
              if (v = 0, o.lookahead >= ee && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + ee - 1]) & o.hash_mask, v = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart), o.prev_length = o.match_length, o.prev_match = o.match_start, o.match_length = ee - 1, v !== 0 && o.prev_length < o.max_lazy_match && o.strstart - v <= o.w_size - re && (o.match_length = d(o, v), o.match_length <= 5 && (o.strategy === oe || o.match_length === ee && o.strstart - o.match_start > 4096) && (o.match_length = ee - 1)), o.prev_length >= ee && o.match_length <= o.prev_length) {
                b = o.strstart + o.lookahead - ee, f = T._tr_tally(o, o.strstart - 1 - o.prev_match, o.prev_length - ee), o.lookahead -= o.prev_length - 1, o.prev_length -= 2;
                do
                  ++o.strstart <= b && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + ee - 1]) & o.hash_mask, v = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart);
                while (--o.prev_length != 0);
                if (o.match_available = 0, o.match_length = ee - 1, o.strstart++, f && (a(o, !1), o.strm.avail_out === 0))
                  return O;
              } else if (o.match_available) {
                if ((f = T._tr_tally(o, 0, o.window[o.strstart - 1])) && a(o, !1), o.strstart++, o.lookahead--, o.strm.avail_out === 0)
                  return O;
              } else
                o.match_available = 1, o.strstart++, o.lookahead--;
            }
            return o.match_available && (f = T._tr_tally(o, 0, o.window[o.strstart - 1]), o.match_available = 0), o.insert = o.strstart < ee - 1 ? o.strstart : ee - 1, g === U ? (a(o, !0), o.strm.avail_out === 0 ? K : V) : o.last_lit && (a(o, !1), o.strm.avail_out === 0) ? O : w;
          }
          function x(o, g) {
            for (var v, f, b, I, F = o.window; ; ) {
              if (o.lookahead <= ue) {
                if (p(o), o.lookahead <= ue && g === S)
                  return O;
                if (o.lookahead === 0)
                  break;
              }
              if (o.match_length = 0, o.lookahead >= ee && o.strstart > 0 && (b = o.strstart - 1, (f = F[b]) === F[++b] && f === F[++b] && f === F[++b])) {
                I = o.strstart + ue;
                do
                  ;
                while (f === F[++b] && f === F[++b] && f === F[++b] && f === F[++b] && f === F[++b] && f === F[++b] && f === F[++b] && f === F[++b] && b < I);
                o.match_length = ue - (I - b), o.match_length > o.lookahead && (o.match_length = o.lookahead);
              }
              if (o.match_length >= ee ? (v = T._tr_tally(o, 1, o.match_length - ee), o.lookahead -= o.match_length, o.strstart += o.match_length, o.match_length = 0) : (v = T._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++), v && (a(o, !1), o.strm.avail_out === 0))
                return O;
            }
            return o.insert = 0, g === U ? (a(o, !0), o.strm.avail_out === 0 ? K : V) : o.last_lit && (a(o, !1), o.strm.avail_out === 0) ? O : w;
          }
          function y(o, g) {
            for (var v; ; ) {
              if (o.lookahead === 0 && (p(o), o.lookahead === 0)) {
                if (g === S)
                  return O;
                break;
              }
              if (o.match_length = 0, v = T._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++, v && (a(o, !1), o.strm.avail_out === 0))
                return O;
            }
            return o.insert = 0, g === U ? (a(o, !0), o.strm.avail_out === 0 ? K : V) : o.last_lit && (a(o, !1), o.strm.avail_out === 0) ? O : w;
          }
          function C(o, g, v, f, b) {
            this.good_length = o, this.max_lazy = g, this.nice_length = v, this.max_chain = f, this.func = b;
          }
          function A() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = N, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new B.Buf16(2 * se), this.dyn_dtree = new B.Buf16(2 * (2 * te + 1)), this.bl_tree = new B.Buf16(2 * (2 * ae + 1)), n(this.dyn_ltree), n(this.dyn_dtree), n(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new B.Buf16(le + 1), this.heap = new B.Buf16(2 * Y + 1), n(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new B.Buf16(2 * Y + 1), n(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
          }
          function P(o) {
            var g;
            return o && o.state ? (o.total_in = o.total_out = 0, o.data_type = fe, (g = o.state).pending = 0, g.pending_out = 0, g.wrap < 0 && (g.wrap = -g.wrap), g.status = g.wrap ? ce : _, o.adler = g.wrap === 2 ? 0 : 1, g.last_flush = S, T._tr_init(g), W) : t(o, J);
          }
          function D(o) {
            var g = P(o);
            return g === W && function(v) {
              v.window_size = 2 * v.w_size, n(v.head), v.max_lazy_match = z[v.level].max_lazy, v.good_match = z[v.level].good_length, v.nice_match = z[v.level].nice_length, v.max_chain_length = z[v.level].max_chain, v.strstart = 0, v.block_start = 0, v.lookahead = 0, v.insert = 0, v.match_length = v.prev_length = ee - 1, v.match_available = 0, v.ins_h = 0;
            }(o.state), g;
          }
          function j(o, g, v, f, b, I) {
            if (!o)
              return J;
            var F = 1;
            if (g === Q && (g = 6), f < 0 ? (F = 0, f = -f) : f > 15 && (F = 2, f -= 16), b < 1 || b > G || v !== N || f < 8 || f > 15 || g < 0 || g > 9 || I < 0 || I > q)
              return t(o, J);
            f === 8 && (f = 9);
            var R = new A();
            return o.state = R, R.strm = o, R.wrap = F, R.gzhead = null, R.w_bits = f, R.w_size = 1 << R.w_bits, R.w_mask = R.w_size - 1, R.hash_bits = b + 7, R.hash_size = 1 << R.hash_bits, R.hash_mask = R.hash_size - 1, R.hash_shift = ~~((R.hash_bits + ee - 1) / ee), R.window = new B.Buf8(2 * R.w_size), R.head = new B.Buf16(R.hash_size), R.prev = new B.Buf16(R.w_size), R.lit_bufsize = 1 << b + 6, R.pending_buf_size = 4 * R.lit_bufsize, R.pending_buf = new B.Buf8(R.pending_buf_size), R.d_buf = 1 * R.lit_bufsize, R.l_buf = 3 * R.lit_bufsize, R.level = g, R.strategy = I, R.method = v, D(o);
          }
          var z, B = s("../utils/common"), T = s("./trees"), L = s("./adler32"), E = s("./crc32"), H = s("./messages"), S = 0, U = 4, W = 0, J = -2, Q = -1, oe = 1, q = 4, fe = 2, N = 8, G = 9, Y = 286, te = 30, ae = 19, se = 2 * Y + 1, le = 15, ee = 3, ue = 258, re = ue + ee + 1, ce = 42, _ = 113, O = 1, w = 2, K = 3, V = 4;
          z = [
            new C(0, 0, 0, 0, function(o, g) {
              var v = 65535;
              for (v > o.pending_buf_size - 5 && (v = o.pending_buf_size - 5); ; ) {
                if (o.lookahead <= 1) {
                  if (p(o), o.lookahead === 0 && g === S)
                    return O;
                  if (o.lookahead === 0)
                    break;
                }
                o.strstart += o.lookahead, o.lookahead = 0;
                var f = o.block_start + v;
                if ((o.strstart === 0 || o.strstart >= f) && (o.lookahead = o.strstart - f, o.strstart = f, a(o, !1), o.strm.avail_out === 0) || o.strstart - o.block_start >= o.w_size - re && (a(o, !1), o.strm.avail_out === 0))
                  return O;
              }
              return o.insert = 0, g === U ? (a(o, !0), o.strm.avail_out === 0 ? K : V) : (o.strstart > o.block_start && (a(o, !1), o.strm.avail_out), O);
            }),
            new C(4, 4, 8, 4, m),
            new C(4, 5, 16, 8, m),
            new C(4, 6, 32, 32, m),
            new C(4, 4, 16, 16, k),
            new C(8, 16, 32, 32, k),
            new C(8, 16, 128, 128, k),
            new C(8, 32, 128, 256, k),
            new C(32, 128, 258, 1024, k),
            new C(32, 258, 258, 4096, k)
          ], r.deflateInit = function(o, g) {
            return j(o, g, N, 15, 8, 0);
          }, r.deflateInit2 = j, r.deflateReset = D, r.deflateResetKeep = P, r.deflateSetHeader = function(o, g) {
            return o && o.state ? o.state.wrap !== 2 ? J : (o.state.gzhead = g, W) : J;
          }, r.deflate = function(o, g) {
            var v, f, b, I;
            if (!o || !o.state || g > 5 || g < 0)
              return o ? t(o, J) : J;
            if (f = o.state, !o.output || !o.input && o.avail_in !== 0 || f.status === 666 && g !== U)
              return t(o, o.avail_out === 0 ? -5 : J);
            if (f.strm = o, v = f.last_flush, f.last_flush = g, f.status === ce)
              if (f.wrap === 2)
                o.adler = 0, u(f, 31), u(f, 139), u(f, 8), f.gzhead ? (u(
                  f,
                  (f.gzhead.text ? 1 : 0) + (f.gzhead.hcrc ? 2 : 0) + (f.gzhead.extra ? 4 : 0) + (f.gzhead.name ? 8 : 0) + (f.gzhead.comment ? 16 : 0)
                ), u(f, 255 & f.gzhead.time), u(f, f.gzhead.time >> 8 & 255), u(f, f.gzhead.time >> 16 & 255), u(f, f.gzhead.time >> 24 & 255), u(f, f.level === 9 ? 2 : f.strategy >= 2 || f.level < 2 ? 4 : 0), u(f, 255 & f.gzhead.os), f.gzhead.extra && f.gzhead.extra.length && (u(f, 255 & f.gzhead.extra.length), u(f, f.gzhead.extra.length >> 8 & 255)), f.gzhead.hcrc && (o.adler = E(o.adler, f.pending_buf, f.pending, 0)), f.gzindex = 0, f.status = 69) : (u(f, 0), u(f, 0), u(f, 0), u(f, 0), u(f, 0), u(f, f.level === 9 ? 2 : f.strategy >= 2 || f.level < 2 ? 4 : 0), u(f, 3), f.status = _);
              else {
                var F = N + (f.w_bits - 8 << 4) << 8;
                F |= (f.strategy >= 2 || f.level < 2 ? 0 : f.level < 6 ? 1 : f.level === 6 ? 2 : 3) << 6, f.strstart !== 0 && (F |= 32), F += 31 - F % 31, f.status = _, c(f, F), f.strstart !== 0 && (c(f, o.adler >>> 16), c(f, 65535 & o.adler)), o.adler = 1;
              }
            if (f.status === 69)
              if (f.gzhead.extra) {
                for (b = f.pending; f.gzindex < (65535 & f.gzhead.extra.length) && (f.pending !== f.pending_buf_size || (f.gzhead.hcrc && f.pending > b && (o.adler = E(o.adler, f.pending_buf, f.pending - b, b)), i(o), b = f.pending, f.pending !== f.pending_buf_size)); )
                  u(f, 255 & f.gzhead.extra[f.gzindex]), f.gzindex++;
                f.gzhead.hcrc && f.pending > b && (o.adler = E(o.adler, f.pending_buf, f.pending - b, b)), f.gzindex === f.gzhead.extra.length && (f.gzindex = 0, f.status = 73);
              } else
                f.status = 73;
            if (f.status === 73)
              if (f.gzhead.name) {
                b = f.pending;
                do {
                  if (f.pending === f.pending_buf_size && (f.gzhead.hcrc && f.pending > b && (o.adler = E(o.adler, f.pending_buf, f.pending - b, b)), i(o), b = f.pending, f.pending === f.pending_buf_size)) {
                    I = 1;
                    break;
                  }
                  I = f.gzindex < f.gzhead.name.length ? 255 & f.gzhead.name.charCodeAt(f.gzindex++) : 0, u(f, I);
                } while (I !== 0);
                f.gzhead.hcrc && f.pending > b && (o.adler = E(o.adler, f.pending_buf, f.pending - b, b)), I === 0 && (f.gzindex = 0, f.status = 91);
              } else
                f.status = 91;
            if (f.status === 91)
              if (f.gzhead.comment) {
                b = f.pending;
                do {
                  if (f.pending === f.pending_buf_size && (f.gzhead.hcrc && f.pending > b && (o.adler = E(o.adler, f.pending_buf, f.pending - b, b)), i(o), b = f.pending, f.pending === f.pending_buf_size)) {
                    I = 1;
                    break;
                  }
                  I = f.gzindex < f.gzhead.comment.length ? 255 & f.gzhead.comment.charCodeAt(f.gzindex++) : 0, u(f, I);
                } while (I !== 0);
                f.gzhead.hcrc && f.pending > b && (o.adler = E(o.adler, f.pending_buf, f.pending - b, b)), I === 0 && (f.status = 103);
              } else
                f.status = 103;
            if (f.status === 103 && (f.gzhead.hcrc ? (f.pending + 2 > f.pending_buf_size && i(o), f.pending + 2 <= f.pending_buf_size && (u(f, 255 & o.adler), u(f, o.adler >> 8 & 255), o.adler = 0, f.status = _)) : f.status = _), f.pending !== 0) {
              if (i(o), o.avail_out === 0)
                return f.last_flush = -1, W;
            } else if (o.avail_in === 0 && e(g) <= e(v) && g !== U)
              return t(o, -5);
            if (f.status === 666 && o.avail_in !== 0)
              return t(o, -5);
            if (o.avail_in !== 0 || f.lookahead !== 0 || g !== S && f.status !== 666) {
              var R = f.strategy === 2 ? y(f, g) : f.strategy === 3 ? x(f, g) : z[f.level].func(f, g);
              if (R !== K && R !== V || (f.status = 666), R === O || R === K)
                return o.avail_out === 0 && (f.last_flush = -1), W;
              if (R === w && (g === 1 ? T._tr_align(f) : g !== 5 && (T._tr_stored_block(f, 0, 0, !1), g === 3 && (n(f.head), f.lookahead === 0 && (f.strstart = 0, f.block_start = 0, f.insert = 0))), i(o), o.avail_out === 0))
                return f.last_flush = -1, W;
            }
            return g !== U ? W : f.wrap <= 0 ? 1 : (f.wrap === 2 ? (u(f, 255 & o.adler), u(f, o.adler >> 8 & 255), u(f, o.adler >> 16 & 255), u(f, o.adler >> 24 & 255), u(f, 255 & o.total_in), u(f, o.total_in >> 8 & 255), u(f, o.total_in >> 16 & 255), u(f, o.total_in >> 24 & 255)) : (c(f, o.adler >>> 16), c(f, 65535 & o.adler)), i(o), f.wrap > 0 && (f.wrap = -f.wrap), f.pending !== 0 ? W : 1);
          }, r.deflateEnd = function(o) {
            var g;
            return o && o.state ? (g = o.state.status) !== ce && g !== 69 && g !== 73 && g !== 91 && g !== 103 && g !== _ && g !== 666 ? t(o, J) : (o.state = null, g === _ ? t(o, -3) : W) : J;
          }, r.deflateSetDictionary = function(o, g) {
            var v, f, b, I, F, R, ne, X, ie = g.length;
            if (!o || !o.state || (v = o.state, (I = v.wrap) === 2 || I === 1 && v.status !== ce || v.lookahead))
              return J;
            for (I === 1 && (o.adler = L(o.adler, g, ie, 0)), v.wrap = 0, ie >= v.w_size && (I === 0 && (n(v.head), v.strstart = 0, v.block_start = 0, v.insert = 0), X = new B.Buf8(v.w_size), B.arraySet(X, g, ie - v.w_size, v.w_size, 0), g = X, ie = v.w_size), F = o.avail_in, R = o.next_in, ne = o.input, o.avail_in = ie, o.next_in = 0, o.input = g, p(v); v.lookahead >= ee; ) {
              f = v.strstart, b = v.lookahead - (ee - 1);
              do
                v.ins_h = (v.ins_h << v.hash_shift ^ v.window[f + ee - 1]) & v.hash_mask, v.prev[f & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = f, f++;
              while (--b);
              v.strstart = f, v.lookahead = ee - 1, p(v);
            }
            return v.strstart += v.lookahead, v.block_start = v.strstart, v.insert = v.lookahead, v.lookahead = 0, v.match_length = v.prev_length = ee - 1, v.match_available = 0, o.next_in = R, o.input = ne, o.avail_in = F, v.wrap = I, W;
          }, r.deflateInfo = "pako deflate (from Nodeca project)";
        },
        { "../utils/common": 1, "./adler32": 3, "./crc32": 4, "./messages": 6, "./trees": 7 }
      ],
      6: [
        function(s, h, r) {
          h.exports = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
          };
        },
        {}
      ],
      7: [
        function(s, h, r) {
          function t(o) {
            for (var g = o.length; --g >= 0; )
              o[g] = 0;
          }
          function e(o, g, v, f, b) {
            this.static_tree = o, this.extra_bits = g, this.extra_base = v, this.elems = f, this.max_length = b, this.has_stree = o && o.length;
          }
          function n(o, g) {
            this.dyn_tree = o, this.max_code = 0, this.stat_desc = g;
          }
          function i(o) {
            return o < 256 ? ue[o] : ue[256 + (o >>> 7)];
          }
          function a(o, g) {
            o.pending_buf[o.pending++] = 255 & g, o.pending_buf[o.pending++] = g >>> 8 & 255;
          }
          function u(o, g, v) {
            o.bi_valid > Q - v ? (o.bi_buf |= g << o.bi_valid & 65535, a(o, o.bi_buf), o.bi_buf = g >> Q - o.bi_valid, o.bi_valid += v - Q) : (o.bi_buf |= g << o.bi_valid & 65535, o.bi_valid += v);
          }
          function c(o, g, v) {
            u(o, v[2 * g], v[2 * g + 1]);
          }
          function l(o, g) {
            var v = 0;
            do
              v |= 1 & o, o >>>= 1, v <<= 1;
            while (--g > 0);
            return v >>> 1;
          }
          function d(o, g, v) {
            var f, b, I = new Array(J + 1), F = 0;
            for (f = 1; f <= J; f++)
              I[f] = F = F + v[f - 1] << 1;
            for (b = 0; b <= g; b++) {
              var R = o[2 * b + 1];
              R !== 0 && (o[2 * b] = l(I[R]++, R));
            }
          }
          function p(o) {
            var g;
            for (g = 0; g < H; g++)
              o.dyn_ltree[2 * g] = 0;
            for (g = 0; g < S; g++)
              o.dyn_dtree[2 * g] = 0;
            for (g = 0; g < U; g++)
              o.bl_tree[2 * g] = 0;
            o.dyn_ltree[2 * q] = 1, o.opt_len = o.static_len = 0, o.last_lit = o.matches = 0;
          }
          function m(o) {
            o.bi_valid > 8 ? a(o, o.bi_buf) : o.bi_valid > 0 && (o.pending_buf[o.pending++] = o.bi_buf), o.bi_buf = 0, o.bi_valid = 0;
          }
          function k(o, g, v, f) {
            var b = 2 * g, I = 2 * v;
            return o[b] < o[I] || o[b] === o[I] && f[g] <= f[v];
          }
          function x(o, g, v) {
            for (var f = o.heap[v], b = v << 1; b <= o.heap_len && (b < o.heap_len && k(g, o.heap[b + 1], o.heap[b], o.depth) && b++, !k(g, f, o.heap[b], o.depth)); )
              o.heap[v] = o.heap[b], v = b, b <<= 1;
            o.heap[v] = f;
          }
          function y(o, g, v) {
            var f, b, I, F, R = 0;
            if (o.last_lit !== 0)
              do
                f = o.pending_buf[o.d_buf + 2 * R] << 8 | o.pending_buf[o.d_buf + 2 * R + 1], b = o.pending_buf[o.l_buf + R], R++, f === 0 ? c(o, b, g) : (c(o, (I = re[b]) + E + 1, g), (F = Y[I]) !== 0 && u(o, b -= ce[I], F), c(o, I = i(--f), v), (F = te[I]) !== 0 && u(o, f -= _[I], F));
              while (R < o.last_lit);
            c(o, q, g);
          }
          function C(o, g) {
            var v, f, b, I = g.dyn_tree, F = g.stat_desc.static_tree, R = g.stat_desc.has_stree, ne = g.stat_desc.elems, X = -1;
            for (o.heap_len = 0, o.heap_max = W, v = 0; v < ne; v++)
              I[2 * v] !== 0 ? (o.heap[++o.heap_len] = X = v, o.depth[v] = 0) : I[2 * v + 1] = 0;
            for (; o.heap_len < 2; )
              I[2 * (b = o.heap[++o.heap_len] = X < 2 ? ++X : 0)] = 1, o.depth[b] = 0, o.opt_len--, R && (o.static_len -= F[2 * b + 1]);
            for (g.max_code = X, v = o.heap_len >> 1; v >= 1; v--)
              x(o, I, v);
            b = ne;
            do
              v = o.heap[1], o.heap[1] = o.heap[o.heap_len--], x(o, I, 1), f = o.heap[1], o.heap[--o.heap_max] = v, o.heap[--o.heap_max] = f, I[2 * b] = I[2 * v] + I[2 * f], o.depth[b] = (o.depth[v] >= o.depth[f] ? o.depth[v] : o.depth[f]) + 1, I[2 * v + 1] = I[2 * f + 1] = b, o.heap[1] = b++, x(o, I, 1);
            while (o.heap_len >= 2);
            o.heap[--o.heap_max] = o.heap[1], function(ie, de) {
              var pe, ge, ye, he, be, we, me = de.dyn_tree, Ae = de.max_code, Ie = de.stat_desc.static_tree, Oe = de.stat_desc.has_stree, Pe = de.stat_desc.extra_bits, Te = de.stat_desc.extra_base, Ee = de.stat_desc.max_length, Se = 0;
              for (he = 0; he <= J; he++)
                ie.bl_count[he] = 0;
              for (me[2 * ie.heap[ie.heap_max] + 1] = 0, pe = ie.heap_max + 1; pe < W; pe++)
                (he = me[2 * me[2 * (ge = ie.heap[pe]) + 1] + 1] + 1) > Ee && (he = Ee, Se++), me[2 * ge + 1] = he, ge > Ae || (ie.bl_count[he]++, be = 0, ge >= Te && (be = Pe[ge - Te]), we = me[2 * ge], ie.opt_len += we * (he + be), Oe && (ie.static_len += we * (Ie[2 * ge + 1] + be)));
              if (Se !== 0) {
                do {
                  for (he = Ee - 1; ie.bl_count[he] === 0; )
                    he--;
                  ie.bl_count[he]--, ie.bl_count[he + 1] += 2, ie.bl_count[Ee]--, Se -= 2;
                } while (Se > 0);
                for (he = Ee; he !== 0; he--)
                  for (ge = ie.bl_count[he]; ge !== 0; )
                    (ye = ie.heap[--pe]) > Ae || (me[2 * ye + 1] !== he && (ie.opt_len += (he - me[2 * ye + 1]) * me[2 * ye], me[2 * ye + 1] = he), ge--);
              }
            }(o, g), d(I, X, o.bl_count);
          }
          function A(o, g, v) {
            var f, b, I = -1, F = g[1], R = 0, ne = 7, X = 4;
            for (F === 0 && (ne = 138, X = 3), g[2 * (v + 1) + 1] = 65535, f = 0; f <= v; f++)
              b = F, F = g[2 * (f + 1) + 1], ++R < ne && b === F || (R < X ? o.bl_tree[2 * b] += R : b !== 0 ? (b !== I && o.bl_tree[2 * b]++, o.bl_tree[2 * fe]++) : R <= 10 ? o.bl_tree[2 * N]++ : o.bl_tree[2 * G]++, R = 0, I = b, F === 0 ? (ne = 138, X = 3) : b === F ? (ne = 6, X = 3) : (ne = 7, X = 4));
          }
          function P(o, g, v) {
            var f, b, I = -1, F = g[1], R = 0, ne = 7, X = 4;
            for (F === 0 && (ne = 138, X = 3), f = 0; f <= v; f++)
              if (b = F, F = g[2 * (f + 1) + 1], !(++R < ne && b === F)) {
                if (R < X)
                  do
                    c(o, b, o.bl_tree);
                  while (--R != 0);
                else
                  b !== 0 ? (b !== I && (c(o, b, o.bl_tree), R--), c(o, fe, o.bl_tree), u(o, R - 3, 2)) : R <= 10 ? (c(o, N, o.bl_tree), u(o, R - 3, 3)) : (c(o, G, o.bl_tree), u(o, R - 11, 7));
                R = 0, I = b, F === 0 ? (ne = 138, X = 3) : b === F ? (ne = 6, X = 3) : (ne = 7, X = 4);
              }
          }
          function D(o, g, v, f) {
            u(o, (T << 1) + (f ? 1 : 0), 3), function(b, I, F, R) {
              m(b), R && (a(b, F), a(b, ~F)), j.arraySet(b.pending_buf, b.window, I, F, b.pending), b.pending += F;
            }(o, g, v, !0);
          }
          var j = s("../utils/common"), z = 0, B = 1, T = 0, L = 29, E = 256, H = E + 1 + L, S = 30, U = 19, W = 2 * H + 1, J = 15, Q = 16, oe = 7, q = 256, fe = 16, N = 17, G = 18, Y = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
            5,
            5,
            5,
            5,
            0
          ], te = [
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            4,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            8,
            8,
            9,
            9,
            10,
            10,
            11,
            11,
            12,
            12,
            13,
            13
          ], ae = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], se = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], le = new Array(2 * (H + 2));
          t(le);
          var ee = new Array(2 * S);
          t(ee);
          var ue = new Array(512);
          t(ue);
          var re = new Array(256);
          t(re);
          var ce = new Array(L);
          t(ce);
          var _ = new Array(S);
          t(_);
          var O, w, K, V = !1;
          r._tr_init = function(o) {
            V || (function() {
              var g, v, f, b, I, F = new Array(J + 1);
              for (f = 0, b = 0; b < L - 1; b++)
                for (ce[b] = f, g = 0; g < 1 << Y[b]; g++)
                  re[f++] = b;
              for (re[f - 1] = b, I = 0, b = 0; b < 16; b++)
                for (_[b] = I, g = 0; g < 1 << te[b]; g++)
                  ue[I++] = b;
              for (I >>= 7; b < S; b++)
                for (_[b] = I << 7, g = 0; g < 1 << te[b] - 7; g++)
                  ue[256 + I++] = b;
              for (v = 0; v <= J; v++)
                F[v] = 0;
              for (g = 0; g <= 143; )
                le[2 * g + 1] = 8, g++, F[8]++;
              for (; g <= 255; )
                le[2 * g + 1] = 9, g++, F[9]++;
              for (; g <= 279; )
                le[2 * g + 1] = 7, g++, F[7]++;
              for (; g <= 287; )
                le[2 * g + 1] = 8, g++, F[8]++;
              for (d(le, H + 1, F), g = 0; g < S; g++)
                ee[2 * g + 1] = 5, ee[2 * g] = l(g, 5);
              O = new e(le, Y, E + 1, H, J), w = new e(ee, te, 0, S, J), K = new e(new Array(0), ae, 0, U, oe);
            }(), V = !0), o.l_desc = new n(o.dyn_ltree, O), o.d_desc = new n(o.dyn_dtree, w), o.bl_desc = new n(o.bl_tree, K), o.bi_buf = 0, o.bi_valid = 0, p(o);
          }, r._tr_stored_block = D, r._tr_flush_block = function(o, g, v, f) {
            var b, I, F = 0;
            o.level > 0 ? (o.strm.data_type === 2 && (o.strm.data_type = function(R) {
              var ne, X = 4093624447;
              for (ne = 0; ne <= 31; ne++, X >>>= 1)
                if (1 & X && R.dyn_ltree[2 * ne] !== 0)
                  return z;
              if (R.dyn_ltree[18] !== 0 || R.dyn_ltree[20] !== 0 || R.dyn_ltree[26] !== 0)
                return B;
              for (ne = 32; ne < E; ne++)
                if (R.dyn_ltree[2 * ne] !== 0)
                  return B;
              return z;
            }(o)), C(o, o.l_desc), C(o, o.d_desc), F = function(R) {
              var ne;
              for (A(R, R.dyn_ltree, R.l_desc.max_code), A(R, R.dyn_dtree, R.d_desc.max_code), C(R, R.bl_desc), ne = U - 1; ne >= 3 && R.bl_tree[2 * se[ne] + 1] === 0; ne--)
                ;
              return R.opt_len += 3 * (ne + 1) + 5 + 5 + 4, ne;
            }(o), b = o.opt_len + 3 + 7 >>> 3, (I = o.static_len + 3 + 7 >>> 3) <= b && (b = I)) : b = I = v + 5, v + 4 <= b && g !== -1 ? D(o, g, v, f) : o.strategy === 4 || I === b ? (u(o, 2 + (f ? 1 : 0), 3), y(o, le, ee)) : (u(o, 4 + (f ? 1 : 0), 3), function(R, ne, X, ie) {
              var de;
              for (u(R, ne - 257, 5), u(R, X - 1, 5), u(R, ie - 4, 4), de = 0; de < ie; de++)
                u(R, R.bl_tree[2 * se[de] + 1], 3);
              P(R, R.dyn_ltree, ne - 1), P(R, R.dyn_dtree, X - 1);
            }(o, o.l_desc.max_code + 1, o.d_desc.max_code + 1, F + 1), y(o, o.dyn_ltree, o.dyn_dtree)), p(o), f && m(o);
          }, r._tr_tally = function(o, g, v) {
            return o.pending_buf[o.d_buf + 2 * o.last_lit] = g >>> 8 & 255, o.pending_buf[o.d_buf + 2 * o.last_lit + 1] = 255 & g, o.pending_buf[o.l_buf + o.last_lit] = 255 & v, o.last_lit++, g === 0 ? o.dyn_ltree[2 * v]++ : (o.matches++, g--, o.dyn_ltree[2 * (re[v] + E + 1)]++, o.dyn_dtree[2 * i(g)]++), o.last_lit === o.lit_bufsize - 1;
          }, r._tr_align = function(o) {
            u(o, 2, 3), c(o, q, le), function(g) {
              g.bi_valid === 16 ? (a(g, g.bi_buf), g.bi_buf = 0, g.bi_valid = 0) : g.bi_valid >= 8 && (g.pending_buf[g.pending++] = 255 & g.bi_buf, g.bi_buf >>= 8, g.bi_valid -= 8);
            }(o);
          };
        },
        { "../utils/common": 1 }
      ],
      8: [
        function(s, h, r) {
          h.exports = function() {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
          };
        },
        {}
      ],
      "/lib/deflate.js": [
        function(s, h, r) {
          function t(x) {
            if (!(this instanceof t))
              return new t(x);
            this.options = i.assign(
              {
                level: p,
                method: k,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: m,
                to: ""
              },
              x || {}
            );
            var y = this.options;
            y.raw && y.windowBits > 0 ? y.windowBits = -y.windowBits : y.gzip && y.windowBits > 0 && y.windowBits < 16 && (y.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
            var C = n.deflateInit2(
              this.strm,
              y.level,
              y.method,
              y.windowBits,
              y.memLevel,
              y.strategy
            );
            if (C !== d)
              throw new Error(u[C]);
            if (y.header && n.deflateSetHeader(this.strm, y.header), y.dictionary) {
              var A;
              if (A = typeof y.dictionary == "string" ? a.string2buf(y.dictionary) : l.call(y.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(y.dictionary) : y.dictionary, (C = n.deflateSetDictionary(this.strm, A)) !== d)
                throw new Error(u[C]);
              this._dict_set = !0;
            }
          }
          function e(x, y) {
            var C = new t(y);
            if (C.push(x, !0), C.err)
              throw C.msg || u[C.err];
            return C.result;
          }
          var n = s("./zlib/deflate"), i = s("./utils/common"), a = s("./utils/strings"), u = s("./zlib/messages"), c = s("./zlib/zstream"), l = Object.prototype.toString, d = 0, p = -1, m = 0, k = 8;
          t.prototype.push = function(x, y) {
            var C, A, P = this.strm, D = this.options.chunkSize;
            if (this.ended)
              return !1;
            A = y === ~~y ? y : y === !0 ? 4 : 0, typeof x == "string" ? P.input = a.string2buf(x) : l.call(x) === "[object ArrayBuffer]" ? P.input = new Uint8Array(x) : P.input = x, P.next_in = 0, P.avail_in = P.input.length;
            do {
              if (P.avail_out === 0 && (P.output = new i.Buf8(D), P.next_out = 0, P.avail_out = D), (C = n.deflate(P, A)) !== 1 && C !== d)
                return this.onEnd(C), this.ended = !0, !1;
              P.avail_out !== 0 && (P.avail_in !== 0 || A !== 4 && A !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(i.shrinkBuf(P.output, P.next_out))) : this.onData(i.shrinkBuf(P.output, P.next_out)));
            } while ((P.avail_in > 0 || P.avail_out === 0) && C !== 1);
            return A === 4 ? (C = n.deflateEnd(this.strm), this.onEnd(C), this.ended = !0, C === d) : A !== 2 || (this.onEnd(d), P.avail_out = 0, !0);
          }, t.prototype.onData = function(x) {
            this.chunks.push(x);
          }, t.prototype.onEnd = function(x) {
            x === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
          }, r.Deflate = t, r.deflate = e, r.deflateRaw = function(x, y) {
            return (y = y || {}).raw = !0, e(x, y);
          }, r.gzip = function(x, y) {
            return (y = y || {}).gzip = !0, e(x, y);
          };
        },
        {
          "./utils/common": 1,
          "./utils/strings": 2,
          "./zlib/deflate": 5,
          "./zlib/messages": 6,
          "./zlib/zstream": 8
        }
      ]
    },
    {},
    []
  )("/lib/deflate.js"), (M || (M = {})).evaluateModernizr = function() {
    (function(s, h, r, t) {
      function e(N, G) {
        return typeof N === G;
      }
      function n() {
        return typeof r.createElement != "function" ? r.createElement(arguments[0]) : j ? r.createElementNS.call(r, "http://www.w3.org/2000/svg", arguments[0]) : r.createElement.apply(r, arguments);
      }
      function i(N, G) {
        return !!~("" + N).indexOf(G);
      }
      function a(N, G, Y, te) {
        var ae, se, le, ee, ue = "modernizr", re = n("div"), ce = function() {
          var _ = r.body;
          return _ || ((_ = n(j ? "svg" : "body")).fake = !0), _;
        }();
        if (parseInt(Y, 10))
          for (; Y--; )
            (le = n("div")).id = te ? te[Y] : ue + (Y + 1), re.appendChild(le);
        return (ae = n("style")).type = "text/css", ae.id = "s" + ue, (ce.fake ? ce : re).appendChild(ae), ce.appendChild(re), ae.styleSheet ? ae.styleSheet.cssText = N : ae.appendChild(r.createTextNode(N)), re.id = ue, ce.fake && (ce.style.background = "", ce.style.overflow = "hidden", ee = D.style.overflow, D.style.overflow = "hidden", D.appendChild(ce)), se = G(re, N), ce.fake ? (ce.parentNode.removeChild(ce), D.style.overflow = ee, D.offsetHeight) : re.parentNode.removeChild(re), !!se;
      }
      function u(N) {
        return N.replace(/([A-Z])/g, function(G, Y) {
          return "-" + Y.toLowerCase();
        }).replace(/^ms-/, "-ms-");
      }
      function c(N, G, Y) {
        var te;
        if ("getComputedStyle" in h) {
          te = getComputedStyle.call(h, N, G);
          var ae = h.console;
          te !== null ? Y && (te = te.getPropertyValue(Y)) : ae && ae[ae.error ? "error" : "log"].call(
            ae,
            "getComputedStyle returning null, its possible modernizr test results are inaccurate"
          );
        } else
          te = !G && N.currentStyle && N.currentStyle[Y];
        return te;
      }
      function l(N, G) {
        var Y = N.length;
        if ("CSS" in h && "supports" in h.CSS) {
          for (; Y--; )
            if (h.CSS.supports(u(N[Y]), G))
              return !0;
          return !1;
        }
        if ("CSSSupportsRule" in h) {
          for (var te = []; Y--; )
            te.push("(" + u(N[Y]) + ":" + G + ")");
          return a(
            "@supports (" + (te = te.join(" or ")) + ") { #modernizr { position: absolute; } }",
            function(ae) {
              return c(ae, null, "position") === "absolute";
            }
          );
        }
        return t;
      }
      function d(N) {
        return N.replace(/([a-z])-([a-z])/g, function(G, Y, te) {
          return Y + te.toUpperCase();
        }).replace(/^-/, "");
      }
      function p(N, G, Y, te) {
        function ae() {
          le && (delete E.style, delete E.modElem);
        }
        if (te = !e(te, "undefined") && te, !e(Y, "undefined")) {
          var se = l(N, Y);
          if (!e(se, "undefined"))
            return se;
        }
        for (var le, ee, ue, re, ce, _ = ["modernizr", "tspan", "samp"]; !E.style && _.length; )
          le = !0, E.modElem = n(_.shift()), E.style = E.modElem.style;
        for (ue = N.length, ee = 0; ee < ue; ee++)
          if (re = N[ee], ce = E.style[re], i(re, "-") && (re = d(re)), E.style[re] !== t) {
            if (te || e(Y, "undefined"))
              return ae(), G !== "pfx" || re;
            try {
              E.style[re] = Y;
            } catch {
            }
            if (E.style[re] !== ce)
              return ae(), G !== "pfx" || re;
          }
        return ae(), !1;
      }
      function m(N, G) {
        return function() {
          return N.apply(G, arguments);
        };
      }
      function k(N, G, Y, te, ae) {
        var se = N.charAt(0).toUpperCase() + N.slice(1), le = (N + " " + T.join(se + " ") + se).split(" ");
        return e(G, "string") || e(G, "undefined") ? p(le, G, te, ae) : function(ee, ue, re) {
          var ce;
          for (var _ in ee)
            if (ee[_] in ue)
              return re === !1 ? ee[_] : e(ce = ue[ee[_]], "function") ? m(ce, re || ue) : ce;
          return !1;
        }(le = (N + " " + H.join(se + " ") + se).split(" "), G, Y);
      }
      function x(N, G, Y) {
        return k(N, t, t, G, Y);
      }
      var y = [], C = {
        _version: "3.11.1",
        _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 },
        _q: [],
        on: function(N, G) {
          var Y = this;
          setTimeout(function() {
            G(Y[N]);
          }, 0);
        },
        addTest: function(N, G, Y) {
          y.push({ name: N, fn: G, options: Y });
        },
        addAsyncTest: function(N) {
          y.push({ name: null, fn: N });
        }
      }, A = function() {
      };
      A.prototype = C, A = new A();
      var P = [], D = r.documentElement, j = D.nodeName.toLowerCase() === "svg", z = function() {
        var N = !("onblur" in D);
        return function(G, Y) {
          var te;
          return !!G && (Y && typeof Y != "string" || (Y = n(Y || "div")), !(te = (G = "on" + G) in Y) && N && (Y.setAttribute || (Y = n("div")), Y.setAttribute(G, ""), te = typeof Y[G] == "function", Y[G] !== t && (Y[G] = t), Y.removeAttribute(G)), te);
        };
      }();
      C.hasEvent = z, A.addTest("ambientlight", z("devicelight", h)), A.addTest("applicationcache", "applicationCache" in h), function() {
        var N = n("audio");
        A.addTest("audio", function() {
          var G = !1;
          try {
            (G = !!N.canPlayType) && (G = new Boolean(G));
          } catch {
          }
          return G;
        });
        try {
          N.canPlayType && (A.addTest(
            "audio.ogg",
            N.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")
          ), A.addTest(
            "audio.mp3",
            N.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, "")
          ), A.addTest(
            "audio.opus",
            N.canPlayType('audio/ogg; codecs="opus"') || N.canPlayType('audio/webm; codecs="opus"').replace(/^no$/, "")
          ), A.addTest("audio.wav", N.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "")), A.addTest(
            "audio.m4a",
            (N.canPlayType("audio/x-m4a;") || N.canPlayType("audio/aac;")).replace(
              /^no$/,
              ""
            )
          ));
        } catch {
        }
      }();
      var B = "Moz O ms Webkit", T = C._config.usePrefixes ? B.split(" ") : [];
      C._cssomPrefixes = T;
      var L = { elem: n("modernizr") };
      A._q.push(function() {
        delete L.elem;
      });
      var E = { style: L.elem.style };
      A._q.unshift(function() {
        delete E.style;
      });
      var H = C._config.usePrefixes ? B.toLowerCase().split(" ") : [];
      C._domPrefixes = H, C.testAllProps = k;
      var S = function(N) {
        var G, Y = Q.length, te = h.CSSRule;
        if (te === void 0)
          return t;
        if (!N)
          return !1;
        if ((G = (N = N.replace(/^@/, "")).replace(/-/g, "_").toUpperCase() + "_RULE") in te)
          return "@" + N;
        for (var ae = 0; ae < Y; ae++) {
          var se = Q[ae];
          if (se.toUpperCase() + "_" + G in te)
            return "@-" + se.toLowerCase() + "-" + N;
        }
        return !1;
      };
      C.atRule = S;
      var U = C.prefixed = function(N, G, Y) {
        return N.indexOf("@") === 0 ? S(N) : (N.indexOf("-") !== -1 && (N = d(N)), G ? k(N, G, Y) : k(N, "pfx"));
      };
      A.addTest("batteryapi", !!U("battery", navigator) || !!U("getBattery", navigator), {
        aliases: ["battery-api"]
      }), A.addTest(
        "blobconstructor",
        function() {
          try {
            return !!new Blob();
          } catch {
            return !1;
          }
        },
        { aliases: ["blob-constructor"] }
      ), A.addTest("contextmenu", "contextMenu" in D && "HTMLMenuItemElement" in h), A.addTest("cors", "XMLHttpRequest" in h && "withCredentials" in new XMLHttpRequest());
      var W = U("crypto", h);
      A.addTest("crypto", !!U("subtle", W)), A.addTest("customelements", "customElements" in h), A.addTest("customprotocolhandler", function() {
        if (!navigator.registerProtocolHandler)
          return !1;
        try {
          navigator.registerProtocolHandler("thisShouldFail");
        } catch (N) {
          return N instanceof TypeError;
        }
        return !1;
      }), A.addTest("customevent", "CustomEvent" in h && typeof h.CustomEvent == "function"), A.addTest("dart", !!U("startDart", navigator)), A.addTest(
        "dataview",
        typeof DataView < "u" && "getFloat64" in DataView.prototype
      ), A.addTest("eventlistener", "addEventListener" in h), A.addTest("forcetouch", function() {
        return !!z(U("mouseforcewillbegin", h, !1), h) && MouseEvent.WEBKIT_FORCE_AT_MOUSE_DOWN && MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN;
      }), A.addTest("fullscreen", !(!U("exitFullscreen", r, !1) && !U("cancelFullScreen", r, !1))), A.addTest("gamepads", !!U("getGamepads", navigator)), A.addTest("geolocation", "geolocation" in navigator), A.addTest("ie8compat", !h.addEventListener && !!r.documentMode && r.documentMode === 7), A.addTest("intl", !!U("Intl", h)), A.addTest("json", "JSON" in h && "parse" in JSON && "stringify" in JSON), C.testAllProps = x, A.addTest("ligatures", x("fontFeatureSettings", '"liga" 1')), A.addTest("messagechannel", "MessageChannel" in h), A.addTest("notification", function() {
        if (!h.Notification || !h.Notification.requestPermission)
          return !1;
        if (h.Notification.permission === "granted")
          return !0;
        try {
          new h.Notification("");
        } catch (N) {
          if (N.name === "TypeError")
            return !1;
        }
        return !0;
      }), A.addTest("pagevisibility", !!U("hidden", r, !1)), A.addTest("performance", !!U("performance", h));
      var J = [""].concat(H);
      C._domPrefixesAll = J, A.addTest("pointerevents", function() {
        for (var N = 0, G = J.length; N < G; N++)
          if (z(J[N] + "pointerdown"))
            return !0;
        return !1;
      }), A.addTest("pointerlock", !!U("exitPointerLock", r)), A.addTest("queryselector", "querySelector" in r && "querySelectorAll" in r), A.addTest("quotamanagement", function() {
        var N = U("temporaryStorage", navigator), G = U("persistentStorage", navigator);
        return !(!N || !G);
      }), A.addTest("requestanimationframe", !!U("requestAnimationFrame", h), { aliases: ["raf"] }), A.addTest("serviceworker", "serviceWorker" in navigator);
      var Q = C._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];
      C._prefixes = Q;
      var oe = function() {
        var N = h.matchMedia || h.msMatchMedia;
        return N ? function(G) {
          var Y = N(G);
          return Y && Y.matches || !1;
        } : function(G) {
          var Y = !1;
          return a("@media " + G + " { #modernizr { position: absolute; } }", function(te) {
            Y = c(te, null, "position") === "absolute";
          }), Y;
        };
      }();
      C.mq = oe, A.addTest("touchevents", function() {
        if ("ontouchstart" in h || h.TouchEvent || h.DocumentTouch && r instanceof DocumentTouch)
          return !0;
        var N = ["(", Q.join("touch-enabled),("), "heartz", ")"].join("");
        return oe(N);
      }), A.addTest("typedarrays", "ArrayBuffer" in h), A.addTest("vibrate", !!U("vibrate", navigator)), function() {
        var N = n("video");
        A.addTest("video", function() {
          var G = !1;
          try {
            (G = !!N.canPlayType) && (G = new Boolean(G));
          } catch {
          }
          return G;
        });
        try {
          N.canPlayType && (A.addTest(
            "video.ogg",
            N.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "")
          ), A.addTest(
            "video.h264",
            N.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "")
          ), A.addTest(
            "video.h265",
            N.canPlayType('video/mp4; codecs="hev1"').replace(/^no$/, "")
          ), A.addTest(
            "video.webm",
            N.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "")
          ), A.addTest(
            "video.vp9",
            N.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "")
          ), A.addTest(
            "video.hls",
            N.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "")
          ), A.addTest(
            "video.av1",
            N.canPlayType('video/mp4; codecs="av01"').replace(/^no$/, "")
          ));
        } catch {
        }
      }(), A.addTest("webgl", function() {
        return "WebGLRenderingContext" in h;
      });
      var q = !1;
      try {
        q = "WebSocket" in h && h.WebSocket.CLOSING === 2;
      } catch {
      }
      A.addTest("websockets", q), A.addTest("xdomainrequest", "XDomainRequest" in h), A.addTest("matchmedia", !!U("matchMedia", h)), function() {
        var N, G, Y, te, ae, se;
        for (var le in y)
          if (y.hasOwnProperty(le)) {
            if (N = [], (G = y[le]).name && (N.push(G.name.toLowerCase()), G.options && G.options.aliases && G.options.aliases.length))
              for (Y = 0; Y < G.options.aliases.length; Y++)
                N.push(G.options.aliases[Y].toLowerCase());
            for (te = e(G.fn, "function") ? G.fn() : G.fn, ae = 0; ae < N.length; ae++)
              (se = N[ae].split(".")).length === 1 ? A[se[0]] = te : (A[se[0]] && (!A[se[0]] || A[se[0]] instanceof Boolean) || (A[se[0]] = new Boolean(A[se[0]])), A[se[0]][se[1]] = te), P.push((te ? "" : "no-") + se.join("-"));
          }
      }(), delete C.addTest, delete C.addAsyncTest;
      for (var fe = 0; fe < A._q.length; fe++)
        A._q[fe]();
      s.Modernizr = A;
    })(M || (M = {}), window, document);
  };
  var Z = function(s, h, r, t) {
    return new (r || (r = Promise))(function(e, n) {
      function i(c) {
        try {
          u(t.next(c));
        } catch (l) {
          n(l);
        }
      }
      function a(c) {
        try {
          u(t.throw(c));
        } catch (l) {
          n(l);
        }
      }
      function u(c) {
        var l;
        c.done ? e(c.value) : (l = c.value, l instanceof r ? l : new r(function(d) {
          d(l);
        })).then(i, a);
      }
      u((t = t.apply(s, h || [])).next());
    });
  }, $ = function(s, h) {
    var r, t, e, n, i = {
      label: 0,
      sent: function() {
        if (1 & e[0])
          throw e[1];
        return e[1];
      },
      trys: [],
      ops: []
    };
    return n = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (n[Symbol.iterator] = function() {
      return this;
    }), n;
    function a(u) {
      return function(c) {
        return function(l) {
          if (r)
            throw new TypeError("Generator is already executing.");
          for (; i; )
            try {
              if (r = 1, t && (e = 2 & l[0] ? t.return : l[0] ? t.throw || ((e = t.return) && e.call(t), 0) : t.next) && !(e = e.call(t, l[1])).done)
                return e;
              switch (t = 0, e && (l = [2 & l[0], e.value]), l[0]) {
                case 0:
                case 1:
                  e = l;
                  break;
                case 4:
                  return i.label++, { value: l[1], done: !1 };
                case 5:
                  i.label++, t = l[1], l = [0];
                  continue;
                case 7:
                  l = i.ops.pop(), i.trys.pop();
                  continue;
                default:
                  if (!(e = (e = i.trys).length > 0 && e[e.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                    i = 0;
                    continue;
                  }
                  if (l[0] === 3 && (!e || l[1] > e[0] && l[1] < e[3])) {
                    i.label = l[1];
                    break;
                  }
                  if (l[0] === 6 && i.label < e[1]) {
                    i.label = e[1], e = l;
                    break;
                  }
                  if (e && i.label < e[2]) {
                    i.label = e[2], i.ops.push(l);
                    break;
                  }
                  e[2] && i.ops.pop(), i.trys.pop();
                  continue;
              }
              l = h.call(s, i);
            } catch (d) {
              l = [6, d], t = 0;
            } finally {
              r = e = 0;
            }
          if (5 & l[0])
            throw l[1];
          return { value: l[0] ? l[1] : void 0, done: !0 };
        }([u, c]);
      };
    }
  }, ve = function() {
    return (ve = Object.assign || function(s) {
      for (var h, r = 1, t = arguments.length; r < t; r++)
        for (var e in h = arguments[r])
          Object.prototype.hasOwnProperty.call(h, e) && (s[e] = h[e]);
      return s;
    }).apply(this, arguments);
  };
  ((function(s) {
    (function(h) {
      var r = function() {
        function t() {
          this._isIphoneOrIPad = !1, (navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPod/i)) && (this._isIphoneOrIPad = !0), this.initUAParser();
        }
        return Object.defineProperty(t.prototype, "userAgentData", {
          get: function() {
            return this._userAgentData;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "deviceType", {
          get: function() {
            return this._deviceType || (h.Util.isMobile ? this._deviceType = this.mobileType || this.desktopType || t.UNKNOWN_DEVICE_TYPE : this._deviceType = this.desktopType || this.mobileType || t.UNKNOWN_DEVICE_TYPE), this._deviceType;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "isIphoneOrIPad", {
          get: function() {
            return this._isIphoneOrIPad;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "browserName", {
          get: function() {
            return this._userAgentData && this._userAgentData.browser && this._userAgentData.browser.name ? this._userAgentData.browser.name.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "browserVersion", {
          get: function() {
            return this._userAgentData && this._userAgentData.browser && this._userAgentData.browser.version ? this._userAgentData.browser.version.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "osName", {
          get: function() {
            return this._userAgentData && this._userAgentData.os && this._userAgentData.os.name ? this._userAgentData.os.name.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "osVersion", {
          get: function() {
            return this._userAgentData && this._userAgentData.os && this._userAgentData.os.version ? this._userAgentData.os.version.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "deviceCategory", {
          get: function() {
            return this._userAgentData && this._userAgentData.device ? this._userAgentData.device.type : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "engineName", {
          get: function() {
            return this._userAgentData && this._userAgentData.engine && this._userAgentData.engine.name ? this._userAgentData.engine.name.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "engineVersion", {
          get: function() {
            return this._userAgentData && this._userAgentData.engine && this._userAgentData.engine.version ? this._userAgentData.engine.version.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "cpuArchitecture", {
          get: function() {
            return this._userAgentData && this._userAgentData.cpu && this._userAgentData.cpu.architecture ? this._userAgentData.cpu.architecture.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "deviceModel", {
          get: function() {
            return this._userAgentData && this._userAgentData.device && this._userAgentData.device.model ? this._userAgentData.device.model.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "deviceVendor", {
          get: function() {
            return this._userAgentData && this._userAgentData.device && this._userAgentData.device.vendor ? this._userAgentData.device.vendor.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "desktopType", {
          get: function() {
            var e = this.browserName;
            this.browserVersion && (e = e + "(" + this.browserVersion + ")");
            var n = this.osName;
            this.osVersion && (n = n + "(" + this.osVersion + ")");
            var i = e && n ? e + "-" + n : e || n;
            return i ? i.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "mobileType", {
          get: function() {
            var e = this.deviceModel, n = this.deviceVendor, i = e && n ? e + " " + n : e || n;
            return i ? i.trim() : "";
          },
          enumerable: !1,
          configurable: !0
        }), t.prototype.initUAParser = function() {
          try {
            var e = new s.UAParser();
            e.setUA(navigator.userAgent), this._userAgentData = e.getResult();
          } catch (n) {
            h.Logger.warn("UAParser failure", n);
          }
        }, t.UNKNOWN_DEVICE_TYPE = "unknown", t;
      }();
      h.BrowserInfo = r;
    })(s._POSignalsUtils || (s._POSignalsUtils = {}));
  }))(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t() {
        }
        return Object.defineProperty(t, "CLIENT_VERSION", {
          get: function() {
            return "5.3.5w";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "SALT", {
          get: function() {
            return "ST8irbd3bB";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "TAB_UUID_KEY", {
          get: function() {
            return "pos_tid";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "OPS_KEY", {
          get: function() {
            return "pos_ops";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "DEVICE_ID_KEY", {
          get: function() {
            return "SecuredTouchDeviceId";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "LAST_DEVICE_KEY_RESYNC", {
          get: function() {
            return "DeviceRefreshDate";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "CAPTURED_KEYBOARD_INTERACTIONS", {
          get: function() {
            return "pos_cki";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "CAPTURED_MOUSE_INTERACTIONS", {
          get: function() {
            return "pos_cmi";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "CAPTURED_GESTURES", {
          get: function() {
            return "pos_cg";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "CAPTURED_INDIRECT", {
          get: function() {
            return "pos_cie";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "CAPTURED_TAGS", {
          get: function() {
            return "pos_ct";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "KEYBOARD_INTERACTIONS_COUNT", {
          get: function() {
            return "pos_kic";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "MOUSE_INTERACTIONS_COUNT", {
          get: function() {
            return "pos_mic";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "GESTURES_COUNT", {
          get: function() {
            return "pos_gc";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "EVENT_COUNTERS", {
          get: function() {
            return "pos_ec";
          },
          enumerable: !1,
          configurable: !0
        }), t;
      }();
      h.Constants = r;
    })(s._POSignalsUtils || (s._POSignalsUtils = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t(e, n, i) {
          if (e === void 0 && (e = "RSA-PSS"), n === void 0 && (n = ["sign", "verify"]), i === void 0 && (i = "SHA-256"), this.signingKeyType = e, this.keyUsage = n, this.algorithm = i, this._crypto = window.crypto || window.msCrypto, !this._crypto || !this._crypto.subtle)
            throw new Error("Cryptography API not supported in this browser");
        }
        return t.prototype.generateKeys = function() {
          return Z(this, void 0, void 0, function() {
            return $(this, function(e) {
              return [
                2,
                this._crypto.subtle.generateKey(
                  {
                    name: this.signingKeyType,
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: { name: this.algorithm }
                  },
                  !1,
                  this.keyUsage
                )
              ];
            });
          });
        }, t.prototype.exportPublicKey = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i, a;
            return $(this, function(u) {
              switch (u.label) {
                case 0:
                  return [4, this._crypto.subtle.exportKey("spki", e.publicKey)];
                case 1:
                  return n = u.sent(), i = h.Util.ab2str(n), a = btoa(i), h.Logger.debug("Exported base64 pub key: ", a), [2, a];
              }
            });
          });
        }, t.prototype.exportPrivateKey = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i, a, u;
            return $(this, function(c) {
              switch (c.label) {
                case 0:
                  return [4, this._crypto.subtle.exportKey("pkcs8", e.privateKey)];
                case 1:
                  return n = c.sent(), i = h.Util.ab2str(n), a = btoa(i), u = `-----BEGIN PRIVATE KEY-----
` + a + `
-----END PRIVATE KEY-----`, h.Logger.debug("Exported base64 pem:", u), [2, u];
              }
            });
          });
        }, t.prototype.signChallenge = function(e, n, i) {
          return i === void 0 && (i = 0), Z(this, void 0, void 0, function() {
            var a, u, c;
            return $(this, function(l) {
              switch (l.label) {
                case 0:
                  return a = h.Util.string2buf(e), [
                    4,
                    this._crypto.subtle.sign(
                      { name: this.signingKeyType, saltLength: i, hash: this.algorithm },
                      n,
                      a
                    )
                  ];
                case 1:
                  return u = l.sent(), c = btoa(String.fromCharCode.apply(null, new Uint8Array(u))), h.Logger.debug("Signed challenge: ", c), [2, c];
              }
            });
          });
        }, t;
      }();
      h.CryptoOperator = r;
    })(s._POSignalsUtils || (s._POSignalsUtils = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t() {
        }
        return Object.defineProperty(t, "isLogEnabled", {
          get: function() {
            return this._isLogEnabled || window["enable-logs-pingOneSignals"];
          },
          set: function(e) {
            this._isLogEnabled = e;
          },
          enumerable: !1,
          configurable: !0
        }), t.debug = function(e) {
          for (var n = [], i = 1; i < arguments.length; i++)
            n[i - 1] = arguments[i];
          e = t.TAG + " " + e, t.isLogEnabled && (n && n.length > 0 ? console.debug ? console.debug(e, n) : console.log(e, n) : console.debug ? console.debug(e) : console.log(e));
        }, t.error = function(e) {
          for (var n = [], i = 1; i < arguments.length; i++)
            n[i - 1] = arguments[i];
          e = t.TAG + " " + e, t.isLogEnabled && (n && n.length > 0 ? console.error(e, n) : console.error(e));
        }, t.warn = function(e) {
          for (var n = [], i = 1; i < arguments.length; i++)
            n[i - 1] = arguments[i];
          e = t.TAG + " " + e, t.isLogEnabled && (n && n.length > 0 ? console.warn(e, n) : console.warn(e));
        }, t.info = function(e) {
          for (var n = [], i = 1; i < arguments.length; i++)
            n[i - 1] = arguments[i];
          e = t.TAG + " " + e, t.isLogEnabled && (n && n.length > 0 ? console.info(e, n) : console.info(e));
        }, t.TAG = "[SignalsSDK]", t;
      }();
      h.Logger = r;
    })(s._POSignalsUtils || (s._POSignalsUtils = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t() {
        }
        return Object.defineProperty(t, "INITIALIZATION_ERROR", {
          get: function() {
            return "INITIALIZATION_ERROR";
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t, "UNEXPECTED_ERROR", {
          get: function() {
            return "UNEXPECTED_ERROR";
          },
          enumerable: !1,
          configurable: !0
        }), t;
      }();
      h.POErrorCodes = r;
    })(s._POSignalsUtils || (s._POSignalsUtils = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t() {
        }
        return Object.defineProperty(t, "isMobile", {
          get: function() {
            var e, n = !1;
            return e = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
              e
            ) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
              e.substr(0, 4)
            )) && (n = !0), n;
          },
          enumerable: !1,
          configurable: !0
        }), t.newGuid = function() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
            var n = 16 * Math.random() | 0;
            return (e === "x" ? n : 3 & n | 8).toString(16);
          });
        }, t.ieFix = function() {
          (navigator.userAgent.indexOf("MSIE") != -1 ? /MSIE (\d+\.\d+);/ : /Trident.*rv[ :]*(\d+\.\d+)/).test(navigator.userAgent) && (document.body.setAttribute("style", "-ms-touch-action:none;"), document.body.style.touchAction = "none", document.body.style.msTouchAction = "none");
        }, t.now = function() {
          var e = window.performance || {};
          return e.now = e.now || e.webkitNow || e.msNow || e.oNow || e.mozNow || function() {
            return (/* @__PURE__ */ new Date()).getTime();
          }, e.now();
        }, t.base64Uint8Array = function(e) {
          var n, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = e.length, u = "";
          for (n = 0; n < a; n += 3)
            u += i[e[n] >> 2], u += i[(3 & e[n]) << 4 | e[n + 1] >> 4], u += i[(15 & e[n + 1]) << 2 | e[n + 2] >> 6], u += i[63 & e[n + 2]];
          return a % 3 == 2 ? u = u.substring(0, u.length - 1) + "=" : a % 3 == 1 && (u = u.substring(0, u.length - 2) + "=="), u;
        }, t.string2buf = function(e) {
          if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
            return new TextEncoder().encode(e);
          var n, i, a, u, c, l = e.length, d = 0;
          for (u = 0; u < l; u++)
            (64512 & (i = e.charCodeAt(u))) == 55296 && u + 1 < l && (64512 & (a = e.charCodeAt(u + 1))) == 56320 && (i = 65536 + (i - 55296 << 10) + (a - 56320), u++), d += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
          for (n = new Uint8Array(d), c = 0, u = 0; c < d; u++)
            (64512 & (i = e.charCodeAt(u))) == 55296 && u + 1 < l && (64512 & (a = e.charCodeAt(u + 1))) == 56320 && (i = 65536 + (i - 55296 << 10) + (a - 56320), u++), i < 128 ? n[c++] = i : i < 2048 ? (n[c++] = 192 | i >>> 6, n[c++] = 128 | 63 & i) : i < 65536 ? (n[c++] = 224 | i >>> 12, n[c++] = 128 | i >>> 6 & 63, n[c++] = 128 | 63 & i) : (n[c++] = 240 | i >>> 18, n[c++] = 128 | i >>> 12 & 63, n[c++] = 128 | i >>> 6 & 63, n[c++] = 128 | 63 & i);
          return n;
        }, t.utf8Encode = function(e) {
          e = e.replace(/\r\n/g, `
`);
          for (var n = "", i = 0; i < e.length; i++) {
            var a = e.charCodeAt(i);
            a < 128 ? n += String.fromCharCode(a) : a > 127 && a < 2048 ? (n += String.fromCharCode(a >> 6 | 192), n += String.fromCharCode(63 & a | 128)) : (n += String.fromCharCode(a >> 12 | 224), n += String.fromCharCode(a >> 6 & 63 | 128), n += String.fromCharCode(63 & a | 128));
          }
          return n;
        }, t.hash = function(e) {
          var n = t.hashCache.get(e);
          return n || (n = s.sha256(e + h.Constants.SALT), t.hashCache.set(e, n)), n;
        }, t.hashMini = function(e) {
          var n, i, a = "" + JSON.stringify(e), u = 2166136261;
          for (n = 0, i = a.length; n < i; n++)
            u = Math.imul(31, u) + a.charCodeAt(n) | 0;
          return ("0000000" + (u >>> 0).toString(16)).substr(-8);
        }, t.hashCode = function(e) {
          var n = 0, i = e ? e.length : 0, a = 0;
          if (i > 0)
            for (; a < i; )
              n = (n << 5) - n + e.charCodeAt(a++) | 0;
          return n;
        }, t.mod = function(e, n) {
          return (t.hashCode(e) % n + n) % n;
        }, t.isEmail = function(e) {
          try {
            return e && /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(
              e.toLowerCase()
            );
          } catch (n) {
            return h.Logger.warn("isEmail function failed to parse string", n), !1;
          }
        }, t.getEmailDomain = function(e) {
          return t.isEmail(e) ? e.substring(e.lastIndexOf("@") + 1) : "";
        }, t.extendPrimitiveValues = function(e, n, i) {
          for (var a = t.allKeys(n), u = 0; u < a.length; )
            t.isObject(n[a[u]]) || i && (!i || e[a[u]] !== void 0) || (e[a[u]] = n[a[u]]), u++;
          return e;
        }, t.flatten = function(e) {
          var n = {};
          return t.dive("", e, n), n;
        }, t.isFunction = function(e) {
          return e && typeof e == "function";
        }, t.isPassiveSupported = function() {
          var e = !1, n = function() {
          };
          try {
            var i = {
              get passive() {
                return e = !0, !0;
              }
            };
            window.addEventListener("test", n, i), window.removeEventListener("test", n, !1);
          } catch {
            e = !1;
          }
          return e;
        }, t.getAttribute = function(e, n) {
          try {
            if (e && typeof e.getAttribute == "function")
              return e.getAttribute(n) || "";
          } catch {
          }
          return "";
        }, t.createInvisibleElement = function(e) {
          try {
            var n = document.createElement(e);
            return n.style.display = "none", n.style.border = "none", n.style.position = "absolute", n.style.top = "-999px", n.style.left = "-999px", n.style.width = "0", n.style.height = "0", n.style.visibility = "hidden", n;
          } catch (i) {
            return h.Logger.warn("Failed to create element", i), null;
          }
        }, t.values = function(e) {
          for (var n = t.allKeys(e), i = n.length, a = Array(i), u = 0; u < i; u++)
            a[u] = e[n[u]];
          return a;
        }, t.getValuesOfMap = function(e) {
          if (this.isFunction(e.values))
            return Array.from(e.values());
          var n = [];
          return e.forEach(function(i) {
            return n.push(i);
          }), n;
        }, t.typesCounter = function(e) {
          for (var n = {}, i = 0, a = e; i < a.length; i++) {
            var u = a[i];
            n[u.type] = (n[u.type] || 0) + 1;
          }
          return n;
        }, t.modifiersKeys = function(e) {
          var n = [];
          return e.getModifierState && [
            "Alt",
            "AltGraph",
            "CapsLock",
            "Control",
            "Fn",
            "FnLock",
            "Hyper",
            "Meta",
            "NumLock",
            "OS",
            "ScrollLock",
            "Shift",
            "Super",
            "Symbol",
            "SymbolLock"
          ].forEach(function(i) {
            e.getModifierState(i.toString()) && n.push(i);
          }), n;
        }, t.getElementText = function(e) {
          var n, i;
          return e instanceof HTMLInputElement ? ["checkbox", "radio"].indexOf(e.type) >= 0 ? "" + e.checked : e.value : e instanceof HTMLSelectElement ? (i = (n = e.selectedOptions) === null || n === void 0 ? void 0 : n[0]) === null || i === void 0 ? void 0 : i.innerText : e.innerText;
        }, t.getSrcElement = function(e) {
          return e.srcElement || e.target;
        }, t.getObjectType = function(e) {
          try {
            var n = /function (.{1,})\(/.exec(e.constructor.toString());
            return n && n.length > 1 ? n[1] : "";
          } catch {
            return "";
          }
        }, t.isSelectorMatches = function(e, n, i) {
          try {
            var a = Element.prototype, u = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.msMatchesSelector, c = 0;
            do {
              if (u.call(e, n))
                return e;
              e = e.parentElement || e.parentNode;
            } while (e !== null && e.nodeType === 1 && c++ < i);
            return null;
          } catch {
            return null;
          }
        }, t.anySelectorMatches = function(e, n, i) {
          try {
            for (var a = 0, u = n; a < u.length; a++) {
              var c = u[a];
              if (this.isSelectorMatches(e, c, i))
                return !0;
            }
          } catch (l) {
            h.Logger.warn(l);
          }
          return !1;
        }, t.isArray = function(e) {
          return Array.isArray ? Array.isArray(e) : Object.prototype.toString.call(e) === "[object Array]";
        }, t.safeJsonParse = function(e) {
          var n = null;
          try {
            e && (n = JSON.parse(e));
          } catch (i) {
            h.Logger.warn("Failed to parse object " + i), n = null;
          }
          return n;
        }, t.getElementSelectionStart = function(e) {
          var n;
          try {
            n = e.selectionStart;
          } catch {
            n = "";
          }
          return n;
        }, t.getElementSelectionEnd = function(e) {
          var n;
          try {
            n = e.selectionEnd;
          } catch {
            n = "";
          }
          return n;
        }, t.isClickableInput = function(e) {
          return e && [
            "button",
            "checkbox",
            "color",
            "radio",
            "range",
            "image",
            "submit",
            "file",
            "reset"
          ].indexOf(e.type) >= 0;
        }, t.isTextInput = function(e) {
          return e && [
            "date",
            "datetime-local",
            "email",
            "month",
            "number",
            "password",
            "search",
            "tel",
            "text",
            "time",
            "url",
            "week",
            "datetime"
          ].indexOf(e.type) >= 0;
        }, t.getDeviceOrientation = function() {
          var e = screen.orientation || screen.mozOrientation || {}, n = screen.msOrientation || e.type, i = e.angle;
          return {
            orientation: n == null ? void 0 : n.toString(),
            angle: i == null ? void 0 : i.toString()
          };
        }, t.getDevToolsState = function() {
          var e, n, i = window.outerWidth - window.innerWidth > 160, a = window.outerHeight - window.innerHeight > 160, u = i ? "vertical" : "horizontal";
          return a && i || !(!((n = (e = window.Firebug) === null || e === void 0 ? void 0 : e.chrome) === null || n === void 0) && n.isInitialized || i || a) ? { open: !1, orientation: void 0 } : { open: !0, orientation: u };
        }, t.getCookie = function(e) {
          var n = document.cookie.match("(^|;) ?" + e + "=([^;]*)(;|$)");
          return n ? n[2] : null;
        }, t.setCookie = function(e, n, i) {
          var a = /* @__PURE__ */ new Date();
          a.setTime(a.getTime() + 1e3 * i), document.cookie = e + "=" + n + ";path=/;secure;SameSite=None;expires=" + a.toUTCString();
        }, t.deleteCookie = function(e) {
          t.setCookie(e, "", -1);
        }, t.delay = function(e) {
          return new Promise(function(n) {
            return setTimeout(n, e);
          });
        }, t.getHostnameFromRegex = function(e) {
          if (e) {
            var n = e.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i);
            return n && n[1];
          }
          return null;
        }, t.inIframe = function() {
          try {
            return window.self !== window.top;
          } catch {
            return !0;
          }
        }, t.promiseTimeout = function(e, n) {
          var i = new Promise(function(a, u) {
            var c = setTimeout(function() {
              clearTimeout(c), u(new Error("Timed out in " + e + "ms."));
            }, e);
          });
          return Promise.race([n, i]);
        }, t.getProperty = function(e, n) {
          return n.split(".").reduce(function(i, a) {
            return i ? i[a] : null;
          }, e);
        }, t.filterReduce = function(e, n) {
          return Object.keys(e).filter(function(i) {
            return n(e[i]);
          }).reduce(function(i, a) {
            var u;
            return ve(ve({}, i), ((u = {})[a] = e[a], u));
          }, {});
        }, t.dive = function(e, n, i) {
          for (var a in n)
            if (n.hasOwnProperty(a)) {
              var u = a, c = n[a];
              e.length > 0 && (u = e + "." + a), t.isObject(c) ? t.dive(u, c, i) : i[u] = c;
            }
        }, t.isObject = function(e) {
          var n = typeof e;
          return n === "function" || n === "object" && !!e;
        }, t.allKeys = function(e) {
          if (!t.isObject(e))
            return [];
          var n = [];
          for (var i in e)
            n.push(i);
          return n;
        }, t.encryptionString = function(e, n) {
          for (var i = [], a = 0; a < e.length; a++) {
            var u = e.charCodeAt(a) ^ n.charCodeAt(a % n.length);
            i.push(String.fromCharCode(u));
          }
          return i.join("");
        }, t.encryptionBytes = function(e, n) {
          for (var i = new Uint8Array(e.length), a = 0; a < e.length; a++)
            i[a] = e[a] ^ n.charCodeAt(a % n.length);
          return i;
        }, t.parseJwt = function(e) {
          var n = e.split(".")[1].replace(/-/g, "+").replace(/_/g, "/"), i = decodeURIComponent(
            window.atob(n).split("").map(function(a) {
              return "%" + ("00" + a.charCodeAt(0).toString(16)).slice(-2);
            }).join("")
          );
          return JSON.parse(i);
        }, t.calculateMeanTimeDeltasBetweenEvents = function(e) {
          var n = 0;
          if ((e == null ? void 0 : e.length) > 1) {
            for (var i = e[0].epochTs, a = 1; a < e.length; a++)
              n += e[a].epochTs - i, i = e[a].epochTs;
            n /= e.length - 1;
          }
          return n;
        }, t.sortEventsByTimestamp = function(e) {
          return e.sort(function(n, i) {
            return n.eventTs > i.eventTs ? 1 : n.eventTs < i.eventTs ? -1 : n.epochTs > i.epochTs ? 1 : n.epochTs < i.epochTs ? -1 : n.type === "click" ? 1 : -1;
          });
        }, t.distanceBetweenPoints = function(e, n) {
          return Math.sqrt(Math.pow(e.getX() - n.getX(), 2) + Math.pow(e.getY() - n.getY(), 2));
        }, t.calculateMeanDistanceBetweenPoints = function(e) {
          var n = 0;
          if ((e == null ? void 0 : e.length) > 1) {
            for (var i = 1; i < e.length; i++)
              n += t.distanceBetweenPoints(e[i - 1], e[i]);
            n /= e.length - 1;
          }
          return n;
        }, t.filterArrayByLength = function(e, n) {
          return e.length <= n ? e : e.slice(0, n).concat(e[e.length - 1]);
        }, t.keepFirstEventsWithDistance = function(e) {
          var n = e.events, i = e.threshold, a = e.min, u = e.max;
          if (n.length <= a)
            return n;
          var c, l = n[0];
          for (c = 1; c < n.length && c < u && !(Math.max(Math.abs(n[c].getX() - l.getX()), Math.abs(n[c].getY() - l.getY())) >= i); c++)
            ;
          return n.slice(0, Math.max(c + 1, a));
        }, t.ab2str = function(e) {
          return String.fromCharCode.apply(null, new Uint8Array(e));
        }, t.str2ab = function(e) {
          for (var n = new ArrayBuffer(e.length), i = new Uint8Array(n), a = 0, u = e.length; a < u; a++)
            i[a] = e.charCodeAt(a);
          return n;
        }, t.hashCache = /* @__PURE__ */ new Map(), t.keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", t;
      }();
      h.Util = r;
    })(s._POSignalsUtils || (s._POSignalsUtils = {}));
  }(M || (M = {})), Z = function(s, h, r, t) {
    return new (r || (r = Promise))(function(e, n) {
      function i(c) {
        try {
          u(t.next(c));
        } catch (l) {
          n(l);
        }
      }
      function a(c) {
        try {
          u(t.throw(c));
        } catch (l) {
          n(l);
        }
      }
      function u(c) {
        var l;
        c.done ? e(c.value) : (l = c.value, l instanceof r ? l : new r(function(d) {
          d(l);
        })).then(i, a);
      }
      u((t = t.apply(s, h || [])).next());
    });
  }, $ = function(s, h) {
    var r, t, e, n, i = {
      label: 0,
      sent: function() {
        if (1 & e[0])
          throw e[1];
        return e[1];
      },
      trys: [],
      ops: []
    };
    return n = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (n[Symbol.iterator] = function() {
      return this;
    }), n;
    function a(u) {
      return function(c) {
        return function(l) {
          if (r)
            throw new TypeError("Generator is already executing.");
          for (; i; )
            try {
              if (r = 1, t && (e = 2 & l[0] ? t.return : l[0] ? t.throw || ((e = t.return) && e.call(t), 0) : t.next) && !(e = e.call(t, l[1])).done)
                return e;
              switch (t = 0, e && (l = [2 & l[0], e.value]), l[0]) {
                case 0:
                case 1:
                  e = l;
                  break;
                case 4:
                  return i.label++, { value: l[1], done: !1 };
                case 5:
                  i.label++, t = l[1], l = [0];
                  continue;
                case 7:
                  l = i.ops.pop(), i.trys.pop();
                  continue;
                default:
                  if (!(e = (e = i.trys).length > 0 && e[e.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                    i = 0;
                    continue;
                  }
                  if (l[0] === 3 && (!e || l[1] > e[0] && l[1] < e[3])) {
                    i.label = l[1];
                    break;
                  }
                  if (l[0] === 6 && i.label < e[1]) {
                    i.label = e[1], e = l;
                    break;
                  }
                  if (e && i.label < e[2]) {
                    i.label = e[2], i.ops.push(l);
                    break;
                  }
                  e[2] && i.ops.pop(), i.trys.pop();
                  continue;
              }
              l = h.call(s, i);
            } catch (d) {
              l = [6, d], t = 0;
            } finally {
              r = e = 0;
            }
          if (5 & l[0])
            throw l[1];
          return { value: l[0] ? l[1] : void 0, done: !0 };
        }([u, c]);
      };
    }
  }, function(s) {
    var h = s.openDB;
    (function(r) {
      var t = function() {
        function e() {
        }
        return e.initDB = function() {
          return Z(this, void 0, void 0, function() {
            var n, i = this;
            return $(this, function(a) {
              if (!(window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB))
                throw new Error("IndexedDB is not supported");
              return n = new e(), [
                2,
                new Promise(function(u) {
                  return Z(i, void 0, void 0, function() {
                    var c;
                    return $(this, function(l) {
                      switch (l.label) {
                        case 0:
                          return c = n, [
                            4,
                            h(this._PingDBName, e._version, {
                              upgrade: function(d, p, m, k, x) {
                                d.createObjectStore(e._storeDefaultName);
                              }
                            })
                          ];
                        case 1:
                          return c.indexedDatabase = l.sent(), u(n), [2];
                      }
                    });
                  });
                })
              ];
            });
          });
        }, e.prototype.close = function() {
          this.indexedDatabase.close();
        }, e.prototype.getValue = function(n) {
          return this.indexedDatabase.get(e._storeDefaultName, n);
        }, e.prototype.setValue = function(n, i) {
          return this.indexedDatabase.put(e._storeDefaultName, i, n);
        }, e._PingDBName = "Ping", e._version = 1, e._storeDefaultName = "PING_ONE", e;
      }();
      r.IndexedDBStorage = t;
    })(s._POSignalsStorage || (s._POSignalsStorage = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function e(n, i) {
          this.crossStorageClient = new s.CrossStorageClient(n, i);
        }
        return e.prototype.get = function(n) {
          var i = s._POSignalsUtils.Util.hash(n);
          return this.crossStorageClient.get(i);
        }, e.prototype.del = function(n) {
          return this.crossStorageClient.del(s._POSignalsUtils.Util.hash(n));
        }, e.prototype.set = function(n, i, a) {
          return this.crossStorageClient.set(s._POSignalsUtils.Util.hash(n), i, a);
        }, e.prototype.onConnect = function() {
          return this.crossStorageClient.onConnect();
        }, e.prototype.close = function(n) {
          return this.crossStorageClient.close(n);
        }, e.prototype.getSignedPayload = function(n, i) {
          return this.crossStorageClient.getSignedPayload(n, i);
        }, e.prototype.getDeviceDetails = function(n) {
          var i = s._POSignalsUtils.Util.hash(n);
          return this.crossStorageClient.getDeviceDetails(i);
        }, e.prototype.setDeviceDetails = function(n, i) {
          var a = s._POSignalsUtils.Util.hash(n);
          return this.crossStorageClient.setDeviceDetails(a, i);
        }, e;
      }();
      h.CrossStorage = r;
      var t = function() {
        function e(n) {
          this.storage = n;
        }
        return e.prototype.get = function(n) {
          return Promise.resolve(this.storage.getItem(n));
        }, e.prototype.del = function(n) {
          return this.storage.removeItem(n), Promise.resolve();
        }, e.prototype.set = function(n, i) {
          return this.storage.setItem(n, i), Promise.resolve();
        }, e.prototype.onConnect = function() {
          return Promise.resolve();
        }, e.prototype.close = function(n) {
          return Promise.resolve();
        }, e.prototype.getSignedPayload = function(n, i) {
          return Promise.resolve([]);
        }, e.prototype.getDeviceDetails = function(n) {
          return Promise.resolve([]);
        }, e.prototype.setDeviceDetails = function(n, i) {
          return Promise.resolve([]);
        }, e;
      }();
      h.CrossStorageFallback = t;
    })(s._POSignalsStorage || (s._POSignalsStorage = {}));
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t, e, n) {
        this.deviceId = t, this.dbStorage = e, this.cryptoHandler = n;
      }
      return r.prototype.getExportedPublicKey = function() {
        return Z(this, void 0, void 0, function() {
          var t;
          return $(this, function(e) {
            switch (e.label) {
              case 0:
                return [4, this.getDeviceKeys()];
              case 1:
                return (t = e.sent()) ? [2, this.cryptoHandler.exportPublicKey(t)] : [2];
            }
          });
        });
      }, r.prototype.setDeviceKeys = function(t) {
        return Z(this, void 0, void 0, function() {
          var e;
          return $(this, function(n) {
            switch (n.label) {
              case 0:
                return [4, this.dbStorage.setValue(this.deviceId, t)];
              case 1:
                return e = n.sent(), this.cachedDeviceKey = t, [2, e];
            }
          });
        });
      }, r.prototype.associateDeviceKeys = function() {
        return Z(this, void 0, void 0, function() {
          var t;
          return $(this, function(e) {
            switch (e.label) {
              case 0:
                return [4, this.cryptoHandler.generateKeys()];
              case 1:
                return t = e.sent(), s._POSignalsUtils.Logger.info("Associating new device domain keys"), [4, this.setDeviceKeys(t)];
              case 2:
                return e.sent(), [2, t];
            }
          });
        });
      }, r.prototype.signDeviceWithKeys = function(t) {
        return Z(this, void 0, void 0, function() {
          var e, n, i;
          return $(this, function(a) {
            switch (a.label) {
              case 0:
                return n = (e = this.cryptoHandler).signChallenge, i = [t], [4, this.getDeviceKeys()];
              case 1:
                return [2, n.apply(e, i.concat([a.sent().privateKey, r._default_salt]))];
            }
          });
        });
      }, r.prototype.getDeviceKeys = function() {
        return Z(this, void 0, void 0, function() {
          var t;
          return $(this, function(e) {
            switch (e.label) {
              case 0:
                return this.cachedDeviceKey ? [3, 2] : (t = this, [4, this.dbStorage.getValue(this.deviceId)]);
              case 1:
                t.cachedDeviceKey = e.sent(), e.label = 2;
              case 2:
                return [2, this.cachedDeviceKey];
            }
          });
        });
      }, r._default_salt = 32, r;
    }();
    s.DeviceKeys = h;
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t() {
          this._disabledStorage = [], this.assertionValues = [
            "BROWSER_ENGINE_VERSION",
            "NAVIGATOR_LANGUAGE",
            "OS_NAME",
            "OS_VERSION",
            "NAVIGATOR_USER_AGENT",
            "FINGER_PRINT",
            "RESOLUTION",
            "PUSH_NOTIFICATIONS_SUPPORTED",
            "COOKIES_ENABLED",
            "IS_INCOGNITO",
            "IS_PRIVATE_MODE"
          ];
          try {
            window.sessionStorage.setItem("_st_storage_enabled_check", "test"), window.sessionStorage.removeItem("_st_storage_enabled_check"), this.signalsSessionStorage = window.sessionStorage;
          } catch {
            s._POSignalsUtils.Logger.warn("session storage disabled"), this._disabledStorage.push("sessionStorage"), this.signalsSessionStorage = new h.StorageFallback();
          }
          try {
            window.localStorage.setItem("_st_storage_enabled_check", "test"), window.localStorage.removeItem("_st_storage_enabled_check"), this.signalsLocalStorage = new h.StorageWrapper(window.localStorage);
          } catch {
            s._POSignalsUtils.Logger.warn("local storage disabled"), this._disabledStorage.push("localStorage"), this.signalsLocalStorage = new h.StorageWrapper(new h.StorageFallback()), this.crossStorage = new h.CrossStorageFallback(this.signalsLocalStorage);
          }
        }
        return t.prototype.setStorageConfig = function(e) {
          this.disableHub = e.disableHub, this.hubUrl = e.hubUrl, this.universalTrustEnabled = this.isUniversalTrustEnabled(
            e.universalDeviceIdentification
          ), this.devEnv = e.devEnv;
        }, Object.defineProperty(t, "instance", {
          get: function() {
            return t._instance || (t._instance = new t()), t._instance;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "tabUUID", {
          get: function() {
            var e = this.signalsSessionStorage.getItem(
              s._POSignalsUtils.Constants.TAB_UUID_KEY
            );
            return e || (e = s._POSignalsUtils.Util.newGuid(), this.signalsSessionStorage.setItem(
              s._POSignalsUtils.Constants.TAB_UUID_KEY,
              e
            )), e;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "ops", {
          get: function() {
            var e = Number(
              this.signalsSessionStorage.getItem(s._POSignalsUtils.Constants.OPS_KEY)
            );
            return isNaN(e) ? null : e;
          },
          set: function(e) {
            e ? this.signalsSessionStorage.setItem(
              s._POSignalsUtils.Constants.OPS_KEY,
              e.toString()
            ) : this.signalsSessionStorage.removeItem(s._POSignalsUtils.Constants.OPS_KEY);
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "disabledStorage", {
          get: function() {
            return this._disabledStorage;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "sessionStorage", {
          get: function() {
            return this.signalsSessionStorage;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(t.prototype, "localStorage", {
          get: function() {
            return this.signalsLocalStorage;
          },
          enumerable: !1,
          configurable: !0
        }), t.prototype.initDeviceIdentity = function() {
          return Z(this, void 0, void 0, function() {
            var e, n, i;
            return $(this, function(a) {
              switch (a.label) {
                case 0:
                  return (n = this.signalsLocalStorage.getItem(
                    s._POSignalsUtils.Constants.DEVICE_ID_KEY
                  )) && (this.cachedDeviceId = n), this.universalTrustEnabled ? (this.deviceTrust = { attestation: {}, dtts: (/* @__PURE__ */ new Date()).getTime() }, this.disableHub && (this.deviceTrust.hubDisabled = !0), i = this, [4, h.IndexedDBStorage.initDB()]) : [3, 3];
                case 1:
                  return i.indexedDBStorage = a.sent(), [4, this.loadLocalDeviceTrust()];
                case 2:
                  e = a.sent(), a.label = 3;
                case 3:
                  return this.disableHub || n && !this.shouldFallbackToP1Key(e) ? [3, 5] : [4, this.fallbackToCrossStorage(this.hubUrl)];
                case 4:
                  return a.sent(), [3, 6];
                case 5:
                  this.crossStorage = new h.CrossStorageFallback(this.signalsLocalStorage), a.label = 6;
                case 6:
                  return this.getDeviceId() ? [3, 8] : [4, this.associateDeviceDetails(this.disableHub)];
                case 7:
                  a.sent(), a.label = 8;
                case 8:
                  return !this.universalTrustEnabled || this.getDeviceId() && e ? [3, 10] : [4, this.createDomainKeys(this.disableHub)];
                case 9:
                  a.sent(), a.label = 10;
                case 10:
                  return [2, this.getDeviceId()];
              }
            });
          });
        }, t.prototype.shouldFallbackToP1Key = function(e) {
          return this.universalTrustEnabled && !this.disableHub && (!e || this.isRefreshRequired(this.deviceKeyRsyncIntervals));
        }, t.prototype.isRefreshRequired = function(e) {
          if (e === void 0 && (e = 3), !this.deviceTrust.dtts)
            return !0;
          var n = this.signalsLocalStorage.getItem(
            s._POSignalsUtils.Constants.LAST_DEVICE_KEY_RESYNC
          );
          if (!n || isNaN(parseInt(n)))
            return !0;
          var i = this.deviceTrust.dtts - n > 864e5 * e;
          return i && s._POSignalsUtils.Logger.debug("Refresh required"), i;
        }, t.prototype.loadLocalDeviceTrust = function() {
          return Z(this, void 0, void 0, function() {
            var e, n;
            return $(this, function(i) {
              switch (i.label) {
                case 0:
                  return i.trys.push([0, 4, , 5]), this.cachedDeviceId ? this.cachedDeviceId ? (this.domainDeviceKeys = new s.DeviceKeys(
                    this.getDeviceId(),
                    this.indexedDBStorage,
                    new s._POSignalsUtils.CryptoOperator()
                  ), [4, this.domainDeviceKeys.getDeviceKeys()]) : [3, 3] : (s._POSignalsUtils.Logger.debug(
                    "No device id found on customer domain"
                  ), [2, !1]);
                case 1:
                  return i.sent() ? (e = this.deviceTrust.attestation, [4, this.domainDeviceKeys.getExportedPublicKey()]) : (s._POSignalsUtils.Logger.debug(
                    "No device keys found on customer domain"
                  ), [2, !1]);
                case 2:
                  return e.deviceKey = i.sent(), this.crossStorage = new h.CrossStorageFallback(this.signalsLocalStorage), [2, !0];
                case 3:
                  return [3, 5];
                case 4:
                  return n = i.sent(), s._POSignalsUtils.Logger.error("Domain PKI initialization failed", n), [2, !1];
                case 5:
                  return [2];
              }
            });
          });
        }, t.prototype.createDomainKeys = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i;
            return $(this, function(a) {
              switch (a.label) {
                case 0:
                  return a.trys.push([0, 3, , 4]), !e && this._disabledStorage.lastIndexOf("hub") > -1 ? (s._POSignalsUtils.Logger.debug(
                    "Hub unavailable - skipping domain trust creation"
                  ), [2]) : (this.domainDeviceKeys = new s.DeviceKeys(
                    this.getDeviceId(),
                    this.indexedDBStorage,
                    new s._POSignalsUtils.CryptoOperator()
                  ), [4, this.domainDeviceKeys.associateDeviceKeys()]);
                case 1:
                  return a.sent(), n = this.deviceTrust.attestation, [4, this.domainDeviceKeys.getExportedPublicKey()];
                case 2:
                  return n.deviceKey = a.sent(), [3, 4];
                case 3:
                  return i = a.sent(), s._POSignalsUtils.Logger.error("Domain PKI initialization failed", i), [3, 4];
                case 4:
                  return [2];
              }
            });
          });
        }, t.prototype.getDeviceId = function() {
          return this.cachedDeviceId;
        }, t.prototype.associateDeviceDetails = function(e) {
          var n, i;
          return Z(this, void 0, void 0, function() {
            var a;
            return $(this, function(u) {
              switch (u.label) {
                case 0:
                  return s._POSignalsUtils.Logger.debug("Associating fresh device details"), this.cachedDeviceId = "Id-" + s._POSignalsUtils.Util.newGuid(), this.signalsLocalStorage.setItem(
                    s._POSignalsUtils.Constants.DEVICE_ID_KEY,
                    this.cachedDeviceId
                  ), e ? [3, 4] : this.universalTrustEnabled ? (a = this.deviceTrust.attestation, [
                    4,
                    this.crossStorage.setDeviceDetails(
                      s._POSignalsUtils.Constants.DEVICE_ID_KEY,
                      this.cachedDeviceId
                    )
                  ]) : [3, 2];
                case 1:
                  return a.fallbackDeviceKey = u.sent()[0], [3, 4];
                case 2:
                  return [
                    4,
                    this.crossStorage.set(
                      s._POSignalsUtils.Constants.DEVICE_ID_KEY,
                      this.cachedDeviceId
                    )
                  ];
                case 3:
                  u.sent(), u.label = 4;
                case 4:
                  return s._POSignalsUtils.Logger.debug(
                    "PingOne Signals deviceId: " + this.cachedDeviceId
                  ), [
                    2,
                    [
                      this.cachedDeviceId,
                      (i = (n = this.deviceTrust) === null || n === void 0 ? void 0 : n.attestation) === null || i === void 0 ? void 0 : i.fallbackDeviceKey
                    ]
                  ];
              }
            });
          });
        }, t.prototype.addAssertion = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i, a, u, c, l, d;
            return $(this, function(p) {
              switch (p.label) {
                case 0:
                  if (p.trys.push([0, 5, 6, 7]), !this.universalTrustEnabled || !this.deviceTrust.attestation.deviceKey && !this.deviceTrust.attestation.fallbackDeviceKey)
                    return [2];
                  for (n = (n = e.deviceId).concat("-" + e.deviceType), i = 0, a = this.assertionValues; i < a.length; i++)
                    u = a[i], e[u] != null && e[u] != null && (n = n.concat("-" + e[u]));
                  return n = n.concat("-" + this.deviceTrust.dtts), s._POSignalsUtils.Logger.debug("Device identityContract " + n), this.deviceTrust.attestation.fallbackDeviceKey && this.crossStorage ? (c = this.deviceTrust.attestation, [4, this.crossStorage.getSignedPayload(n, this.getDeviceId())]) : [3, 2];
                case 1:
                  return c.deviceToken = p.sent()[1], this.signalsLocalStorage.setItem(
                    s._POSignalsUtils.Constants.LAST_DEVICE_KEY_RESYNC,
                    (/* @__PURE__ */ new Date()).getTime()
                  ), [3, 4];
                case 2:
                  return l = this.deviceTrust.attestation, [4, this.domainDeviceKeys.signDeviceWithKeys(n)];
                case 3:
                  l.deviceToken = p.sent(), p.label = 4;
                case 4:
                  return [3, 7];
                case 5:
                  return d = p.sent(), s._POSignalsUtils.Logger.warn("Device attestation failed:", d), [3, 7];
                case 6:
                  return this.universalTrustEnabled && s._POSignalsUtils.Logger.info(
                    "Device attestation " + JSON.stringify(this.deviceTrust, null, 2)
                  ), [7];
                case 7:
                  return [2];
              }
            });
          });
        }, t.prototype.closeTrustStore = function() {
          try {
            this.crossStorage.close(this.devEnv), this.indexedDBStorage && this.indexedDBStorage.close();
          } catch (e) {
            s._POSignalsUtils.Logger.info("Unable to close trust store:", e);
          }
        }, t.prototype.fallbackToCrossStorage = function(e) {
          return Z(this, void 0, void 0, function() {
            var n;
            return $(this, function(i) {
              switch (i.label) {
                case 0:
                  s._POSignalsUtils.Logger.debug(
                    "PingOne Signals cross storage is required, initializing"
                  ), i.label = 1;
                case 1:
                  return i.trys.push([1, 3, , 4]), [4, this.initCrossStorage(e)];
                case 2:
                  return i.sent(), s._POSignalsUtils.Logger.info("PingOne Signals cross storage initiated"), [3, 4];
                case 3:
                  return n = i.sent(), s._POSignalsUtils.Logger.warn(
                    "PingOne Signals Session crossStorage failed to connect " + n
                  ), this._disabledStorage.push("hub"), this.crossStorage = new h.CrossStorageFallback(this.signalsLocalStorage), [3, 4];
                case 4:
                  return [2];
              }
            });
          });
        }, t.prototype.initCrossStorage = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i, a, u, c;
            return $(this, function(l) {
              switch (l.label) {
                case 0:
                  return n = this.universalTrustEnabled ? "1.0.7" : "1.0.1", i = "https://apps.pingone.com/signals/web-sdk/hub-" + n + "/hub.html", (a = ((e == null ? void 0 : e.trim()) || i).replace(
                    /\/$/,
                    ""
                  )).endsWith("html") || (a += "/hub.html"), this.crossStorage = new h.CrossStorage(a, { timeout: 2e3 }), [4, this.crossStorage.onConnect()];
                case 1:
                  return l.sent(), this.universalTrustEnabled ? [
                    4,
                    this.crossStorage.getDeviceDetails(
                      s._POSignalsUtils.Constants.DEVICE_ID_KEY
                    )
                  ] : [3, 3];
                case 2:
                  return u = l.sent(), this.cachedDeviceId = u[0], [3, 5];
                case 3:
                  return c = this, [4, this.crossStorage.get(s._POSignalsUtils.Constants.DEVICE_ID_KEY)];
                case 4:
                  c.cachedDeviceId = l.sent(), l.label = 5;
                case 5:
                  return this.cachedDeviceId ? this.signalsLocalStorage.setItem(
                    s._POSignalsUtils.Constants.DEVICE_ID_KEY,
                    this.cachedDeviceId
                  ) : s._POSignalsUtils.Logger.info("no device id from hub"), this.universalTrustEnabled && (u && u[1] ? (this.deviceTrust.attestation.fallbackDeviceKey = u[1], s._POSignalsUtils.Logger.info(
                    "Using fallback device keys from hub " + this.deviceTrust.attestation.fallbackDeviceKey
                  )) : s._POSignalsUtils.Logger.info("failed to use any device keys")), [2];
              }
            });
          });
        }, t.prototype.isUniversalTrustEnabled = function(e) {
          return e != null && (typeof e == "boolean" ? e : typeof e == "string" && e.toLowerCase() === "true");
        }, t;
      }();
      h.SessionStorage = r;
    })(s._POSignalsStorage || (s._POSignalsStorage = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function e(n) {
          this.storage = n;
        }
        return e.prototype.getItem = function(n) {
          var i = s._POSignalsUtils.Util.hash(n), a = this.storage.getItem(i);
          return a || (a = this.storage.getItem(n)) && (this.storage.setItem(i, a), this.storage.removeItem(n)), a;
        }, e.prototype.removeItem = function(n) {
          return this.storage.removeItem(s._POSignalsUtils.Util.hash(n));
        }, e.prototype.setItem = function(n, i) {
          return this.storage.setItem(s._POSignalsUtils.Util.hash(n), i);
        }, e;
      }();
      h.StorageWrapper = r;
      var t = function() {
        function e() {
          this.internalStorageMap = /* @__PURE__ */ new Map();
        }
        return e.prototype.getItem = function(n) {
          return this.internalStorageMap.get(n);
        }, e.prototype.removeItem = function(n) {
          this.internalStorageMap.delete(n);
        }, e.prototype.setItem = function(n, i) {
          this.internalStorageMap.set(n, i);
        }, e;
      }();
      h.StorageFallback = t;
    })(s._POSignalsStorage || (s._POSignalsStorage = {}));
  }(M || (M = {})), ve = function() {
    return (ve = Object.assign || function(s) {
      for (var h, r = 1, t = arguments.length; r < t; r++)
        for (var e in h = arguments[r])
          Object.prototype.hasOwnProperty.call(h, e) && (s[e] = h[e]);
      return s;
    }).apply(this, arguments);
  }, Z = function(s, h, r, t) {
    return new (r || (r = Promise))(function(e, n) {
      function i(c) {
        try {
          u(t.next(c));
        } catch (l) {
          n(l);
        }
      }
      function a(c) {
        try {
          u(t.throw(c));
        } catch (l) {
          n(l);
        }
      }
      function u(c) {
        var l;
        c.done ? e(c.value) : (l = c.value, l instanceof r ? l : new r(function(d) {
          d(l);
        })).then(i, a);
      }
      u((t = t.apply(s, h || [])).next());
    });
  }, $ = function(s, h) {
    var r, t, e, n, i = {
      label: 0,
      sent: function() {
        if (1 & e[0])
          throw e[1];
        return e[1];
      },
      trys: [],
      ops: []
    };
    return n = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (n[Symbol.iterator] = function() {
      return this;
    }), n;
    function a(u) {
      return function(c) {
        return function(l) {
          if (r)
            throw new TypeError("Generator is already executing.");
          for (; i; )
            try {
              if (r = 1, t && (e = 2 & l[0] ? t.return : l[0] ? t.throw || ((e = t.return) && e.call(t), 0) : t.next) && !(e = e.call(t, l[1])).done)
                return e;
              switch (t = 0, e && (l = [2 & l[0], e.value]), l[0]) {
                case 0:
                case 1:
                  e = l;
                  break;
                case 4:
                  return i.label++, { value: l[1], done: !1 };
                case 5:
                  i.label++, t = l[1], l = [0];
                  continue;
                case 7:
                  l = i.ops.pop(), i.trys.pop();
                  continue;
                default:
                  if (!(e = (e = i.trys).length > 0 && e[e.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                    i = 0;
                    continue;
                  }
                  if (l[0] === 3 && (!e || l[1] > e[0] && l[1] < e[3])) {
                    i.label = l[1];
                    break;
                  }
                  if (l[0] === 6 && i.label < e[1]) {
                    i.label = e[1], e = l;
                    break;
                  }
                  if (e && i.label < e[2]) {
                    i.label = e[2], i.ops.push(l);
                    break;
                  }
                  e[2] && i.ops.pop(), i.trys.pop();
                  continue;
              }
              l = h.call(s, i);
            } catch (d) {
              l = [6, d], t = 0;
            } finally {
              r = e = 0;
            }
          if (5 & l[0])
            throw l[1];
          return { value: l[0] ? l[1] : void 0, done: !0 };
        }([u, c]);
      };
    }
  }, function(s) {
    (function(h) {
      var r = function() {
        function t() {
        }
        return t.prototype.isCanvasSupported = function() {
          var e = document.createElement("canvas");
          return !(!e.getContext || !e.getContext("2d"));
        }, t.prototype.getWebglCanvas = function(e) {
          var n = document.createElement("canvas"), i = null;
          try {
            i = e === "webgl" ? n.getContext("webgl") || n.getContext("experimental-webgl") : n.getContext("webgl2");
          } catch {
          }
          return i || (i = null), i;
        }, t.prototype.isWebGlSupported = function(e) {
          if (!this.isCanvasSupported())
            return !1;
          var n = this.getWebglCanvas(e);
          return (e === "webgl" ? !!window.WebGLRenderingContext : !!window.WebGL2RenderingContext) && !!n;
        }, t.prototype.isWebGl = function(e) {
          return !!this.isWebGlSupported(e) && !!this.getWebglCanvas(e);
        }, t.prototype.getWebglVendorAndRenderer = function(e) {
          try {
            if (this.isWebGlSupported(e)) {
              var n = this.getWebglCanvas(e), i = n.getExtension("WEBGL_debug_renderer_info");
              return n.getParameter(i.UNMASKED_VENDOR_WEBGL) + "~" + n.getParameter(i.UNMASKED_RENDERER_WEBGL);
            }
          } catch {
          }
          return null;
        }, t.prototype.getHasLiedLanguages = function() {
          if (navigator.languages !== void 0)
            try {
              if (navigator.languages[0].substr(0, 2) !== navigator.language.substr(0, 2))
                return !0;
            } catch {
              return !0;
            }
          return !1;
        }, t.prototype.getHasLiedResolution = function() {
          return window.screen.width < window.screen.availWidth || window.screen.height < window.screen.availHeight;
        }, t.prototype.getHasLiedOs = function() {
          var e, n = navigator.userAgent.toLowerCase(), i = navigator.oscpu, a = navigator.platform.toLowerCase();
          return e = n.indexOf("windows phone") >= 0 ? "Windows Phone" : n.indexOf("win") >= 0 ? "Windows" : n.indexOf("android") >= 0 ? "Android" : n.indexOf("linux") >= 0 || n.indexOf("cros") >= 0 ? "Linux" : n.indexOf("iphone") >= 0 || n.indexOf("ipad") >= 0 ? "iOS" : n.indexOf("mac") >= 0 ? "Mac" : "Other", ("ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) && e !== "Windows Phone" && e !== "Android" && e !== "iOS" && e !== "Other" || i !== void 0 && ((i = i.toLowerCase()).indexOf("win") >= 0 && e !== "Windows" && e !== "Windows Phone" || i.indexOf("linux") >= 0 && e !== "Linux" && e !== "Android" || i.indexOf("mac") >= 0 && e !== "Mac" && e !== "iOS" || (i.indexOf("win") === -1 && i.indexOf("linux") === -1 && i.indexOf("mac") === -1) != (e === "Other")) ? !0 : a.indexOf("win") >= 0 && e !== "Windows" && e !== "Windows Phone" || (a.indexOf("linux") >= 0 || a.indexOf("android") >= 0 || a.indexOf("pike") >= 0) && e !== "Linux" && e !== "Android" || (a.indexOf("mac") >= 0 || a.indexOf("ipad") >= 0 || a.indexOf("ipod") >= 0 || a.indexOf("iphone") >= 0) && e !== "Mac" && e !== "iOS" || (a.indexOf("win") < 0 && a.indexOf("linux") < 0 && a.indexOf("mac") < 0 && a.indexOf("iphone") < 0 && a.indexOf("ipad") < 0) != (e === "Other") || navigator.plugins === void 0 && e !== "Windows" && e !== "Windows Phone";
        }, t.prototype.getHasLiedBrowser = function() {
          var e, n = navigator.userAgent.toLowerCase(), i = navigator.productSub;
          if (((e = n.indexOf("firefox") >= 0 ? "Firefox" : n.indexOf("opera") >= 0 || n.indexOf("opr") >= 0 ? "Opera" : n.indexOf("chrome") >= 0 ? "Chrome" : n.indexOf("safari") >= 0 ? "Safari" : n.indexOf("trident") >= 0 ? "Internet Explorer" : "Other") == "Chrome" || e === "Safari" || e === "Opera") && i !== "20030107")
            return !0;
          var a, u = eval.toString().length;
          if (u === 37 && e !== "Safari" && e !== "Firefox" && e !== "Other" || u === 39 && e !== "Internet Explorer" && e !== "Other" || u === 33 && e !== "Chrome" && e !== "Opera" && e !== "Other")
            return !0;
          try {
            throw "a";
          } catch (c) {
            try {
              c.toSource(), a = !0;
            } catch {
              a = !1;
            }
          }
          return a && e !== "Firefox" && e !== "Other";
        }, t;
      }();
      h.FingerprintLegacyMetadata = r;
    })(s._POSignalsMetadata || (s._POSignalsMetadata = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t(e, n) {
          this.sessionData = e, this.metadataParams = n, this.deviceId = null, this.hasMicrophone = null, this.hasSpeakers = null, this.hasWebcam = null, this.isBatterySupported = null, this.batteryLevel = null, this.batteryCharging = null, this.batteryChargingTime = null, this.batteryDischargingTime = null, this.headlessTests = /* @__PURE__ */ new Map(), this.lieTests = {}, this.gpsSupported = null, this.fingerPrintComponentKeys = /* @__PURE__ */ new Set([
            "navigatorPlatform",
            "colorDepth",
            "deviceMemory",
            "pixelRatio",
            "hardwareConcurrency",
            "screenResolution",
            "availableScreenResolution",
            "timezoneOffset",
            "timezone",
            "sessionStorage",
            "localStorage",
            "indexedDB",
            "addBehavior",
            "openDatabase",
            "cpuClass",
            "platform",
            "canvas",
            "adBlock",
            "touchSupport",
            "fonts",
            "audio",
            "osCpu",
            "productSub",
            "emptyEvalLength",
            "errorFF",
            "chrome",
            "cookiesEnabled"
          ]), this.webGlStatus = -1, this.numberOfVideoDevices = 0, this.numberOfAudioDevices = 0, this.videoInputDevices = [], this.audioInputDevices = [], this.audioOutputDevices = [], this.webRtcIps = /* @__PURE__ */ new Map(), this.lastCalculatedMetadata = null, this.metadataQueue = new s.PromiseQueue(1);
        }
        return Object.defineProperty(t.prototype, "OPS", {
          get: function() {
            if (!this.metadataParams.browserInfo.isIphoneOrIPad)
              return 0;
            var e = this.sessionData.ops;
            return e || (e = this.getOps(), this.sessionData.ops = e), e;
          },
          enumerable: !1,
          configurable: !0
        }), t.prototype.getDeviceAttributes = function() {
          return Z(this, void 0, void 0, function() {
            var e = this;
            return $(this, function(n) {
              return [
                2,
                this.metadataQueue.add(function() {
                  return Z(e, void 0, void 0, function() {
                    var i;
                    return $(this, function(a) {
                      switch (a.label) {
                        case 0:
                          return this.lastCalculatedMetadata ? [3, 3] : (i = this, [4, this.calculateDeviceMetadata()]);
                        case 1:
                          return i.lastCalculatedMetadata = a.sent(), s._POSignalsUtils.Logger.info("calculated device attributes."), s._POSignalsUtils.Logger.info(
                            "PingOne Signals deviceId: " + this.deviceId
                          ), [4, this.sessionData.addAssertion(this.lastCalculatedMetadata)];
                        case 2:
                          a.sent(), this.sessionData.closeTrustStore(), a.label = 3;
                        case 3:
                          return [2, this.lastCalculatedMetadata];
                      }
                    });
                  });
                })
              ];
            });
          });
        }, t.prototype.getObfsInfo = function() {
          return { identifier: "x1", key: "Xq7tSbjB517mhZwt" };
        }, t.prototype.calculateDeviceMetadata = function() {
          return Z(this, void 0, void 0, function() {
            var e, n, i, a, u;
            return $(this, function(c) {
              switch (c.label) {
                case 0:
                  return this.gpsSupported = navigator.geolocation != null, e = this.metadataParams.metadataBlackList, n = [
                    this.sessionData.initDeviceIdentity().catch(function(l) {
                      s._POSignalsUtils.Logger.warn("failed to get deviceId info", l);
                    }),
                    this.getFingerPrint(e).catch(function(l) {
                      s._POSignalsUtils.Logger.warn(
                        "failed to get fingerprint info",
                        l.message
                      );
                    }),
                    this.getPrivateMode().catch(function(l) {
                      return s._POSignalsUtils.Logger.warn("failed to get incognito info", l);
                    }),
                    h.Incognito.isPrivateMode().catch(function(l) {
                      return s._POSignalsUtils.Logger.warn(
                        "failed to get private mode info",
                        l
                      );
                    }),
                    this.getPermissionsMetadata().catch(function(l) {
                      return s._POSignalsUtils.Logger.warn(
                        "failed to get permissions info",
                        l
                      );
                    }),
                    new h.DetectHeadless(e).getHeadlessResults().catch(function(l) {
                      return s._POSignalsUtils.Logger.warn(
                        "failed to get headless results",
                        l
                      );
                    }),
                    new h.DetectLies(e).getAllLies().catch(function(l) {
                      return s._POSignalsUtils.Logger.warn("failed to get lies results", l);
                    }),
                    this.audioIntVideoInit().catch(function(l) {
                      return s._POSignalsUtils.Logger.warn(
                        "failed to get audio-video info",
                        l
                      );
                    }),
                    this.batteryInit().catch(function(l) {
                      return s._POSignalsUtils.Logger.warn("failed to get battery info", l);
                    })
                  ], [4, Promise.all(n)];
                case 1:
                  return u = c.sent(), this.deviceId = u[0], this.fingerPrint = u[1], this.isPrivateMode = u[2], this.isPrivateModeV2 = u[3], this.permissions = u[4], this.headlessTests = u[5], this.lieTests = u[6], i = {
                    ops: this.OPS,
                    devicePixelRatio: window.devicePixelRatio,
                    screenWidth: window.screen.width,
                    screenHeight: window.screen.height
                  }, s._POSignalsUtils.Util.extendPrimitiveValues(i, screen, !1), a = [
                    {
                      deviceId: this.deviceId,
                      deviceType: this.metadataParams.browserInfo.deviceType,
                      osVersion: (this.metadataParams.browserInfo.osName + " " + this.metadataParams.browserInfo.osVersion).trim() || ""
                    }
                  ], [4, this.getIdentificationMetadata(e)];
                case 2:
                  return [
                    2,
                    ve.apply(void 0, [
                      ve.apply(void 0, [
                        ve.apply(void 0, [
                          ve.apply(void 0, a.concat([c.sent()])),
                          this.getIoMetadata()
                        ]),
                        this.getSensorsMetadata()
                      ]),
                      i
                    ])
                  ];
              }
            });
          });
        }, t.prototype.batteryInit = function() {
          return Z(this, void 0, void 0, function() {
            var e, n = this;
            return $(this, function(i) {
              switch (i.label) {
                case 0:
                  return e = this, [
                    4,
                    s._POSignalsUtils.Util.promiseTimeout(
                      50,
                      new Promise(function(a, u) {
                        navigator.getBattery ? (n.isBatterySupported = !0, navigator.getBattery().then(function(c) {
                          c && (e.batteryLevel = c.level, e.batteryCharging = c.charging, e.batteryChargingTime = c.chargingTime, e.batteryDischargingTime = c.dischargingTime), a();
                        }).catch(function(c) {
                          s._POSignalsUtils.Logger.warn("Battery " + c), a();
                        })) : (s._POSignalsUtils.Logger.debug("Battery not supported!"), a());
                      })
                    )
                  ];
                case 1:
                  return i.sent(), [2];
              }
            });
          });
        }, t.prototype.enumerateDevicesEnabled = function() {
          var e = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          return !s._POSignalsUtils.Util.inIframe() || !e;
        }, t.prototype.getRTCPeerConnection = function() {
          var e = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
          if (!e) {
            var n = window["iframe.contentWindow"];
            n && (e = n.RTCPeerConnection || n.mozRTCPeerConnection || n.webkitRTCPeerConnection);
          }
          return e;
        }, t.prototype.collectWebRtc = function() {
          var e = this;
          try {
            var n = {}, i = this.getRTCPeerConnection(), a = new i(
              { iceServers: [{ urls: this.metadataParams.webRtcUrl.trim() }] },
              { optional: [{ RtpDataChannels: !0 }] }
            );
            a.onicecandidate = function(u) {
              if (u.candidate) {
                var c = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/.exec(
                  u.candidate.candidate
                )[1];
                n[c] === void 0 && (u.candidate.candidate.indexOf("host") > 0 ? e.webRtcIps.set("WEB_RTC_HOST_IP", c) : u.candidate.candidate.indexOf("srflx") > 0 && e.webRtcIps.set("WEB_RTC_SRFLX_IP", c)), n[c] = !0;
              }
            }, a.createDataChannel(""), a.createOffer(
              function(u) {
                a.setLocalDescription(
                  u,
                  function() {
                  },
                  function() {
                  }
                );
              },
              function() {
              }
            );
          } catch {
          }
        }, t.prototype.audioIntVideoInit = function() {
          return Z(this, void 0, void 0, function() {
            var e, n = this;
            return $(this, function(i) {
              switch (i.label) {
                case 0:
                  return e = this, [
                    4,
                    s._POSignalsUtils.Util.promiseTimeout(
                      50,
                      new Promise(function(a, u) {
                        return n.enumerateDevicesEnabled() ? navigator.mediaDevices && navigator.mediaDevices.enumerateDevices ? void navigator.mediaDevices.enumerateDevices().then(function(c) {
                          c.forEach(function(l) {
                            l.kind && (l.kind.toLowerCase() == "audioinput" ? (e.hasMicrophone = !0, e.numberOfAudioDevices++, l.label && e.audioInputDevices.push(l.label)) : l.kind.toLowerCase() == "videoinput" ? (e.hasWebcam = !0, e.numberOfVideoDevices++, l.label && e.videoInputDevices.push(l.label)) : l.kind.toLowerCase() == "audiooutput" && (e.hasSpeakers = !0, e.numberOfAudioDevices++, l.label && e.audioOutputDevices.push(l.label)));
                          }), a();
                        }).catch(function(c) {
                          s._POSignalsUtils.Logger.warn("enumerateDevices failed", c), a();
                        }) : (s._POSignalsUtils.Logger.debug(
                          "enumerateDevices() not supported."
                        ), void a()) : (s._POSignalsUtils.Logger.debug(
                          "enumerateDevices() cannot run within safari iframe"
                        ), void a());
                      })
                    )
                  ];
                case 1:
                  return i.sent(), [2];
              }
            });
          });
        }, t.prototype.getFingerPrint = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i, a = this;
            return $(this, function(u) {
              switch (u.label) {
                case 0:
                  return e.has("fingerprint") ? [2, Promise.resolve("")] : (n = new Promise(function(c, l) {
                    return Z(a, void 0, void 0, function() {
                      var d, p;
                      return $(this, function(m) {
                        switch (m.label) {
                          case 0:
                            return m.trys.push([0, 3, , 4]), [4, s.FingerprintJS.load()];
                          case 1:
                            return [4, m.sent().get()];
                          case 2:
                            return d = m.sent(), this.fingerPrint = d.visitorId, this.fingerPrintComponents = d.components, c(d.visitorId), [3, 4];
                          case 3:
                            return p = m.sent(), s._POSignalsUtils.Logger.warn(
                              "Failed to get FingerPrint " + p
                            ), l({ err: p, message: "FingerPrint failed" }), [3, 4];
                          case 4:
                            return [2];
                        }
                      });
                    });
                  }), i = new Promise(function(c, l) {
                    return Z(a, void 0, void 0, function() {
                      return $(this, function(d) {
                        switch (d.label) {
                          case 0:
                            return [
                              4,
                              s._POSignalsUtils.Util.delay(
                                this.metadataParams.fingerprintTimeoutMillis
                              )
                            ];
                          case 1:
                            return d.sent(), l({ message: "Fingerprint timeout" }), [2];
                        }
                      });
                    });
                  }), [4, Promise.race([n, i])]);
                case 1:
                  return [2, u.sent()];
              }
            });
          });
        }, t.prototype.getSensorsMetadata = function() {
          var e = {};
          return this.flatAndAddMetadata(e, "DEDVCE_LIGHT_SUPPORTED", function() {
            return "ondevicelight" in window;
          }), this.flatAndAddMetadata(e, "IS_TOUCH_DEVICE", function() {
            return "ontouchstart" in window;
          }), window.DeviceMotionEvent || this.flatAndAddMetadata(e, "ACCELEROMETER_SUPPORTED", function() {
            return !1;
          }), window.DeviceOrientationEvent || this.flatAndAddMetadata(e, "GYROSCOPE_SUPPORTED", function() {
            return !1;
          }), this.flatAndAddMetadata(e, "PROXIMITY_SUPPORTED", function() {
            return "ondeviceproximity" in window;
          }), e;
        }, t.prototype.getIdentificationMetadata = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i, a, u, c, l, d, p, m, k, x, y, C, A, P, D, j, z, B, T, L, E = this;
            return $(this, function(H) {
              switch (H.label) {
                case 0:
                  return n = this, i = {}, this.flatAndAddMetadata(i, "FINGER_PRINT", function() {
                    return E.fingerPrint;
                  }), this.metadataParams.browserInfo.userAgentData && (this.flatAndAddMetadata(i, "OS_NAME", function() {
                    return E.metadataParams.browserInfo.osName;
                  }), this.flatAndAddMetadata(i, "OS_VERSION", function() {
                    return E.metadataParams.browserInfo.osVersion;
                  })), this.metadataParams.browserInfo.userAgentData && (this.flatAndAddMetadata(i, "DEVICE_MODEL", function() {
                    return E.metadataParams.browserInfo.deviceModel;
                  }), this.flatAndAddMetadata(i, "DEVICE_VENDOR", function() {
                    return E.metadataParams.browserInfo.deviceVendor;
                  })), this.metadataParams.browserInfo.userAgentData && (this.flatAndAddMetadata(i, "BROWSER_ENGINE_NAME", function() {
                    return E.metadataParams.browserInfo.engineName;
                  }), this.flatAndAddMetadata(i, "BROWSER_ENGINE_VERSION", function() {
                    return E.metadataParams.browserInfo.engineVersion;
                  })), this.metadataParams.browserInfo.userAgentData && this.flatAndAddMetadata(i, "CPU_ARCHITECTURE", function() {
                    return E.metadataParams.browserInfo.cpuArchitecture;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_VENDOR", function() {
                    return navigator.vendor;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_PLUGINS_LENGTH", function() {
                    return navigator.plugins ? navigator.plugins.length : null;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_MIME_TYPES_LENGTH", function() {
                    return navigator.mimeTypes ? navigator.mimeTypes.length : null;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_LANGUAGE", function() {
                    return navigator.language || navigator.userLanguage || navigator.browserLanguage || navigator.systemLanguage;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_LANGUAGES", function() {
                    return navigator.languages;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_MAX_TOUCH_POINTS", function() {
                    return navigator.maxTouchPoints || navigator.msMaxTouchPoints;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_POINTER_ENABLED", function() {
                    return navigator.pointerEnabled || navigator.msPointerEnabled;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_WEB_DRIVER", function() {
                    return navigator.webdriver;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_HARDWARE_CONCURRENCY", function() {
                    return navigator.hardwareConcurrency;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_VIBRATE", function() {
                    return navigator.vibrate != null;
                  }), this.flatAndAddMetadata(i, "PUSH_NOTIFICATIONS_SUPPORTED", function() {
                    return "Notification" in window;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_APP_CODE_NAME", function() {
                    return navigator.appCodeName;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_APP_NAME", function() {
                    return navigator.appName;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_APP_VERSION", function() {
                    return navigator.appVersion;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_ON_LINE", function() {
                    return navigator.onLine;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_PLATFORM", function() {
                    return navigator.platform;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_PRODUCT", function() {
                    return navigator.product;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_USER_AGENT", function() {
                    return navigator.userAgent;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_PDF_VIEWER_ENABLED", function() {
                    return navigator.pdfViewerEnabled;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_DEVICE_MEMORY", function() {
                    return navigator.deviceMemory;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_CONNECTION_RTT", function() {
                    return navigator.connection ? navigator.connection.rtt : null;
                  }), e.has("modernizr") ? [3, 2] : [4, this.safeAddModernizrFeatures(i)];
                case 1:
                  H.sent(), H.label = 2;
                case 2:
                  if ((a = window._pingOneSignalsPingResult || window._ST_PING) ? this.flatAndAddMetadata(i, "JS_CHALLENGE", function() {
                    return a;
                  }) : this.flatAndAddMetadata(i, "JS_CHALLENGE", function() {
                    return "unknown";
                  }), u = new h.FingerprintLegacyMetadata(), this.flatAndAddMetadata(i, "IS_WEBGL", function() {
                    return u.isWebGl("webgl");
                  }), this.flatAndAddMetadata(i, "WEBGLVENDORANDRENDERER", function() {
                    return u.getWebglVendorAndRenderer("webgl");
                  }), this.flatAndAddMetadata(i, "IS_WEBGL2", function() {
                    return u.isWebGl("webgl2");
                  }), this.flatAndAddMetadata(i, "WEBGL2VENDORANDRENDERER", function() {
                    return u.getWebglVendorAndRenderer("webgl2");
                  }), this.flatAndAddMetadata(i, "HASLIEDLANGUAGES", function() {
                    return u.getHasLiedLanguages();
                  }), this.flatAndAddMetadata(i, "HASLIEDRESOLUTION", function() {
                    return u.getHasLiedResolution();
                  }), this.flatAndAddMetadata(i, "HASLIEDOS", function() {
                    return u.getHasLiedOs();
                  }), this.flatAndAddMetadata(i, "HASLIEDBROWSER", function() {
                    return u.getHasLiedBrowser();
                  }), this.fingerPrintComponents)
                    for (d in c = function(S) {
                      if (!l.fingerPrintComponents.hasOwnProperty(S))
                        return "continue";
                      var U = l.fingerPrintComponents[S];
                      S == "fonts" ? l.flatAndAddMetadata(i, "JS_FONTS", function() {
                        return U.value.length;
                      }) : S == "canvas" ? l.flatAndAddMetadata(i, "IS_CANVAS", function() {
                        return U.value != null;
                      }) : S == "screenResolution" && U.value && U.value.length ? l.flatAndAddMetadata(i, "RESOLUTION", function() {
                        return U.value.join(",");
                      }) : S == "availableScreenResolution" && U.value && U.value.length ? l.flatAndAddMetadata(i, "AVAILABLE_RESOLUTION", function() {
                        return U.value.join(",");
                      }) : S == "touchSupport" && U.value ? l.flatAndAddMetadata(i, "TOUCH_SUPPORT", function() {
                        return U.value;
                      }) : S == "audio" && U.value ? l.flatAndAddMetadata(i, "AUDIO_FINGERPRINT", function() {
                        return U.value;
                      }) : S == "osCpu" && U.value ? l.flatAndAddMetadata(i, "OS_CPU", function() {
                        return U.value;
                      }) : S == "productSub" && U.value ? l.flatAndAddMetadata(i, "PRODUCT_SUB", function() {
                        return U.value;
                      }) : S == "emptyEvalLength" && U.value ? l.flatAndAddMetadata(
                        i,
                        "EMPTY_EVAL_LENGTH",
                        function() {
                          return U.value;
                        }
                      ) : S == "errorFF" && U.value ? l.flatAndAddMetadata(i, "ERROR_FF", function() {
                        return U.value;
                      }) : S == "chrome" && U.value ? l.flatAndAddMetadata(i, "CHROME", function() {
                        return U.value;
                      }) : S == "cookiesEnabled" && U.value ? l.flatAndAddMetadata(
                        i,
                        "COOKIES_ENABLED",
                        function() {
                          return U.value;
                        }
                      ) : n.fingerPrintComponentKeys.has(S) && S != null && l.flatAndAddMetadata(
                        i,
                        S.toUpperCase(),
                        function() {
                          return U.value;
                        }
                      );
                    }, l = this, this.fingerPrintComponents)
                      c(d);
                  for (y in this.flatAndAddMetadata(i, "IS_INCOGNITO", function() {
                    return E.isPrivateMode;
                  }), this.flatAndAddMetadata(i, "IS_PRIVATE_MODE", function() {
                    return E.isPrivateModeV2;
                  }), this.flatAndAddMetadata(i, "IS_WEB_GLSTATUS", function() {
                    return E.webGlStatus;
                  }), p = {
                    selenium: navigator.webdriver || s._POSignalsUtils.Util.getAttribute(
                      window.document.documentElement,
                      "webdriver"
                    ) || "",
                    phantomjs: {
                      _phantom: window._phantom || "",
                      __phantomas: window.__phantomas || "",
                      callPhantom: window.callPhantom || ""
                    },
                    nodejs: { Buffer: window.Buffer || "" },
                    couchjs: { emit: window.emit || "" },
                    rhino: { spawn: window.spawn || "" },
                    chromium: {
                      domAutomationController: window.domAutomationController || "",
                      domAutomation: window.domAutomation || ""
                    },
                    outerWidth: window.outerWidth,
                    outerHeight: window.outerHeight
                  }, this.flatAndAddMetadata(i, "HEADLESS", function() {
                    return p;
                  }), this.flatAndAddMetadata(i, "HEADLESS", function() {
                    return E.headlessTests;
                  }), this.flatAndAddMetadata(i, "LIES", function() {
                    var S = {};
                    for (var U in E.lieTests)
                      S[U] = JSON.stringify(E.lieTests[U]);
                    return Object.keys(S).length > 0 ? S : null;
                  }), this.flatAndAddMetadata(i, "STEALTH", function() {
                    return new h.DetectStealth(e).getStealthResult();
                  }), this.flatAndAddMetadata(i, "REF_LINK", function() {
                    return document.referrer;
                  }), this.flatAndAddMetadata(i, "PLUGINS", function() {
                    for (var S = { length: navigator.plugins.length, details: [] }, U = 0; U < S.length; U++)
                      S.details.push({
                        length: navigator.plugins[U].length,
                        name: navigator.plugins[U].name,
                        version: navigator.plugins[U].version,
                        filename: navigator.plugins[U].filename
                      });
                    return S;
                  }), this.flatAndAddMetadata(i, "AUDIO", function() {
                    return E.numberOfAudioDevices;
                  }), this.flatAndAddMetadata(i, "VIDEO", function() {
                    return E.numberOfVideoDevices;
                  }), this.flatAndAddMetadata(i, "VIDEO_INPUT_DEVICES", function() {
                    return E.videoInputDevices.toString();
                  }), this.flatAndAddMetadata(i, "AUDIO_INPUT_DEVICES", function() {
                    return E.audioInputDevices.toString();
                  }), this.flatAndAddMetadata(i, "AUDIO_OUTPUT_DEVICES", function() {
                    return E.audioOutputDevices.toString();
                  }), this.flatAndAddMetadata(i, "MEDIA_CODEC_MP4_AVC1", function() {
                    return E.getMediaCodec('video/mp4;; codecs = "avc1.42E01E"');
                  }), this.flatAndAddMetadata(i, "MEDIA_CODEC_X_M4A", function() {
                    return E.getMediaCodec("audio/x-m4a");
                  }), this.flatAndAddMetadata(i, "MEDIA_CODEC_AAC", function() {
                    return E.getMediaCodec("audio/aac");
                  }), m = this.metadataParams.additionalMediaCodecs, k = function(S) {
                    if (!m.hasOwnProperty(S))
                      return "continue";
                    x.flatAndAddMetadata(i, "MEDIA_CODEC_" + S, function() {
                      return E.getMediaCodec(m[S]);
                    });
                  }, x = this, m)
                    k(y);
                  window.performance && window.performance.memory && (this.flatAndAddMetadata(i, "MEMORY_HEAP_SIZE_LIMIT", function() {
                    return window.performance.memory.jsHeapSizeLimit;
                  }), this.flatAndAddMetadata(i, "MEMORY_TOTAL_HEAP_SIZE", function() {
                    return window.performance.memory.totalJSHeapSize;
                  }), this.flatAndAddMetadata(i, "MEMORY_USED_HEAP_SIZE", function() {
                    return window.performance.memory.usedJSHeapSize;
                  })), this.flatAndAddMetadata(i, "IS_ACCEPT_COOKIES", function() {
                    return navigator.cookieEnabled;
                  }), this.flatAndAddMetadata(i, "selenium_in_document", function() {
                    return h.SeleniumProperties.seleniumInDocument();
                  }), this.flatAndAddMetadata(i, "selenium_in_window", function() {
                    return h.SeleniumProperties.seleniumInWindow();
                  }), this.flatAndAddMetadata(i, "selenium_in_navigator", function() {
                    return h.SeleniumProperties.seleniumInNavigator();
                  }), this.flatAndAddMetadata(i, "selenium_sequentum", function() {
                    return h.SeleniumProperties.seleniumSequentum();
                  }), this.flatAndAddMetadata(i, "DOCUMENT_ELEMENT_SELENIUM", function() {
                    return s._POSignalsUtils.Util.getAttribute(
                      window.document.documentElement,
                      "selenium"
                    );
                  }), this.flatAndAddMetadata(i, "DOCUMENT_ELEMENT_WEBDRIVER", function() {
                    return s._POSignalsUtils.Util.getAttribute(
                      window.document.documentElement,
                      "webdriver"
                    );
                  }), this.flatAndAddMetadata(i, "DOCUMENT_ELEMENT_DRIVER", function() {
                    return s._POSignalsUtils.Util.getAttribute(
                      window.document.documentElement,
                      "driver"
                    );
                  }), this.flatAndAddMetadata(i, "window_html_webdriver", function() {
                    return !!s._POSignalsUtils.Util.getAttribute(
                      document.getElementsByTagName("html")[0],
                      "webdriver"
                    );
                  }), this.flatAndAddMetadata(i, "window_geb", function() {
                    return !!window.geb;
                  }), this.flatAndAddMetadata(i, "window_awesomium", function() {
                    return !!window.awesomium;
                  }), this.flatAndAddMetadata(i, "window_RunPerfTest", function() {
                    return !!window.RunPerfTest;
                  }), this.flatAndAddMetadata(i, "window_fmget_targets", function() {
                    return !!window.fmget_targets;
                  }), this.flatAndAddMetadata(i, "hasTrustToken", function() {
                    return "hasTrustToken" in document;
                  }), this.flatAndAddMetadata(i, "trustTokenOperationError", function() {
                    return "trustTokenOperationError" in XMLHttpRequest.prototype;
                  }), this.flatAndAddMetadata(i, "setTrustToken", function() {
                    return "setTrustToken" in XMLHttpRequest.prototype;
                  }), this.flatAndAddMetadata(i, "trustToken", function() {
                    return "trustToken" in HTMLIFrameElement.prototype;
                  }), this.flatAndAddMetadata(i, "localStorage.length", function() {
                    return localStorage.length;
                  }), this.flatAndAddMetadata(i, "sessionStorage.length", function() {
                    return sessionStorage.length;
                  }), this.sessionData.disabledStorage.forEach(function(S) {
                    E.flatAndAddMetadata(i, S.toUpperCase() + "_FAILED", function() {
                      return !0;
                    });
                  }), this.flatAndAddMetadata(i, "WEB_RTC_ENABLED", function() {
                    return !!E.getRTCPeerConnection();
                  }), this.metadataParams.webRtcUrl && this.metadataParams.webRtcUrl.length > 0 && (this.collectWebRtc(), this.webRtcIps.forEach(function(S, U) {
                    U != null && S != null && E.flatAndAddMetadata(i, U, function() {
                      return S;
                    });
                  }), this.webRtcIps.clear()), window.matchMedia && this.flatAndAddMetadata(i, "MQ_SCREEN", function() {
                    var S = window.matchMedia(
                      "(min-width: " + (window.innerWidth - 1) + "px)"
                    );
                    return { matches: S.matches, media: S.media };
                  }), this.addIframeData(i, e), window.Notification && this.flatAndAddMetadata(i, "NOTIFICATION_PERMISSION", function() {
                    return window.Notification.permission;
                  }), this.flatAndAddMetadata(i, "HAS_CHROME_APP", function() {
                    return window.chrome && "app" in window.chrome;
                  }), this.flatAndAddMetadata(i, "HAS_CHROME_CSI", function() {
                    return window.chrome && "csi" in window.chrome;
                  }), this.flatAndAddMetadata(i, "HAS_CHROME_LOADTIMES", function() {
                    return window.chrome && "loadTimes" in window.chrome;
                  }), this.flatAndAddMetadata(i, "HAS_CHROME_RUNTIME", function() {
                    return window.chrome && "runtime" in window.chrome;
                  }), this.flatAndAddMetadata(i, "CHROMIUM_MATH", t.detectChromium), this.addClientHints(i), this.flatAndAddMetadata(i, "NAVIGATOR_KEYBOARD_SUPPORTED", function() {
                    return !!navigator.keyboard;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_HID_SUPPORTED", function() {
                    return !!navigator.hid;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_SERIAL_SUPPORTED", function() {
                    return !!navigator.serial;
                  }), this.flatAndAddMetadata(i, "NAVIGATOR_PRESENTATION_SUPPORTED", function() {
                    return !!navigator.presentation;
                  }), H.label = 3;
                case 3:
                  return H.trys.push([3, 6, , 7]), e.has("floc") || !s.Util.isFunction(document.interestCohort) ? [3, 5] : [4, s.Util.promiseTimeout(100, document.interestCohort())];
                case 4:
                  C = H.sent(), A = C.id, P = C.version, this.flatAndAddMetadata(i, "floc_id", function() {
                    return A;
                  }), this.flatAndAddMetadata(i, "floc_version", function() {
                    return P;
                  }), H.label = 5;
                case 5:
                  return [3, 7];
                case 6:
                  return H.sent(), [3, 7];
                case 7:
                  for (z in D = function(S) {
                    j.flatAndAddMetadata(i, S, function() {
                      return s._POSignalsUtils.Util.getProperty(
                        window,
                        E.metadataParams.dataPoints[S]
                      );
                    });
                  }, j = this, this.metadataParams.dataPoints)
                    D(z);
                  for (T in B = this.metadataParams.propertyDescriptors)
                    B.hasOwnProperty(T) && (L = T === "window" ? window : window[T]) && this.addPropertyDescriptorInfo(
                      L,
                      T.toUpperCase() + "_PROPERTY_DESCRIPTOR",
                      B[T],
                      i
                    );
                  return [2, i];
              }
            });
          });
        }, t.prototype.addClientHints = function(e) {
          try {
            var n = navigator.userAgentData;
            if (!n)
              return;
            this.flatAndAddMetadata(e, "NAVIGATOR_CLIENT_HINTS_PLATFORM", function() {
              return n.platform;
            }), this.flatAndAddMetadata(e, "NAVIGATOR_CLIENT_HINTS_MOBILE", function() {
              return n.mobile;
            });
            var i = n.brands;
            if (!i)
              return;
            for (var a = function(l) {
              if (i[l].hasOwnProperty("brand") && i[l].hasOwnProperty("version")) {
                var d = i[l].brand + ":" + i[l].version;
                u.flatAndAddMetadata(e, "NAVIGATOR_CLIENT_HINTS_BRAND_" + l, function() {
                  return d;
                });
              }
            }, u = this, c = 0; c < i.length; c++)
              a(c);
          } catch (l) {
            s._POSignalsUtils.Logger.warn("failed to add client hints", l);
          }
        }, t.prototype.addPropertyDescriptorInfo = function(e, n, i, a) {
          try {
            for (var u = function(p) {
              c.flatAndAddMetadata(a, n + "_" + p.toUpperCase(), function() {
                var m = e.prototype ? e.prototype : e, k = Object.getOwnPropertyDescriptor(m, p);
                if (k) {
                  var x = k.get ? k.get.toString() : void 0;
                  return JSON.stringify({
                    configurable: k.configurable,
                    enumerable: k.enumerable,
                    value: k.value,
                    writable: k.writable,
                    getter: x != null && x.length < 100 ? x : void 0
                  });
                }
                return "undefined";
              });
            }, c = this, l = 0, d = i; l < d.length; l++)
              u(d[l]);
          } catch (p) {
            s._POSignalsUtils.Logger.warn("failed to add properties descriptor", p);
          }
        }, t.prototype.addIframeData = function(e, n) {
          if (!n.has("IFRAME_DATA"))
            try {
              var i = s._POSignalsUtils.Util.createInvisibleElement("iframe");
              if (!i)
                return;
              i.srcdoc = "blank page", document.body.appendChild(i), this.flatAndAddMetadata(e, "IFRAME_CHROME", function() {
                return typeof i.contentWindow.chrome;
              }), this.flatAndAddMetadata(e, "IFRAME_WIDTH", function() {
                return i.contentWindow.screen.width;
              }), this.flatAndAddMetadata(e, "IFRAME_HEIGHT", function() {
                return i.contentWindow.screen.height;
              }), i.remove();
            } catch (a) {
              s._POSignalsUtils.Logger.warn("failed to add iframe data", a);
            }
        }, t.prototype.getPermissionsMetadata = function() {
          return Z(this, void 0, void 0, function() {
            var e, n, i, a, u, c;
            return $(this, function(l) {
              switch (l.label) {
                case 0:
                  if (e = {}, n = [
                    "accelerometer",
                    "accessibility-events",
                    "ambient-light-sensor",
                    "background-sync",
                    "camera",
                    "clipboard-read",
                    "clipboard-write",
                    "geolocation",
                    "gyroscope",
                    "magnetometer",
                    "microphone",
                    "midi",
                    "notifications",
                    "payment-handler",
                    "persistent-storage",
                    "push"
                  ], i = [], navigator.permissions)
                    for (u in a = function(d) {
                      var p = n[d];
                      i.push(
                        navigator.permissions.query({ name: p }).then(function(m) {
                          e[p] = m.state;
                        }).catch(function(m) {
                        })
                      );
                    }, n)
                      a(u);
                  l.label = 1;
                case 1:
                  return l.trys.push([1, 3, , 4]), [4, Promise.all(i)];
                case 2:
                  return l.sent(), [3, 4];
                case 3:
                  return c = l.sent(), s._POSignalsUtils.Logger.warn(c), [3, 4];
                case 4:
                  return [2, e];
              }
            });
          });
        }, t.prototype.getMediaCodec = function(e) {
          var n = document.createElement("video");
          if (n && n.canPlayType)
            return n.canPlayType(e);
        }, t.prototype.safeAddModernizrFeatures = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i, a, u, c, l;
            return $(this, function(d) {
              switch (d.label) {
                case 0:
                  return s.evaluateModernizr(), n = this, i = s.Modernizr, a = i.prefixed, u = i.hasEvent, this.flatAndAddMetadata(e, "ambient_light", function() {
                    return i.ambientlight;
                  }), this.flatAndAddMetadata(e, "application_cache", function() {
                    return i.applicationcache;
                  }), this.flatAndAddMetadata(e, "audio", function() {
                    return !!i.audio;
                  }), i.audio && this.flatAndAddMetadata(e, "audio", function() {
                    return i.audio;
                  }), this.flatAndAddMetadata(e, "battery_api", function() {
                    return !!a("battery", navigator) || !!a("getBattery", navigator);
                  }), this.flatAndAddMetadata(e, "blob_constructor", function() {
                    return i.blobconstructor;
                  }), this.flatAndAddMetadata(e, "context_menu", function() {
                    return i.contextmenu;
                  }), this.flatAndAddMetadata(e, "cors", function() {
                    return i.cors;
                  }), this.flatAndAddMetadata(e, "cryptography", function() {
                    return i.cryptography;
                  }), this.flatAndAddMetadata(e, "custom_elements", function() {
                    return i.customelements;
                  }), this.flatAndAddMetadata(e, "custom_protocol_handler", function() {
                    return i.customprotocolhandler;
                  }), this.flatAndAddMetadata(e, "custom_event", function() {
                    return i.customevent;
                  }), this.flatAndAddMetadata(e, "dart", function() {
                    return i.dart;
                  }), this.flatAndAddMetadata(e, "data_view", function() {
                    return i.dataview;
                  }), this.flatAndAddMetadata(e, "event_listener", function() {
                    return i.eventlistener;
                  }), [4, this.safeModernizrOn("exiforientation")];
                case 1:
                  return c = d.sent(), n.flatAndAddMetadata(e, "exif_orientation", function() {
                    return c;
                  }), this.flatAndAddMetadata(e, "force_touch", function() {
                    return i.forcetouch;
                  }), i.forcetouch && (this.flatAndAddMetadata(
                    e,
                    "force_touch.mouse_force_will_begin",
                    function() {
                      return u(a("mouseforcewillbegin", window, !1), window);
                    }
                  ), this.flatAndAddMetadata(
                    e,
                    "force_touch.webkit_force_at_mouse_down",
                    function() {
                      return MouseEvent.WEBKIT_FORCE_AT_MOUSE_DOWN;
                    }
                  ), this.flatAndAddMetadata(
                    e,
                    "force_touch.webkit_force_at_force_mouse_down",
                    function() {
                      return MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN;
                    }
                  )), this.flatAndAddMetadata(e, "full_screen", function() {
                    return i.fullscreen;
                  }), this.flatAndAddMetadata(e, "game_pads", function() {
                    return i.gamepads;
                  }), this.flatAndAddMetadata(e, "geo_location", function() {
                    return i.geolocation;
                  }), this.flatAndAddMetadata(e, "ie8compat", function() {
                    return i.ie8compat;
                  }), [4, this.safeModernizrOn("indexeddb")];
                case 2:
                  return l = d.sent(), n.flatAndAddMetadata(e, "indexed_db", function() {
                    return l;
                  }), this.flatAndAddMetadata(e, "indexed_db_blob", function() {
                    return i.indexeddbblob;
                  }), this.flatAndAddMetadata(e, "internationalization", function() {
                    return i.intl;
                  }), this.flatAndAddMetadata(e, "json", function() {
                    return i.json;
                  }), this.flatAndAddMetadata(e, "ligatures", function() {
                    return i.ligatures;
                  }), this.flatAndAddMetadata(e, "media_source", function() {
                    return "MediaSource" in window;
                  }), this.flatAndAddMetadata(e, "message_channel", function() {
                    return i.messagechannel;
                  }), this.flatAndAddMetadata(e, "notification", function() {
                    return i.notification;
                  }), this.flatAndAddMetadata(e, "page_visibility", function() {
                    return i.pagevisibility;
                  }), this.flatAndAddMetadata(e, "performance", function() {
                    return i.performance;
                  }), this.flatAndAddMetadata(e, "pointer_events", function() {
                    return i.pointerevents;
                  }), this.flatAndAddMetadata(e, "pointer_lock", function() {
                    return i.pointerlock;
                  }), this.flatAndAddMetadata(e, "proximity", function() {
                    return i.proximity;
                  }), this.flatAndAddMetadata(e, "query_selector", function() {
                    return i.queryselector;
                  }), this.flatAndAddMetadata(e, "quota_management", function() {
                    return i.quotamanagement;
                  }), this.flatAndAddMetadata(e, "request_animation_frame", function() {
                    return i.requestanimationframe;
                  }), this.flatAndAddMetadata(e, "service_worker", function() {
                    return i.serviceworker;
                  }), this.flatAndAddMetadata(e, "touch_events", function() {
                    return i.touchevents;
                  }), this.flatAndAddMetadata(e, "typed_arrays", function() {
                    return i.typedarrays;
                  }), this.flatAndAddMetadata(e, "vibrate", function() {
                    return i.vibrate;
                  }), this.flatAndAddMetadata(e, "video", function() {
                    return !!i.video;
                  }), i.video && this.flatAndAddMetadata(e, "video", function() {
                    return i.video;
                  }), this.flatAndAddMetadata(e, "web_gl", function() {
                    return i.webgl;
                  }), this.flatAndAddMetadata(e, "web_sockets", function() {
                    return i.websockets;
                  }), this.flatAndAddMetadata(e, "x_domain_request", function() {
                    return i.xdomainrequest;
                  }), this.flatAndAddMetadata(e, "matchmedia", function() {
                    return i.matchmedia;
                  }), [2];
              }
            });
          });
        }, t.prototype.getIoMetadata = function() {
          var e = this, n = {}, i = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
          return this.flatAndAddMetadata(n, "NETWORK_TYPE", function() {
            return i ? i.type : null;
          }), this.flatAndAddMetadata(n, "NETWORK_DOWNLOAD_MAX", function() {
            return i ? i.downlinkMax : null;
          }), this.flatAndAddMetadata(n, "BLUTOOTH_SUPPORTED", function() {
            return !!navigator.bluetooth;
          }), this.flatAndAddMetadata(n, "HAS_SPEAKERS", function() {
            return e.hasSpeakers;
          }), this.flatAndAddMetadata(n, "HAS_MICROPHONE", function() {
            return e.hasMicrophone;
          }), this.flatAndAddMetadata(n, "HAS_CAMERA", function() {
            return e.hasWebcam;
          }), this.flatAndAddMetadata(n, "BATTERY_SUPPORTED", function() {
            return e.isBatterySupported;
          }), this.flatAndAddMetadata(n, "BATTERY_LEVEL", function() {
            return e.batteryLevel;
          }), this.flatAndAddMetadata(n, "BATTERY_CHARGING", function() {
            return e.batteryCharging;
          }), this.flatAndAddMetadata(n, "BATTERY_CHARGING_TIME", function() {
            return e.batteryChargingTime;
          }), this.flatAndAddMetadata(n, "BATTERY_DISCHARGING_TIME", function() {
            return e.batteryDischargingTime;
          }), this.flatAndAddMetadata(n, "GPS_SUPPORTED", function() {
            return e.gpsSupported;
          }), this.flatAndAddMetadata(n, "IS_MOBILE", function() {
            return s._POSignalsUtils.Util.isMobile;
          }), this.flatAndAddMetadata(n, "HAS_TOUCH", function() {
            return "ontouchstart" in document.documentElement;
          }), this.flatAndAddMetadata(n, "PERMISSIONS", function() {
            return e.permissions;
          }), this.flatAndAddMetadata(n, "PREFERS_COLOR_SCHEME", function() {
            return window.matchMedia("(prefers-color-scheme: light)").matches ? "light" : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : void 0;
          }), n;
        }, t.prototype.safeAddMetadata = function(e, n, i) {
          try {
            var a = new Set(this.metadataParams.metadataBlackList || []);
            n == null || i == null || a.has(n) || (e[n] = i);
          } catch (u) {
            s._POSignalsUtils.Logger.warn("Failed to add " + n + " -> " + i + ", " + u);
          }
        }, t.prototype.safeModernizrOn = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i;
            return $(this, function(a) {
              switch (a.label) {
                case 0:
                  return n = new Promise(function(u) {
                    try {
                      s.Modernizr.on(e, function(c) {
                        u(c);
                      });
                    } catch (c) {
                      u(null), s._POSignalsUtils.Logger.warn(
                        "Modernizr.on Failed with feature " + e,
                        c
                      );
                    }
                  }), i = s._POSignalsUtils.Util.delay(250).then(function() {
                    return null;
                  }), [4, Promise.race([n, i])];
                case 1:
                  return [2, a.sent()];
              }
            });
          });
        }, t.prototype.flatAndAddMetadata = function(e, n, i) {
          try {
            var a = new Set(this.metadataParams.metadataBlackList || []);
            if (!n || a.has(n))
              return;
            var u = i();
            if (typeof u == "object" && u !== null) {
              var c = s._POSignalsUtils.Util.flatten(u);
              for (var l in c)
                this.safeAddMetadata(e, n + "." + l, c[l]);
            } else
              this.safeAddMetadata(e, n, u);
          } catch (d) {
            s._POSignalsUtils.Logger.warn("Failed to add " + n, d);
          }
        }, t.prototype.getOps = function() {
          var e, n = /* @__PURE__ */ new Date(), i = 0;
          do
            i++, e = (/* @__PURE__ */ new Date()).getTime() - n.getTime();
          while (e < 500);
          var a = i / e;
          return s._POSignalsUtils.Logger.debug("Ops : " + a), a;
        }, t.prototype.getPrivateMode = function() {
          return Z(this, void 0, void 0, function() {
            var e;
            return $(this, function(n) {
              return e = this, [
                2,
                new Promise(function(i, a) {
                  e.detectPrivateMode(function(u) {
                    i(u);
                  });
                })
              ];
            });
          });
        }, t.prototype.detectPrivateMode = function(e) {
          var n, i = e.bind(null, !0), a = e.bind(null, !1);
          window.webkitRequestFileSystem ? window.webkitRequestFileSystem(0, 0, a, i) : "MozAppearance" in document.documentElement.style ? ((n = indexedDB.open("test")).onerror = i, n.onsuccess = a) : /constructor/i.test(window.HTMLElement) || window.safari ? function() {
            try {
              localStorage.length || (localStorage.x = 1, localStorage.removeItem("x")), a();
            } catch {
              navigator.cookieEnabled ? i() : a();
            }
          }() : window.indexedDB || !window.PointerEvent && !window.MSPointerEvent ? a() : i();
        }, t.detectChromium = function() {
          return Math.acos(0.123) == 1.4474840516030247 && Math.acosh(Math.SQRT2) == 0.881373587019543 && Math.atan(2) == 1.1071487177940904 && Math.atanh(0.5) == 0.5493061443340548 && Math.cbrt(Math.PI) == 1.4645918875615231 && Math.cos(21 * Math.LN2) == -0.4067775970251724 && Math.cosh(492 * Math.LOG2E) == 9199870313877772e292 && Math.expm1(1) == 1.718281828459045 && Math.hypot(6 * Math.PI, -100) == 101.76102278593319 && Math.log10(Math.PI) == 0.4971498726941338 && Math.sin(Math.PI) == 12246467991473532e-32 && Math.sinh(Math.PI) == 11.548739357257748 && Math.tan(10 * Math.LOG2E) == -3.3537128705376014 && Math.tanh(0.123) == 0.12238344189440875 && Math.pow(Math.PI, -100) == 19275814160560204e-66;
        }, t;
      }();
      h.Metadata = r;
    })(s._POSignalsMetadata || (s._POSignalsMetadata = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t() {
        }
        return t.seleniumInDocument = function() {
          for (var e = 0, n = [
            "__webdriver_evaluate",
            "__selenium_evaluate",
            "__webdriver_script_function",
            "__webdriver_script_func",
            "__webdriver_script_fn",
            "__fxdriver_evaluate",
            "__driver_unwrapped",
            "__webdriver_unwrapped",
            "__driver_evaluate",
            "__selenium_unwrapped",
            "__fxdriver_unwrapped"
          ]; e < n.length; e++)
            if (document[n[e]])
              return !0;
          return !1;
        }, t.seleniumInWindow = function() {
          for (var e = 0, n = [
            "_phantom",
            "__nightmare",
            "_selenium",
            "callPhantom",
            "calledSelenium",
            "callSelenium",
            "_Selenium_IDE_Recorder"
          ]; e < n.length; e++)
            if (window[n[e]])
              return !0;
          return !1;
        }, t.seleniumInNavigator = function() {
          for (var e = 0, n = [
            "webdriver",
            "__driver_evaluate",
            "__webdriver_evaluate",
            "__selenium_evaluate",
            "__fxdriver_evaluate",
            "__driver_unwrapped",
            "__webdriver_unwrapped",
            "__selenium_unwrapped",
            "__fxdriver_unwrapped",
            "_Selenium_IDE_Recorder",
            "_selenium",
            "calledSelenium",
            "_WEBDRIVER_ELEM_CACHE",
            "ChromeDriverw",
            "driver-evaluate",
            "webdriver-evaluate",
            "selenium-evaluate",
            "webdriverCommand",
            "webdriver-evaluate-response",
            "__webdriverFunc",
            "__webdriver_script_fn",
            "__$webdriverAsyncExecutor",
            "__lastWatirAlert",
            "__lastWatirConfirm",
            "__lastWatirPrompt",
            "$chrome_asyncScriptInfo",
            "$cdc_asdjflasutopfhvcZLmcfl_"
          ]; e < n.length; e++)
            if (navigator[n[e]])
              return !0;
          return !1;
        }, t.seleniumSequentum = function() {
          return window.external && window.external.toString() && window.external.toString().indexOf("Sequentum") != -1;
        }, t;
      }();
      h.SeleniumProperties = r;
    })(s._POSignalsMetadata || (s._POSignalsMetadata = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t(e) {
          this.propertyBlackList = e;
        }
        return t.prototype.getHeadlessResults = function() {
          return Z(this, void 0, void 0, function() {
            var e, n = this;
            return $(this, function(i) {
              switch (i.label) {
                case 0:
                  return [4, this.headlessResults(window)];
                case 1:
                  return e = i.sent(), [
                    4,
                    this.test(e, "iframe_window", function() {
                      return Z(n, void 0, void 0, function() {
                        var a, u;
                        return $(this, function(c) {
                          switch (c.label) {
                            case 0:
                              return Object.getOwnPropertyDescriptors && (a = s._POSignalsUtils.Util.createInvisibleElement("iframe")) ? (a.srcdoc = "page intentionally left blank", document.body.appendChild(a), Object.getOwnPropertyDescriptors(
                                HTMLIFrameElement.prototype
                              ).contentWindow.get.toString() !== "function get contentWindow() { [native code] }" ? [2, !0] : a.contentWindow === window ? [2, !0] : [4, this.headlessResults(a.contentWindow)]) : [2];
                            case 1:
                              return u = c.sent(), a.remove(), [2, u];
                          }
                        });
                      });
                    })
                  ];
                case 2:
                  return i.sent(), [2, e];
              }
            });
          });
        }, t.prototype.headlessResults = function(e) {
          return Z(this, void 0, void 0, function() {
            var n, i, a = this;
            return $(this, function(u) {
              switch (u.label) {
                case 0:
                  return n = /* @__PURE__ */ new Map(), (i = []).push(
                    this.test(n, "headless_chrome", function() {
                      return Z(a, void 0, void 0, function() {
                        return $(this, function(c) {
                          return [2, /HeadlessChrome/.test(e.navigator.userAgent)];
                        });
                      });
                    })
                  ), i.push(
                    this.test(n, "navigator.webdriver_present", function() {
                      return Z(a, void 0, void 0, function() {
                        return $(this, function(c) {
                          return [2, "webdriver" in e.navigator];
                        });
                      });
                    })
                  ), i.push(
                    this.test(n, "window.chrome_missing", function() {
                      return Z(a, void 0, void 0, function() {
                        return $(this, function(c) {
                          return [2, /Chrome/.test(e.navigator.userAgent) && !e.chrome];
                        });
                      });
                    })
                  ), i.push(
                    this.test(n, "permissions_api", function() {
                      return Z(a, void 0, void 0, function() {
                        var c;
                        return $(this, function(l) {
                          switch (l.label) {
                            case 0:
                              return e.navigator.permissions && e.Notification ? [
                                4,
                                e.navigator.permissions.query({ name: "notifications" })
                              ] : [3, 2];
                            case 1:
                              return c = l.sent(), [
                                2,
                                e.Notification.permission === "denied" && c.state === "prompt"
                              ];
                            case 2:
                              return [2];
                          }
                        });
                      });
                    })
                  ), i.push(
                    this.test(n, "permissions_api_overriden", function() {
                      return Z(a, void 0, void 0, function() {
                        var c;
                        return $(this, function(l) {
                          return (c = e.navigator.permissions) ? c.query.toString() !== "function query() { [native code] }" ? [2, !0] : c.query.toString.toString() !== "function toString() { [native code] }" ? [2, !0] : c.query.toString.hasOwnProperty("[[Handler]]") && c.query.toString.hasOwnProperty("[[Target]]") && c.query.toString.hasOwnProperty("[[IsRevoked]]") ? [2, !0] : [2, c.hasOwnProperty("query")] : [2];
                        });
                      });
                    })
                  ), i.push(
                    this.test(n, "navigator.plugins_empty", function() {
                      return Z(a, void 0, void 0, function() {
                        return $(this, function(c) {
                          return [2, navigator.plugins.length === 0];
                        });
                      });
                    })
                  ), i.push(
                    this.test(n, "navigator.languages_blank", function() {
                      return Z(a, void 0, void 0, function() {
                        return $(this, function(c) {
                          return [2, navigator.languages === ""];
                        });
                      });
                    })
                  ), i.push(
                    this.test(n, "consistent_plugins_prototype", function() {
                      return Z(a, void 0, void 0, function() {
                        var c;
                        return $(this, function(l) {
                          return c = PluginArray.prototype === navigator.plugins.__proto__, navigator.plugins.length > 0 && (c = c && Plugin.prototype === navigator.plugins[0].__proto__), [2, c];
                        });
                      });
                    })
                  ), i.push(
                    this.test(n, "consistent_mimetypes_prototype", function() {
                      return Z(a, void 0, void 0, function() {
                        var c;
                        return $(this, function(l) {
                          return c = MimeTypeArray.prototype === navigator.mimeTypes.__proto__, navigator.mimeTypes.length > 0 && (c = c && MimeType.prototype === navigator.mimeTypes[0].__proto__), [2, c];
                        });
                      });
                    })
                  ), [4, Promise.all(i)];
                case 1:
                  return u.sent(), [2, n];
              }
            });
          });
        }, t.prototype.test = function(e, n, i) {
          return Z(this, void 0, void 0, function() {
            var a, u;
            return $(this, function(c) {
              switch (c.label) {
                case 0:
                  return c.trys.push([0, 3, , 4]), this.propertyBlackList.has(n) ? [3, 2] : [4, s._POSignalsUtils.Util.promiseTimeout(100, i())];
                case 1:
                  (a = c.sent()) != null && (e[n] = a), c.label = 2;
                case 2:
                  return [3, 4];
                case 3:
                  return u = c.sent(), s._POSignalsUtils.Logger.warn(n + " headless test was failed", u), [3, 4];
                case 4:
                  return [2];
              }
            });
          });
        }, t;
      }();
      h.DetectHeadless = r;
    })(s._POSignalsMetadata || (s._POSignalsMetadata = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t(e) {
          this.propertyBlackList = e, this.result = {};
        }
        return t.prototype.documentLie = function(e, n) {
          if (n.lied)
            for (var i = 0, a = n.lieTypes; i < a.length; i++) {
              var u = a[i];
              this.result[u] || (this.result[u] = []), this.result[u].push(e);
            }
        }, t.prototype.getLies = function(e, n, i) {
          var a = this;
          if (i === void 0 && (i = null), typeof e != "function")
            return { lied: !1, lieTypes: [] };
          var u = e.name.replace(/get\s/, ""), c = {
            undefined_properties: function() {
              return !!i && t.getUndefinedValueLie(i, u);
            },
            to_string: function() {
              return t.getToStringLie(e, u, a.iframeWindow);
            },
            prototype_in_function: function() {
              return t.getPrototypeInFunctionLie(e);
            },
            own_property: function() {
              return t.getOwnPropertyLie(e);
            },
            object_to_string_error: function() {
              return t.getNewObjectToStringTypeErrorLie(e);
            }
          }, l = Object.keys(c).filter(function(d) {
            return !a.propertyBlackList.has("LIES." + d) && !!c[d]();
          });
          return { lied: l.length > 0, lieTypes: l };
        }, t.prototype.getAllLies = function() {
          return Z(this, void 0, void 0, function() {
            var e;
            return $(this, function(n) {
              switch (n.label) {
                case 0:
                  return this.propertyBlackList.has("LIES") ? [2, this.result] : (this.propertyBlackList.has("LIES_IFRAME") || (e = s._POSignalsUtils.Util.createInvisibleElement("iframe")) && (document.body.appendChild(e), this.iframeWindow = e), [
                    4,
                    Promise.all([
                      this.searchLies(
                        function() {
                          return AnalyserNode;
                        },
                        { target: ["minDecibels"] }
                      ),
                      this.searchLies(
                        function() {
                          return AudioBuffer;
                        },
                        { target: ["copyFromChannel"] }
                      ),
                      this.searchLies(
                        function() {
                          return BiquadFilterNode;
                        },
                        { target: ["getFrequencyResponse"] }
                      ),
                      this.searchLies(
                        function() {
                          return CanvasRenderingContext2D;
                        },
                        { target: ["getLineDash"] }
                      ),
                      this.searchLies(
                        function() {
                          return DOMRect;
                        },
                        { target: ["height"] }
                      ),
                      this.searchLies(
                        function() {
                          return DOMRectReadOnly;
                        },
                        { target: ["left"] }
                      ),
                      this.searchLies(
                        function() {
                          return Element;
                        },
                        { target: ["getClientRects"] }
                      ),
                      this.searchLies(
                        function() {
                          return HTMLCanvasElement;
                        },
                        { target: ["height"] }
                      ),
                      this.searchLies(
                        function() {
                          return Math;
                        },
                        { target: ["sinh"] }
                      ),
                      this.searchLies(
                        function() {
                          return MediaDevices;
                        },
                        { target: ["enumerateDevices"] }
                      ),
                      this.searchLies(
                        function() {
                          return Navigator;
                        },
                        { target: ["plugins"] }
                      ),
                      this.searchLies(
                        function() {
                          return OffscreenCanvasRenderingContext2D;
                        },
                        { target: ["getLineDash"] }
                      ),
                      this.searchLies(
                        function() {
                          return SVGRect;
                        },
                        { target: ["x"] }
                      )
                    ])
                  ]);
                case 1:
                  return n.sent(), this.iframeWindow.remove(), [2, this.result];
              }
            });
          });
        }, t.prototype.searchLies = function(e, n) {
          var i = n === void 0 ? {} : n, a = i.target, u = a === void 0 ? [] : a, c = i.ignore, l = c === void 0 ? [] : c;
          return Z(this, void 0, void 0, function() {
            var d, p, m = this;
            return $(this, function(k) {
              try {
                if (d = e(), (x = d) === void 0 || !x)
                  return [2];
              } catch {
                return [2];
              }
              var x;
              return p = d.prototype ? d.prototype : d, Object.getOwnPropertyNames(p).forEach(function(y) {
                if (!(y == "constructor" || u.length && !new Set(u).has(y) || l.length && new Set(l).has(y))) {
                  var C = /\s(.+)\]/, A = (d.name ? d.name : C.test(d) ? C.exec(d)[1] : void 0) + "." + y;
                  try {
                    var P = d.prototype ? d.prototype : d;
                    try {
                      if (typeof P[y] == "function") {
                        var D = m.getLies(P[y], P);
                        return void m.documentLie(A, D);
                      }
                    } catch {
                    }
                    var j = Object.getOwnPropertyDescriptor(P, y).get, z = m.getLies(j, P, d);
                    m.documentLie(A, z);
                  } catch (B) {
                    s._POSignalsUtils.Logger.warn("failed " + y + " test execution", B);
                  }
                }
              }), [2];
            });
          });
        }, t.getUndefinedValueLie = function(e, n) {
          var i = e.name, a = window[i.charAt(0).toLowerCase() + i.slice(1)];
          return !!a && (Object.getOwnPropertyDescriptor(a, n) !== void 0 || Reflect.getOwnPropertyDescriptor(a, n) !== void 0);
        }, t.getToStringLie = function(e, n, i) {
          var a, u;
          try {
            a = i.Function.prototype.toString.call(e);
          } catch {
          }
          try {
            u = i.Function.prototype.toString.call(e.toString);
          } catch {
          }
          var c = a || e.toString(), l = u || e.toString.toString(), d = function(p) {
            var m;
            return (m = {})["function " + p + "() { [native code] }"] = !0, m["function get " + p + "() { [native code] }"] = !0, m["function () { [native code] }"] = !0, m["function " + p + `() {
    [native code]
}`] = !0, m["function get " + p + `() {
    [native code]
}`] = !0, m[`function () {
    [native code]
}`] = !0, m;
          };
          return !d(n)[c] || !d("toString")[l];
        }, t.getPrototypeInFunctionLie = function(e) {
          return "prototype" in e;
        }, t.getOwnPropertyLie = function(e) {
          return e.hasOwnProperty("arguments") || e.hasOwnProperty("caller") || e.hasOwnProperty("prototype") || e.hasOwnProperty("toString");
        }, t.getNewObjectToStringTypeErrorLie = function(e) {
          try {
            return Object.create(e).toString(), !0;
          } catch (l) {
            var n = l.stack.split(`
`), i = /at Object\.apply/, a = !n.slice(1).find(function(d) {
              return i.test(d);
            }), u = l.constructor.name == "TypeError" && n.length > 1, c = "chrome" in window || h.Metadata.detectChromium();
            return !(!u || !c || /at Function\.toString/.test(n[1]) && a) || !u;
          }
        }, t;
      }();
      h.DetectLies = r;
    })(s._POSignalsMetadata || (s._POSignalsMetadata = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t(e) {
          this.propertyBlackList = e, this.result = /* @__PURE__ */ new Map();
        }
        return t.prototype.getStealthResult = function() {
          return this.addStealthTest("srcdoc_throws_error", function() {
            try {
              return !!document.createElement("iframe").srcdoc;
            } catch {
              return !0;
            }
          }), this.addStealthTest("srcdoc_triggers_window_proxy", function() {
            var e = document.createElement("iframe");
            return e.srcdoc = "" + s._POSignalsUtils.Util.hashMini(crypto.getRandomValues(new Uint32Array(10))), !!e.contentWindow;
          }), this.addStealthTest("index_chrome_too_high", function() {
            var e = "cookieStore" in window ? "cookieStore" : "ondevicemotion" in window ? "ondevicemotion" : "speechSynthesis", n = [];
            for (var i in window)
              n.push(i);
            return n.indexOf("chrome") > n.indexOf(e);
          }), this.addStealthTest("chrome_runtime_functions_invalid", function() {
            if (!("chrome" in window && "runtime" in window.chrome))
              return !1;
            try {
              return "prototype" in window.chrome.runtime.sendMessage || "prototype" in window.chrome.runtime.connect || (new window.chrome.runtime.sendMessage(), new window.chrome.runtime.connect(), !0);
            } catch (e) {
              return e.constructor.name != "TypeError";
            }
          }), this.addStealthTest("Function_prototype_toString_invalid_typeError", function() {
            var e = new t.StackTraceTester();
            return e.isInvalidStackTraceSize(Function.prototype.toString) || e.isInvalidStackTraceSize(function() {
            });
          }), this.result;
        }, t.prototype.addStealthTest = function(e, n) {
          if (!this.propertyBlackList.has(e))
            try {
              this.result[e] = n();
            } catch (i) {
              s._POSignalsUtils.Logger.warn("stealth test " + e + " failed", i);
            }
        }, t.StackTraceTester = function() {
          function e() {
          }
          return e.prototype.isInvalidStackTraceSize = function(n) {
            var i = this;
            try {
              return this.you = function() {
                return Object.create(n).toString();
              }, this.cant = function() {
                return i.you();
              }, this.hide = function() {
                return i.cant();
              }, this.hide(), !0;
            } catch (d) {
              var a = d.stack.split(`
`), u = !/at Object\.apply/.test(a[1]), c = d.constructor.name == "TypeError" && a.length >= 5, l = "chrome" in window || h.Metadata.detectChromium();
              return !(!c || !l || u && /at Function\.toString/.test(a[1]) && /\.you/.test(a[2]) && /\.cant/.test(a[3]) && /\.hide/.test(a[4])) || !c;
            }
          }, e;
        }(), t;
      }();
      h.DetectStealth = r;
    })(s._POSignalsMetadata || (s._POSignalsMetadata = {}));
  }(M || (M = {})), function(s) {
    (function(h) {
      var r = function() {
        function t() {
        }
        return t.isPrivateMode = function() {
          return new Promise(function(e) {
            var n, i, a = function() {
              return e(!0);
            }, u = function() {
              return e(!1);
            };
            try {
              if ((i = navigator && /(?=.*(opera|chrome)).*/i.test(navigator.userAgent) && navigator.storage && navigator.storage.estimate) && navigator.storage.estimate().then(function(c) {
                c.quota < 12e7 ? a() : u();
              }).catch(function(c) {
                u();
              }), i || function() {
                var c = "MozAppearance" in document.documentElement.style;
                if (c)
                  if (indexedDB == null)
                    a();
                  else {
                    var l = indexedDB.open("inPrivate");
                    l.onsuccess = u, l.onerror = a;
                  }
                return c;
              }() || function() {
                var c = navigator && navigator.userAgent && navigator.userAgent.match(/Version\/([0-9\._]+).*Safari/);
                if (c) {
                  if (parseInt(c[1], 10) < 11)
                    return function() {
                      try {
                        localStorage.length || (localStorage.setItem("inPrivate", "0"), localStorage.removeItem("inPrivate")), u();
                      } catch {
                        navigator.cookieEnabled ? a() : u();
                      }
                      return !0;
                    }();
                  try {
                    window.openDatabase(null, null, null, null), u();
                  } catch {
                    a();
                  }
                }
                return !!c;
              }() || ((n = !window.indexedDB && (window.PointerEvent || window.MSPointerEvent)) && a(), n))
                return;
            } catch {
            }
            return u();
          });
        }, t;
      }();
      h.Incognito = r;
    })(s._POSignalsMetadata || (s._POSignalsMetadata = {}));
  }(M || (M = {}));
  var _e = /* @__PURE__ */ function() {
    var s = function(h, r) {
      return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) {
        t.__proto__ = e;
      } || function(t, e) {
        for (var n in e)
          e.hasOwnProperty(n) && (t[n] = e[n]);
      })(h, r);
    };
    return function(h, r) {
      function t() {
        this.constructor = h;
      }
      s(h, r), h.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
    };
  }();
  Z = function(s, h, r, t) {
    return new (r || (r = Promise))(function(e, n) {
      function i(c) {
        try {
          u(t.next(c));
        } catch (l) {
          n(l);
        }
      }
      function a(c) {
        try {
          u(t.throw(c));
        } catch (l) {
          n(l);
        }
      }
      function u(c) {
        var l;
        c.done ? e(c.value) : (l = c.value, l instanceof r ? l : new r(function(d) {
          d(l);
        })).then(i, a);
      }
      u((t = t.apply(s, h || [])).next());
    });
  }, $ = function(s, h) {
    var r, t, e, n, i = {
      label: 0,
      sent: function() {
        if (1 & e[0])
          throw e[1];
        return e[1];
      },
      trys: [],
      ops: []
    };
    return n = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (n[Symbol.iterator] = function() {
      return this;
    }), n;
    function a(u) {
      return function(c) {
        return function(l) {
          if (r)
            throw new TypeError("Generator is already executing.");
          for (; i; )
            try {
              if (r = 1, t && (e = 2 & l[0] ? t.return : l[0] ? t.throw || ((e = t.return) && e.call(t), 0) : t.next) && !(e = e.call(t, l[1])).done)
                return e;
              switch (t = 0, e && (l = [2 & l[0], e.value]), l[0]) {
                case 0:
                case 1:
                  e = l;
                  break;
                case 4:
                  return i.label++, { value: l[1], done: !1 };
                case 5:
                  i.label++, t = l[1], l = [0];
                  continue;
                case 7:
                  l = i.ops.pop(), i.trys.pop();
                  continue;
                default:
                  if (!(e = (e = i.trys).length > 0 && e[e.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                    i = 0;
                    continue;
                  }
                  if (l[0] === 3 && (!e || l[1] > e[0] && l[1] < e[3])) {
                    i.label = l[1];
                    break;
                  }
                  if (l[0] === 6 && i.label < e[1]) {
                    i.label = e[1], e = l;
                    break;
                  }
                  if (e && i.label < e[2]) {
                    i.label = e[2], i.ops.push(l);
                    break;
                  }
                  e[2] && i.ops.pop(), i.trys.pop();
                  continue;
              }
              l = h.call(s, i);
            } catch (d) {
              l = [6, d], t = 0;
            } finally {
              r = e = 0;
            }
          if (5 & l[0])
            throw l[1];
          return { value: l[0] ? l[1] : void 0, done: !0 };
        }([u, c]);
      };
    }
  }, ve = function() {
    return (ve = Object.assign || function(s) {
      for (var h, r = 1, t = arguments.length; r < t; r++)
        for (var e in h = arguments[r])
          Object.prototype.hasOwnProperty.call(h, e) && (s[e] = h[e]);
      return s;
    }).apply(this, arguments);
  }, function(s) {
    (function(h) {
      h[h.Unknown = 0] = "Unknown", h[h.FlingRight = 1] = "FlingRight", h[h.FlingLeft = 2] = "FlingLeft", h[h.FlingUp = 3] = "FlingUp", h[h.FlingDown = 4] = "FlingDown", h[h.Diagonal = 5] = "Diagonal", h[h.ScrollRight = 6] = "ScrollRight", h[h.ScrollLeft = 7] = "ScrollLeft", h[h.ScrollUp = 8] = "ScrollUp", h[h.ScrollDown = 9] = "ScrollDown", h[h.Tap = 10] = "Tap", h[h.DoubleTap = 11] = "DoubleTap";
    })(s.GestureType || (s.GestureType = {}));
  }(M || (M = {})), function(s) {
    var h = function() {
      function d(p, m) {
        this.handler = p, this.isOnce = m, this.isExecuted = !1;
      }
      return d.prototype.execute = function(p, m, k) {
        if (!this.isOnce || !this.isExecuted) {
          this.isExecuted = !0;
          var x = this.handler;
          p ? setTimeout(function() {
            x.apply(m, k);
          }, 1) : x.apply(m, k);
        }
      }, d;
    }(), r = function() {
      function d() {
        this._wrap = new i(this), this._subscriptions = new Array();
      }
      return d.prototype.subscribe = function(p) {
        p && this._subscriptions.push(new h(p, !1));
      }, d.prototype.sub = function(p) {
        this.subscribe(p);
      }, d.prototype.one = function(p) {
        p && this._subscriptions.push(new h(p, !0));
      }, d.prototype.has = function(p) {
        if (p) {
          for (var m = 0, k = this._subscriptions; m < k.length; m++)
            if (k[m].handler == p)
              return !0;
        }
        return !1;
      }, d.prototype.unsubscribe = function(p) {
        if (p) {
          for (var m = 0; m < this._subscriptions.length; m++)
            if (this._subscriptions[m].handler == p) {
              this._subscriptions.splice(m, 1);
              break;
            }
        }
      }, d.prototype.unsub = function(p) {
        this.unsubscribe(p);
      }, d.prototype._dispatch = function(p, m, k) {
        for (var x = 0; x < this._subscriptions.length; x++) {
          var y = this._subscriptions[x];
          if (y.isOnce) {
            if (y.isExecuted === !0)
              continue;
            this._subscriptions.splice(x, 1), x--;
          }
          y.execute(p, m, k);
        }
      }, d.prototype.asEvent = function() {
        return this._wrap;
      }, d;
    }();
    s.DispatcherBase = r;
    var t = function(d) {
      function p() {
        return d !== null && d.apply(this, arguments) || this;
      }
      return _e(p, d), p.prototype.dispatch = function(m, k) {
        this._dispatch(!1, this, arguments);
      }, p.prototype.dispatchAsync = function(m, k) {
        this._dispatch(!0, this, arguments);
      }, p;
    }(r);
    s.EventDispatcher = t;
    var e = function(d) {
      function p() {
        return d !== null && d.apply(this, arguments) || this;
      }
      return _e(p, d), p.prototype.dispatch = function(m) {
        this._dispatch(!1, this, arguments);
      }, p.prototype.dispatchAsync = function(m) {
        this._dispatch(!0, this, arguments);
      }, p;
    }(r), n = function(d) {
      function p() {
        return d !== null && d.apply(this, arguments) || this;
      }
      return _e(p, d), p.prototype.dispatch = function() {
        this._dispatch(!1, this, arguments);
      }, p.prototype.dispatchAsync = function() {
        this._dispatch(!0, this, arguments);
      }, p;
    }(r), i = function() {
      function d(p) {
        this._subscribe = function(m) {
          return p.subscribe(m);
        }, this._unsubscribe = function(m) {
          return p.unsubscribe(m);
        }, this._one = function(m) {
          return p.one(m);
        }, this._has = function(m) {
          return p.has(m);
        };
      }
      return d.prototype.subscribe = function(p) {
        this._subscribe(p);
      }, d.prototype.sub = function(p) {
        this.subscribe(p);
      }, d.prototype.unsubscribe = function(p) {
        this._unsubscribe(p);
      }, d.prototype.unsub = function(p) {
        this.unsubscribe(p);
      }, d.prototype.one = function(p) {
        this._one(p);
      }, d.prototype.has = function(p) {
        return this._has(p);
      }, d;
    }(), a = function() {
      function d() {
        this._events = {};
      }
      return d.prototype.get = function(p) {
        var m = this._events[p];
        return m || (m = this.createDispatcher(), this._events[p] = m, m);
      }, d.prototype.remove = function(p) {
        this._events[p] = null;
      }, d;
    }(), u = function(d) {
      function p() {
        return d !== null && d.apply(this, arguments) || this;
      }
      return _e(p, d), p.prototype.createDispatcher = function() {
        return new t();
      }, p;
    }(a), c = function(d) {
      function p() {
        return d !== null && d.apply(this, arguments) || this;
      }
      return _e(p, d), p.prototype.createDispatcher = function() {
        return new e();
      }, p;
    }(a), l = function(d) {
      function p() {
        return d !== null && d.apply(this, arguments) || this;
      }
      return _e(p, d), p.prototype.createDispatcher = function() {
        return new n();
      }, p;
    }(a);
    ((function() {
      function d() {
        this._events = new u();
      }
      Object.defineProperty(d.prototype, "events", {
        get: function() {
          return this._events;
        },
        enumerable: !1,
        configurable: !0
      }), d.prototype.subscribe = function(p, m) {
        this._events.get(p).subscribe(m);
      }, d.prototype.sub = function(p, m) {
        this.subscribe(p, m);
      }, d.prototype.unsubscribe = function(p, m) {
        this._events.get(p).unsubscribe(m);
      }, d.prototype.unsub = function(p, m) {
        this.unsubscribe(p, m);
      }, d.prototype.one = function(p, m) {
        this._events.get(p).one(m);
      }, d.prototype.has = function(p, m) {
        return this._events.get(p).has(m);
      };
    }))(), function() {
      function d() {
        this._events = new c();
      }
      Object.defineProperty(d.prototype, "events", {
        get: function() {
          return this._events;
        },
        enumerable: !1,
        configurable: !0
      }), d.prototype.subscribe = function(p, m) {
        this._events.get(p).subscribe(m);
      }, d.prototype.sub = function(p, m) {
        this.subscribe(p, m);
      }, d.prototype.one = function(p, m) {
        this._events.get(p).one(m);
      }, d.prototype.has = function(p, m) {
        return this._events.get(p).has(m);
      }, d.prototype.unsubscribe = function(p, m) {
        this._events.get(p).unsubscribe(m);
      }, d.prototype.unsub = function(p, m) {
        this.unsubscribe(p, m);
      };
    }(), function() {
      function d() {
        this._events = new l();
      }
      Object.defineProperty(d.prototype, "events", {
        get: function() {
          return this._events;
        },
        enumerable: !1,
        configurable: !0
      }), d.prototype.one = function(p, m) {
        this._events.get(p).one(m);
      }, d.prototype.has = function(p, m) {
        return this._events.get(p).has(m);
      }, d.prototype.subscribe = function(p, m) {
        this._events.get(p).subscribe(m);
      }, d.prototype.sub = function(p, m) {
        this.subscribe(p, m);
      }, d.prototype.unsubscribe = function(p, m) {
        this._events.get(p).unsubscribe(m);
      }, d.prototype.unsub = function(p, m) {
        this.unsubscribe(p, m);
      };
    }();
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this._isStarted = !1, this._isEventsStarted = !1, this._gestureTimestamps = [], this._maxSensorSamples = 0, this._sensorsTimestampDeltaInMillis = 0, this._accelerometerList = [], this._gyroscopeList = [], this._linearAccelerometerList = [], this._rotationList = [], this.orientationImplementationFix = 1, this.delegate = t, window.navigator.userAgent.match(
          /^.*(iPhone|iPad).*(OS\s[0-9]).*(CriOS|Version)\/[.0-9]*\sMobile.*$/i
        ) && (this.orientationImplementationFix = -1), this.accelerometerUpdateHandle = this.accelerometerUpdate.bind(this), this.orientationUpdateHandle = this.orientationUpdate.bind(this);
      }
      return Object.defineProperty(r.prototype, "LAST_GESTURE_SENSOR_TIMEOUT_MILI_SECONDS", {
        get: function() {
          return 3e3;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "accX", {
        get: function() {
          return this._accX;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "accY", {
        get: function() {
          return this._accY;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "accZ", {
        get: function() {
          return this._accZ;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "lienarAccX", {
        get: function() {
          return this._lienarAccX;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "lienarAccY", {
        get: function() {
          return this._lienarAccY;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "lienarAccZ", {
        get: function() {
          return this._lienarAccZ;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "rotX", {
        get: function() {
          return this._rotX;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "rotY", {
        get: function() {
          return this._rotY;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "rotZ", {
        get: function() {
          return this._rotZ;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "maxSensorSamples", {
        get: function() {
          return this._maxSensorSamples;
        },
        set: function(t) {
          this._maxSensorSamples = t;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "sensorsTimestampDeltaInMillis", {
        get: function() {
          return this._sensorsTimestampDeltaInMillis;
        },
        set: function(t) {
          this._sensorsTimestampDeltaInMillis = t;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "accelerometerList", {
        get: function() {
          return this.getRelevantSensorSamples(this._accelerometerList);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "gyroscopeList", {
        get: function() {
          return this.getRelevantSensorSamples(this._gyroscopeList);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "linearAccelerometerList", {
        get: function() {
          return this.getRelevantSensorSamples(this._linearAccelerometerList);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "rotationList", {
        get: function() {
          return this._rotationList;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.start = function() {
        this._isStarted || (this._isStarted = !0, s._POSignalsUtils.Logger.debug("Sensor events started..."));
      }, r.prototype.getRotationListCopy = function() {
        return this._rotationList ? Array.from(this._rotationList) : [];
      }, r.prototype.stop = function() {
        this._isStarted && (window.DeviceMotionEvent != null && window.removeEventListener("devicemotion", this.accelerometerUpdateHandle, !0), window.DeviceOrientationEvent && window.removeEventListener("deviceorientation", this.orientationUpdateHandle, !0), this._isStarted = !1, s._POSignalsUtils.Logger.debug("Sensor events stopped"));
      }, r.prototype.getRelevantSensorSamples = function(t) {
        if (t.length == 0 || this._sensorsTimestampDeltaInMillis < 1 || this._gestureTimestamps.length == 0)
          return t;
        for (var e = /* @__PURE__ */ new Map(), n = null, i = 0, a = 0; a < t.length; a++)
          for (var u = 0; u < this._gestureTimestamps.length; u++)
            (i = t[a].timestamp) >= (n = this._gestureTimestamps[u]).start - this._sensorsTimestampDeltaInMillis && i <= n.end + this._sensorsTimestampDeltaInMillis && e.set(t[a].timestamp, t[a]);
        return s._POSignalsUtils.Util.getValuesOfMap(e);
      }, r.prototype.stopEvents = function() {
        this._isEventsStarted && (window.DeviceMotionEvent != null && window.removeEventListener("devicemotion", this.accelerometerUpdateHandle, !0), window.DeviceOrientationEvent && window.removeEventListener("deviceorientation", this.orientationUpdateHandle, !0), this._isEventsStarted = !1, s._POSignalsUtils.Logger.debug("Sensor events stopped listening"));
      }, r.prototype.startEvents = function() {
        this._isEventsStarted || (window.DeviceMotionEvent != null ? this.delegate.addEventListener(
          window,
          "devicemotion",
          this.accelerometerUpdateHandle,
          !0
        ) : s._POSignalsUtils.Logger.warn("DeviceMotion not supported!"), window.DeviceOrientationEvent ? this.delegate.addEventListener(
          window,
          "deviceorientation",
          this.orientationUpdateHandle,
          !0
        ) : s._POSignalsUtils.Logger.warn("DeviceOrientation not supported!"), s._POSignalsUtils.Logger.debug("Sensor events start listening..."), this._isEventsStarted = !0);
      }, r.prototype.reset = function() {
        this._accelerometerList = [], this._gyroscopeList = [], this._linearAccelerometerList = [], this._rotationList = [], this._gestureTimestamps.length > 0 ? this._gestureTimestamps = [
          this._gestureTimestamps[this._gestureTimestamps.length - 1]
        ] : this._gestureTimestamps = [], this._accX = 0, this._accY = 0, this._accZ = 0, this._rotX = 0, this._rotY = 0, this._rotZ = 0;
      }, r.prototype.onGesture = function(t) {
        this._isEventsStarted || this.startEvents(), t.events.length > 1 && this._gestureTimestamps.push({
          start: t.events[0].eventTs,
          end: t.events[t.events.length - 1].eventTs
        });
      }, r.prototype.puaseSensorsCollectionIfNoActivity = function(t) {
        return (this._gestureTimestamps.length > 0 ? this._gestureTimestamps[this._gestureTimestamps.length - 1].end : 0) > 0 ? Math.abs(t - this._gestureTimestamps[this._gestureTimestamps.length - 1].end) > this.LAST_GESTURE_SENSOR_TIMEOUT_MILI_SECONDS && (this.stopEvents(), !0) : (this.stopEvents(), !0);
      }, r.prototype.getDeviceAcceleration = function(t) {
        return t && t.x != null && t.y != null && t.z != null ? t : null;
      }, r.prototype.accelerometerUpdate = function(t) {
        try {
          if (!this.delegate.collectBehavioralData() || this.puaseSensorsCollectionIfNoActivity(s._POSignalsUtils.Util.now()))
            return;
          var e = this.getDeviceAcceleration(t.accelerationIncludingGravity);
          e && (this._accX = e.x * this.orientationImplementationFix, this._accY = e.y * this.orientationImplementationFix, this._accZ = e.z, this.safeAddSensorSample(
            {
              x: this._accX,
              y: this._accY,
              z: this._accX,
              timestamp: s._POSignalsUtils.Util.now()
            },
            this._accelerometerList
          ));
          var n = this.getDeviceAcceleration(t.acceleration);
          n && (this._lienarAccX = n.x * this.orientationImplementationFix, this._lienarAccY = n.y * this.orientationImplementationFix, this._lienarAccZ = n.z, this.safeAddSensorSample(
            {
              x: this._lienarAccX,
              y: this._lienarAccY,
              z: this._lienarAccZ,
              timestamp: s._POSignalsUtils.Util.now()
            },
            this._linearAccelerometerList
          )), t.rotationRate && t.rotationRate.alpha != null && t.rotationRate.beta != null && t.rotationRate.gamma != null && (this._rotX = t.rotationRate.alpha, this._rotY = t.rotationRate.beta, this._rotZ = t.rotationRate.gamma, this.safeAddSensorSample(
            {
              x: this._rotX,
              y: this._rotY,
              z: this._rotZ,
              timestamp: s._POSignalsUtils.Util.now()
            },
            this._gyroscopeList
          ));
        } catch (i) {
          s._POSignalsUtils.Logger.warn("error in accelerometer handler", i);
        }
      }, r.prototype.orientationUpdate = function(t) {
        try {
          if (!this.delegate.collectBehavioralData() || this.puaseSensorsCollectionIfNoActivity(s._POSignalsUtils.Util.now()))
            return;
          t.alpha != null && t.beta != null && t.gamma != null && this.safeAddSensorSample(
            { x: t.alpha, y: t.beta, z: t.gamma, timestamp: s._POSignalsUtils.Util.now() },
            this._rotationList
          );
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in orientation handler", e);
        }
      }, r.prototype.safeAddSensorSample = function(t, e) {
        this.maxSensorSamples > e.length && e.push(t);
      }, r;
    }();
    s.Sensors = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
        this._pointerParams = new s.PointerParams();
      }
      return Object.defineProperty(r, "instance", {
        get: function() {
          return r._instance || (r._instance = new r()), r._instance;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "pointerParams", {
        get: function() {
          return this._pointerParams;
        },
        enumerable: !1,
        configurable: !0
      }), r;
    }();
    s.PointerConfig = h;
  }(M || (M = {})), function(s) {
    var h;
    (function(t) {
      t[t.Up = 1] = "Up", t[t.Down = 2] = "Down", t[t.Left = 3] = "Left", t[t.Right = 4] = "Right";
    })(h || (h = {}));
    var r = function() {
      function t(e, n) {
        this.BEHAVIORAL_TYPE = "gestures", this._isStarted = !1, this._onGesture = new s.EventDispatcher(), this.touchSnapshotsMap = /* @__PURE__ */ new Map(), this.snapshotStartTime = /* @__PURE__ */ new Map(), this.delegate = e, this.sensors = n, this.touchStartHandler = this.touchStart.bind(this), this.touchMoveHandler = this.touchMove.bind(this), this.touchEndHandler = this.touchEnd.bind(this), this.touchCancelHandler = this.touchCancel.bind(this);
      }
      return Object.defineProperty(t.prototype, "onGesture", {
        get: function() {
          return this._onGesture.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "SCROLL_MIN_DURATION", {
        get: function() {
          return 500;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "SWIPE_MAX_ANGLE", {
        get: function() {
          return 45;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "TAP_MOVEMENT_TRESHOLD", {
        get: function() {
          return 10;
        },
        enumerable: !1,
        configurable: !0
      }), t.prototype.countEvents = function(e) {
        for (var n = {}, i = 0, a = e; i < a.length; i++) {
          var u = a[i];
          n[u.type] = (n[u.type] || 0) + 1;
        }
        return n;
      }, t.prototype.clearTouchSnapshots = function(e) {
        this.touchSnapshotsMap.delete(e), this.snapshotStartTime.delete(e);
      }, t.prototype.getTouchSnapshots = function(e) {
        var n;
        return this.touchSnapshotsMap.has(e) ? n = this.touchSnapshotsMap.get(e) : (n = [], this.touchSnapshotsMap.set(e, n)), n;
      }, t.prototype.isEmpty = function() {
        return this.touchSnapshotsMap.size === 0;
      }, t.prototype.start = function() {
        this._isStarted || (this.delegate.addEventListener(document, "touchstart", this.touchStartHandler), this.delegate.addEventListener(document, "touchmove", this.touchMoveHandler), this.delegate.addEventListener(document, "touchend", this.touchEndHandler), this.delegate.addEventListener(document, "touchcancel", this.touchCancelHandler), this._isStarted = !0);
      }, t.prototype.stop = function() {
        this._isStarted && (document.removeEventListener("touchstart", this.touchStartHandler), document.removeEventListener("touchmove", this.touchMoveHandler), document.removeEventListener("touchend", this.touchEndHandler), document.removeEventListener("touchcancel", this.touchCancelHandler), this._isStarted = !1);
      }, t.prototype.touchStart = function(e) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE) || s.PointerConfig.instance.pointerParams.eventsToIgnore.has(e.type))
            return;
          s._POSignalsUtils.Logger.debug("touchstart(" + e.changedTouches.length + ")", e), e.changedTouches.length > 0 && this.pushSnapshot(e);
        } catch (n) {
          s._POSignalsUtils.Logger.warn("error in touchStart handler", n);
        }
      }, t.prototype.touchMove = function(e) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE) || s.PointerConfig.instance.pointerParams.eventsToIgnore.has(e.type))
            return;
          s._POSignalsUtils.Logger.debug("touchmove(" + e.changedTouches.length + ")", e), e.changedTouches.length > 0 && this.pushSnapshot(e);
        } catch (n) {
          s._POSignalsUtils.Logger.warn("error in touchMove handler", n);
        }
      }, t.prototype.touchEnd = function(e) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return void this._onGesture.dispatch(this, null);
          if (s.PointerConfig.instance.pointerParams.eventsToIgnore.has(e.type))
            return;
          s._POSignalsUtils.Logger.debug("touchend(" + e.changedTouches.length + ")", e), this.gestureEnd(e);
        } catch (n) {
          s._POSignalsUtils.Logger.warn("error in touchEnd handler", n);
        }
      }, t.prototype.touchCancel = function(e) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return void this._onGesture.dispatch(this, null);
          if (s.PointerConfig.instance.pointerParams.eventsToIgnore.has(e.type))
            return;
          s._POSignalsUtils.Logger.debug("touchcancel(" + e.changedTouches.length + ")", e), this.gestureEnd(e);
        } catch (n) {
          s._POSignalsUtils.Logger.warn("error in touchCancel handler", n);
        }
      }, t.prototype.gestureEnd = function(e) {
        e.changedTouches.length > 0 && this.pushSnapshot(e);
        for (var n = 0; n < e.changedTouches.length; n++) {
          var i = e.changedTouches.item(n), a = this.getTouchSnapshots(i.identifier);
          a.length > 0 && (this.isTap(a) ? this.dispatchGesture(s.GestureType.Tap, i.identifier) : this.dispatchGesture(this.calcGestureType(a), i.identifier));
        }
      }, t.prototype.calcGestureType = function(e) {
        var n, i = this.getDirection(e);
        if (this.isFling(e))
          switch (i) {
            case h.Up:
              n = s.GestureType.FlingUp;
              break;
            case h.Right:
              n = s.GestureType.FlingRight;
              break;
            case h.Down:
              n = s.GestureType.FlingDown;
              break;
            case h.Left:
              n = s.GestureType.FlingLeft;
          }
        else if (this.isScroll(e))
          switch (i) {
            case h.Up:
              n = s.GestureType.ScrollUp;
              break;
            case h.Right:
              n = s.GestureType.ScrollRight;
              break;
            case h.Down:
              n = s.GestureType.ScrollDown;
              break;
            case h.Left:
              n = s.GestureType.ScrollLeft;
          }
        return n;
      }, t.prototype.pushSnapshot = function(e) {
        if (e.changedTouches && e.changedTouches.length > 0)
          for (var n, i = function() {
            var c = e.changedTouches.item(u);
            n = c.radiusX && c.radiusY ? (c.radiusX + c.radiusY) / 2 : null, a.snapshotStartTime.has(c.identifier) || a.snapshotStartTime.set(c.identifier, (/* @__PURE__ */ new Date()).getTime());
            var l = a.getTouchSnapshots(c.identifier);
            l.length < s.PointerConfig.instance.pointerParams.maxSnapshotsCount && l.push({
              type: e.type,
              eventTs: e.timeStamp,
              epochTs: (/* @__PURE__ */ new Date()).getTime(),
              relativeX: c.screenX,
              relativeY: c.screenY,
              x: c.clientX,
              y: c.clientY,
              pressure: c.force,
              size: n,
              xaccelerometer: a.sensors.accX,
              yaccelerometer: a.sensors.accY,
              zaccelerometer: a.sensors.accZ,
              xlinearaccelerometer: a.sensors.lienarAccX,
              ylinearaccelerometer: a.sensors.lienarAccY,
              zlinearaccelerometer: a.sensors.lienarAccZ,
              xrotation: a.sensors.rotX,
              yrotation: a.sensors.rotY,
              zrotation: a.sensors.rotZ,
              radiusX: c.radiusX,
              radiusY: c.radiusY,
              rotationAngle: c.rotationAngle,
              pageX: c.pageX,
              pageY: c.pageY,
              getX: function() {
                return c.screenX;
              },
              getY: function() {
                return c.screenY;
              }
            });
          }, a = this, u = 0; u < e.changedTouches.length; u++)
            i();
      }, t.prototype.dispatchGesture = function(e, n) {
        var i = this.touchSnapshotsMap.get(n) || [], a = i.filter(function(u) {
          return u.type === "touchmove";
        });
        this._onGesture.dispatch(this, {
          epochTs: this.snapshotStartTime.get(n) || 0,
          counter: this.delegate.gesturesCounter,
          type: e,
          events: i,
          eventCounters: this.countEvents(i),
          duration: this.delegate.getInteractionDuration(i),
          additionalData: this.delegate.additionalData,
          uiControl: void 0,
          timeProximity: s._POSignalsUtils.Util.calculateMeanTimeDeltasBetweenEvents(a),
          meanEuclidean: s._POSignalsUtils.Util.calculateMeanDistanceBetweenPoints(a),
          reduction: {}
        }), this.clearTouchSnapshots(n);
      }, t.prototype.isTap = function(e) {
        var n = Math.abs(e[0].x - e[1].x), i = Math.abs(e[0].y - e[1].y);
        return e.length == 2 && n < this.TAP_MOVEMENT_TRESHOLD && i < this.TAP_MOVEMENT_TRESHOLD;
      }, t.prototype.isFling = function(e) {
        return e.length > 1 && e[e.length - 1].eventTs - e[0].eventTs < this.SCROLL_MIN_DURATION;
      }, t.prototype.isScroll = function(e) {
        return e.length > 1 && e[e.length - 1].eventTs - e[0].eventTs > this.SCROLL_MIN_DURATION;
      }, t.prototype.getDirection = function(e) {
        var n = this.calcAngle(e[0], e[e.length - 1]);
        return n > 90 - this.SWIPE_MAX_ANGLE && n <= 90 + this.SWIPE_MAX_ANGLE ? h.Up : n > 180 - this.SWIPE_MAX_ANGLE && n <= 180 + this.SWIPE_MAX_ANGLE ? h.Right : n > 270 - this.SWIPE_MAX_ANGLE && n <= 270 + this.SWIPE_MAX_ANGLE ? h.Down : h.Left;
      }, t.prototype.calcAngle = function(e, n) {
        return 180 * Math.atan2(n.y - e.y, n.x - e.x) / Math.PI + 180;
      }, t;
    }();
    s.GestureEvents = r;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.key = t, this.cache = this.loadFromStorage();
      }
      return r.prototype.loadFromStorage = function() {
        var t = r.sessionStorage.getItem(this.key);
        return t || (t = JSON.stringify([])), JSON.parse(t);
      }, r.prototype.get = function() {
        return this.cache;
      }, Object.defineProperty(r.prototype, "length", {
        get: function() {
          return this.cache.length;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.push = function(t) {
        var e = this.cache.push(t);
        return r.sessionStorage.setItem(this.key, JSON.stringify(this.cache)), e;
      }, r.prototype.set = function(t) {
        this.cache = t, r.sessionStorage.setItem(this.key, JSON.stringify(this.cache));
      }, r.prototype.remove = function(t) {
        this.cache.splice(t, 1), r.sessionStorage.setItem(this.key, JSON.stringify(this.cache));
      }, r.prototype.concat = function(t) {
        return this.cache.concat(t);
      }, r.prototype.clear = function() {
        this.cache = [], r.sessionStorage.removeItem(this.key);
      }, r.sessionStorage = s._POSignalsStorage.SessionStorage.instance.sessionStorage, r;
    }();
    s.StorageArray = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
        this.MAX_TAGS = 10, this._tags = new s.StorageArray(s._POSignalsUtils.Constants.CAPTURED_TAGS);
      }
      return Object.defineProperty(r, "instance", {
        get: function() {
          return r._instance || (r._instance = new r()), r._instance;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "tags", {
        get: function() {
          return this._tags.get();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "disableTags", {
        set: function(t) {
          this._disableTags = t;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.setTag = function(t, e) {
        var n;
        if (!this._disableTags)
          if (s.PointerConfig.instance.pointerParams.enabled)
            if (t) {
              var i = s.PointerConfig.instance.pointerParams.tagsBlacklistRegex;
              if (i && (t.match(i) || e != null && e.match(i)))
                s._POSignalsUtils.Logger.info("Tag name or value is blacklisted");
              else if (!(this._tags.length >= this.MAX_TAGS)) {
                this._tags.push({
                  name: t.trim(),
                  value: ((n = e == null ? void 0 : e.trim) === null || n === void 0 ? void 0 : n.call(e)) || void 0,
                  epochTs: Date.now(),
                  timestamp: Date.now()
                });
                var a = e ? t + ":" + e : t;
                s._POSignalsUtils.Logger.info("Add tag: " + a);
              }
            } else
              s._POSignalsUtils.Logger.info("Can't add tag, missing name");
          else
            s._POSignalsUtils.Logger.info("Can't add tag, PingOneSignals SDK is disabled");
      }, r.prototype.reset = function() {
        this._tags.clear();
      }, r;
    }();
    s.Tags = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.client = t;
      }
      return r.prototype.calculateStrategyResult = function(t, e) {
        return {
          shouldCollect: this.client.getBufferSize() < s.PointerConfig.instance.pointerParams.bufferSize
        };
      }, r;
    }();
    s.FirstInteractionsStrategy = h;
  }(M || (M = {})), function(s) {
    var h;
    (function(t) {
      t[t.RICH = 3] = "RICH", t[t.CLICK = 2] = "CLICK", t[t.MOVE = 1] = "MOVE", t[t.POOR = 0] = "POOR";
    })(h || (h = {}));
    var r = function() {
      function t(e) {
        this.client = e, this.MAX_INTERACTIONS_PER_TYPE = 5, this.MAX_MOUSE_AND_GESTURE = this.MAX_INTERACTIONS_PER_TYPE + 1, this.RICH_MOUSE_MOVES_AMOUNT = 8, this.MIN_KEYBOARD_EVENTS = 4;
      }
      return t.prototype.isRichMouseInteraction = function(e) {
        return e.mousemove >= this.RICH_MOUSE_MOVES_AMOUNT && this.isClickInteraction(e);
      }, t.prototype.isClickInteraction = function(e) {
        return e.mousedown > 0 && e.mouseup > 0;
      }, t.prototype.isMoveInteraction = function(e) {
        return e.mousemove >= this.RICH_MOUSE_MOVES_AMOUNT;
      }, t.prototype.classifyMouseInteraction = function(e) {
        var n = s._POSignalsUtils.Util.typesCounter(e.events);
        return this.isRichMouseInteraction(n) ? h.RICH : this.isClickInteraction(n) ? h.CLICK : this.isMoveInteraction(n) ? h.MOVE : h.POOR;
      }, t.prototype.findMinPriorityGestureIndex = function(e, n) {
        if (n.length === 0)
          return -1;
        for (var i = e ? -1 : 0, a = e ? e.events.length : n[0].events.length, u = 0; u < n.length; u++)
          n[u].events.length < a && (i = u, a = n[u].events.length);
        return i;
      }, t.prototype.calculateStrategyResult = function(e, n) {
        var i = this.client.getBehavioralData();
        switch (n) {
          case "mouse":
            if (i.mouse.interactions.length < this.MAX_INTERACTIONS_PER_TYPE) {
              if (i.touch.interactions.length + i.mouse.interactions.length >= this.MAX_MOUSE_AND_GESTURE) {
                var a = this.findMinPriorityGestureIndex(null, i.touch.interactions);
                if (a !== -1)
                  return { shouldCollect: !0, remove: { type: "touch", index: a } };
              }
              return { shouldCollect: !0 };
            }
            var u = this.classifyMouseInteraction(e);
            if (u === h.POOR)
              return { shouldCollect: !1 };
            for (var c = -1, l = u, d = 0; d < i.mouse.interactions.length; d++) {
              var p = this.classifyMouseInteraction(i.mouse.interactions[d]);
              p < l && (c = d, l = p);
            }
            return c === -1 ? { shouldCollect: !1 } : { shouldCollect: !0, remove: { type: "mouse", index: c } };
          case "keyboard":
            if (i.keyboard.interactions.length < this.MAX_INTERACTIONS_PER_TYPE)
              return { shouldCollect: !0 };
            if (e.events.length < this.MIN_KEYBOARD_EVENTS)
              return { shouldCollect: !1 };
            for (d = 0; d < i.keyboard.interactions.length; d++)
              if (i.keyboard.interactions[d].events.length < this.MIN_KEYBOARD_EVENTS)
                return { shouldCollect: !0, remove: { type: "keyboard", index: d } };
            return { shouldCollect: !1 };
          case "touch":
            if (i.touch.interactions.length < this.MAX_INTERACTIONS_PER_TYPE && i.touch.interactions.length + i.mouse.interactions.length < this.MAX_MOUSE_AND_GESTURE)
              return { shouldCollect: !0 };
            var m = e, k = this.findMinPriorityGestureIndex(m, i.touch.interactions);
            return k === -1 ? { shouldCollect: !1 } : { shouldCollect: !0, remove: { type: "touch", index: k } };
        }
      }, t;
    }();
    s.PriorityStrategy = r;
  }(M || (M = {})), function(s) {
    var h;
    (function(t) {
      t[t.FIRST_INTERACTIONS = 0] = "FIRST_INTERACTIONS", t[t.PRIORITY_INTERACTIONS = 1] = "PRIORITY_INTERACTIONS";
    })(h = s.BufferingStrategyType || (s.BufferingStrategyType = {}));
    var r = function() {
      function t() {
      }
      return t.createBufferingStrategy = function(e, n) {
        switch (e) {
          case h.FIRST_INTERACTIONS:
            return new s.FirstInteractionsStrategy(n);
          case h.PRIORITY_INTERACTIONS:
            return new s.PriorityStrategy(n);
        }
      }, t;
    }();
    s.StrategyFactory = r;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.sessionData = t, this.instanceUUID = s._POSignalsUtils.Util.newGuid(), this._isBehavioralDataPaused = !1, this.started = !1, this.initQueue = new s.PromiseQueue(1);
      }
      return r.instance = function() {
        if (!this._instance) {
          var t = s._POSignalsStorage.SessionStorage.instance;
          if (!document.body)
            throw s._POSignalsUtils.Logger.error(
              "PingOne Signals can be started only after DOM Ready!"
            ), new Error("PingOne Signals can be started only after DOM Ready!");
          this._instance = new s.Client(t, s.BufferingStrategyType.PRIORITY_INTERACTIONS);
        }
        return this._instance;
      }, r.prototype.getData = function() {
        return Z(this, void 0, void 0, function() {
          return $(this, function(t) {
            switch (t.label) {
              case 0:
                if (!this.startedPromise)
                  throw new Error("SDK not initialized");
                return [4, this.startedPromise];
              case 1:
                return t.sent(), [4, this.dataHandler.getData(Date.now())];
              case 2:
                return [2, t.sent()];
            }
          });
        });
      }, r.prototype.addTag = function(t, e) {
        s.Tags.instance.setTag(t, e);
      }, r.prototype.start = function(t) {
        var e, n;
        return t === void 0 && (t = {}), Z(this, void 0, void 0, function() {
          var i, a;
          return $(this, function(u) {
            switch (u.label) {
              case 0:
                return (e = t.waitForWindowLoad) === null || e === void 0 || e ? [4, this.loadEventPromise()] : [3, 2];
              case 1:
                u.sent(), u.label = 2;
              case 2:
                if (this.initParams = t, this.validateStartParams(t), this.clientVersion = s._POSignalsUtils.Constants.CLIENT_VERSION, this.started)
                  return s._POSignalsUtils.Logger.warn("SDK already initialized"), [2];
                this.browserInfo = new s._POSignalsUtils.BrowserInfo(), s._POSignalsUtils.Logger.isLogEnabled = !!t.consoleLogEnabled || !!t.devEnv, s._POSignalsUtils.Logger.info("Starting Signals SDK..."), s.Tags.instance.disableTags = !!this.initParams.disableTags, this.sessionData.setStorageConfig(t), i = s.PointerConfig.instance.pointerParams, a = {
                  additionalMediaCodecs: i.additionalMediaCodecs,
                  browserInfo: this.browserInfo,
                  fingerprintTimeoutMillis: i.fingerprintTimeoutMillis,
                  metadataBlackList: new Set(
                    i.metadataBlackList.concat(t.deviceAttributesToIgnore)
                  ),
                  propertyDescriptors: i.propertyDescriptors,
                  webRtcUrl: i.webRtcUrl,
                  dataPoints: i.metadataDataPoints
                }, this.metadata = new s._POSignalsMetadata.Metadata(this.sessionData, a), this.dataHandler = new s.DataHandler(
                  this.clientVersion,
                  this.instanceUUID,
                  this.initParams,
                  this.metadata,
                  this,
                  t.externalIdentifiers,
                  this.sessionData
                ), ((n = this.initParams.behavioralDataCollection) === null || n === void 0 || n) && this.refreshListening(), t.lazyMetadata || this.metadata.getDeviceAttributes(), this.started = !0;
                try {
                  this.logInit(), this.addStartupTags();
                } catch (c) {
                  s._POSignalsUtils.Logger.warn("SDK post init failed", c);
                }
                return [2];
            }
          });
        });
      }, r.prototype.logInit = function() {
        var t, e;
        s._POSignalsUtils.Logger.info(
          "PingOne Signals initialized. " + JSON.stringify(
            {
              timestamp: (/* @__PURE__ */ new Date()).getTime(),
              sdkVersion: this.clientVersion,
              instanceUUID: this.instanceUUID,
              tabUUID: this.sessionData.tabUUID
            },
            null,
            2
          )
        );
        var n = function() {
          return s._POSignalsUtils.Logger.info("Token Ready: " + window._pingOneSignalsToken);
        }, i = function() {
          s._POSignalsUtils.Logger.info("Signals token fetch is disabled"), window._pingOneSignalsToken = void 0;
        };
        ((t = window._pingOneSignalsToken) === null || t === void 0 ? void 0 : t.substring(0, 7)) === "skipped" ? i() : ((e = window._pingOneSignalsToken) === null || e === void 0 ? void 0 : e.substring(0, 13)) !== "uninitialized" && n(), document.addEventListener("PingOneSignalsTokenReadyEvent", n), document.addEventListener("PingOneSignalsTokenSkippedEvent", i);
      }, Object.defineProperty(r.prototype, "isBehavioralDataPaused", {
        get: function() {
          return this._isBehavioralDataPaused;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.getSignalsToken = function() {
        var t = "";
        if (typeof window._pingOneSignalsToken == "string" && 0 <= window._pingOneSignalsToken.indexOf(":")) {
          var e = window._pingOneSignalsToken.match(/t:(.*?)(&|$)/g);
          e && 0 < e.length && (t = e[0].replace(/&s*$/, "").replace(/t:/, ""));
        } else
          typeof window._pingOneSignalsToken == "string" && (t = window._pingOneSignalsToken);
        return t;
      }, r.prototype.pauseBehavioralData = function() {
        this._isBehavioralDataPaused || (this._isBehavioralDataPaused = !0, this.addTag("SDK paused behaviorally"));
      }, r.prototype.resumeBehavioralData = function() {
        this._isBehavioralDataPaused && (this._isBehavioralDataPaused = !1, this.addTag("SDK resumed behaviorally"));
      }, r.prototype.startSignals = function(t) {
        return Z(this, void 0, void 0, function() {
          var e, n, i = this;
          return $(this, function(a) {
            switch (a.label) {
              case 0:
                return a.trys.push([0, 2, , 3]), this.startedPromise = this.initQueue.add(function() {
                  return i.start(t);
                }), [4, this.startedPromise];
              case 1:
                return [2, a.sent()];
              case 2:
                throw e = a.sent(), n = {
                  id: s._POSignalsUtils.POErrorCodes.INITIALIZATION_ERROR,
                  message: e.message,
                  code: "SDK initialization failed."
                }, new Error(JSON.stringify(n));
              case 3:
                return [2];
            }
          });
        });
      }, r.prototype.validateStartParams = function(t) {
        if (!document.body)
          throw s._POSignalsUtils.Logger.error(
            "PingOne Signals can be started only after DOM Ready!"
          ), new Error("PingOne Signals can be started only after DOM Ready!");
        t.externalIdentifiers = t.externalIdentifiers || {};
      }, r.prototype.loadEventPromise = function() {
        return Z(this, void 0, void 0, function() {
          return $(this, function(t) {
            return [
              2,
              new Promise(function(e) {
                document.readyState === "complete" ? e() : window.addEventListener("load", function(n) {
                  e();
                });
              })
            ];
          });
        });
      }, r.prototype.addStartupTags = function() {
        this.addTag("SDK started"), document.referrer && this.addTag("referrer", document.referrer), this.addTag("location", window.location.href);
      }, r;
    }();
    s.ClientBase = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.BEHAVIORAL_TYPE = "indirect", this._isStarted = !1, this._onClipboardEvent = new s.EventDispatcher(), this.delegate = t, this.onClipboardEventHandler = this.onEvent.bind(this);
      }
      return Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onClipboardEvent", {
        get: function() {
          return this._onClipboardEvent.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.onEvent = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return;
          this._onClipboardEvent.dispatch(this, this.createClipboardEvent(t));
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in clipboard handler", e);
        }
      }, r.prototype.createClipboardEvent = function(t) {
        var e = s._POSignalsUtils.Util.getSrcElement(t);
        return {
          category: "ClipboardEvent",
          type: t.type,
          eventTs: t.timeStamp,
          epochTs: (/* @__PURE__ */ new Date()).getTime(),
          additionalData: {
            locationHref: location.href,
            stId: this.delegate.getElementsStID(e),
            elementId: e == null ? void 0 : e.id
          }
        };
      }, r.prototype.start = function() {
        this._isStarted || (this._isStarted = !0, this.delegate.addEventListener(document, "cut", this.onClipboardEventHandler), this.delegate.addEventListener(document, "copy", this.onClipboardEventHandler), this.delegate.addEventListener(document, "paste", this.onClipboardEventHandler));
      }, r.prototype.stop = function() {
        this._isStarted && (this._isStarted = !1, document.removeEventListener("cut", this.onClipboardEventHandler), document.removeEventListener("copy", this.onClipboardEventHandler), document.removeEventListener("paste", this.onClipboardEventHandler));
      }, r;
    }();
    s.ClipboardEvents = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.BEHAVIORAL_TYPE = "indirect", this._isStarted = !1, this._onDragEvent = new s.EventDispatcher(), this.delegate = t, this.onDragEventHandler = this.onEvent.bind(this);
      }
      return Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onDragEvent", {
        get: function() {
          return this._onDragEvent.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.createDragEvent = function(t) {
        return {
          category: "DragEvent",
          type: t.type,
          eventTs: t.timeStamp,
          epochTs: (/* @__PURE__ */ new Date()).getTime(),
          additionalData: { locationHref: location.href }
        };
      }, r.prototype.onEvent = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return;
          this._onDragEvent.dispatch(this, this.createDragEvent(t));
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in drag handler", e);
        }
      }, r.prototype.start = function() {
        this._isStarted || (this._isStarted = !0, this.delegate.addEventListener(document, "dragstart", this.onDragEventHandler), this.delegate.addEventListener(document, "dragexit", this.onDragEventHandler), this.delegate.addEventListener(document, "drop", this.onDragEventHandler), this.delegate.addEventListener(document, "dragend", this.onDragEventHandler));
      }, r.prototype.stop = function() {
        this._isStarted && (this._isStarted = !1, document.removeEventListener("dragstart", this.onDragEventHandler), document.removeEventListener("dragexit", this.onDragEventHandler), document.removeEventListener("drop", this.onDragEventHandler), document.removeEventListener("dragend", this.onDragEventHandler));
      }, r;
    }();
    s.DragEvents = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.BEHAVIORAL_TYPE = "indirect", this._isStarted = !1, this._onFocusEvent = new s.EventDispatcher(), this.delegate = t, this.onFocusEventHandler = this.onEvent.bind(this);
      }
      return Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onFocusEvent", {
        get: function() {
          return this._onFocusEvent.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.getRelatedTarget = function(t) {
        if (!t.relatedTarget)
          return { type: "", stId: "", elementId: "" };
        var e = {
          type: s._POSignalsUtils.Util.getObjectType(t.relatedTarget),
          stId: "",
          elementId: ""
        };
        t.relatedTarget.id && (e.elementId = t.relatedTarget.id);
        try {
          var n = t.relatedTarget;
          e.stId = this.delegate.getElementsStID(n);
        } catch {
        }
        return e;
      }, r.prototype.createFocusEvent = function(t) {
        var e = s._POSignalsUtils.Util.getSrcElement(t), n = this.getRelatedTarget(t);
        return {
          category: "FocusEvent",
          type: t.type,
          eventTs: t.timeStamp,
          epochTs: (/* @__PURE__ */ new Date()).getTime(),
          additionalData: {
            locationHref: location.href,
            stId: this.delegate.getElementsStID(e),
            elementId: e ? e.id : "",
            relatedTarget: n
          }
        };
      }, r.prototype.onEvent = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return;
          this._onFocusEvent.dispatch(this, this.createFocusEvent(t));
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in focus handler", e);
        }
      }, r.prototype.start = function() {
        this._isStarted || (this._isStarted = !0, this.delegate.addEventListener(document, "DOMFocusIn", this.onFocusEventHandler), this.delegate.addEventListener(document, "DOMFocusOut", this.onFocusEventHandler), this.delegate.addEventListener(document, "focus", this.onFocusEventHandler), this.delegate.addEventListener(document, "focusin", this.onFocusEventHandler), this.delegate.addEventListener(document, "focusout", this.onFocusEventHandler));
      }, r.prototype.stop = function() {
        this._isStarted && (this._isStarted = !1, document.removeEventListener("DOMFocusIn", this.onFocusEventHandler), document.removeEventListener("DOMFocusOut", this.onFocusEventHandler), document.removeEventListener("focus", this.onFocusEventHandler), document.removeEventListener("focusin", this.onFocusEventHandler), document.removeEventListener("focusout", this.onFocusEventHandler));
      }, r;
    }();
    s.FocusEvents = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.BEHAVIORAL_TYPE = "indirect", this._isStarted = !1, this._onUIEvent = new s.EventDispatcher(), this.delegate = t, this.onUIEventHandler = this.onEvent.bind(this);
      }
      return Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onUIEvent", {
        get: function() {
          return this._onUIEvent.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.createUIEvent = function(t) {
        return {
          category: "UIEvent",
          type: t.type,
          eventTs: t.timeStamp,
          epochTs: (/* @__PURE__ */ new Date()).getTime(),
          additionalData: { locationHref: location.href }
        };
      }, r.prototype.onEvent = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return;
          this._onUIEvent.dispatch(this, this.createUIEvent(t));
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in UIEvent handler", e);
        }
      }, r.prototype.start = function() {
        this._isStarted || (this._isStarted = !0, this.delegate.addEventListener(document, "resize", this.onUIEventHandler), this.delegate.addEventListener(document, "scroll", this.onUIEventHandler), this.delegate.addEventListener(document, "select", this.onUIEventHandler));
      }, r.prototype.stop = function() {
        this._isStarted && (this._isStarted = !1, document.removeEventListener("resize", this.onUIEventHandler), document.removeEventListener("scroll", this.onUIEventHandler), document.removeEventListener("select", this.onUIEventHandler));
      }, r;
    }();
    s.UIEvents = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.BEHAVIORAL_TYPE = "indirect", this.visibilityChangeEventName = "visibilitychange", this.hiddenProperty = "hidden", this._isStarted = !1, this._onGeneralEvent = new s.EventDispatcher(), this.delegate = t, this.onGeneralEventHandler = this.onEvent.bind(this), this.onLangChangeHandler = this.onLangChangeEvent.bind(this), this.onOrientationChangeHandler = this.onOrientationChangeEvent.bind(this), this.onVisibilityChangeHandler = this.onVisibilityChangeEvent.bind(this), document.msHidden !== void 0 ? (this.hiddenProperty = "msHidden", this.visibilityChangeEventName = "msvisibilitychange") : document.webkitHidden !== void 0 && (this.hiddenProperty = "webkitHidden", this.visibilityChangeEventName = "webkitvisibilitychange");
      }
      return Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onGeneralEvent", {
        get: function() {
          return this._onGeneralEvent.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.onEvent = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return;
          this._onGeneralEvent.dispatch(this, this.createGeneralEvent(t));
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in general event handler", e);
        }
      }, r.prototype.onLangChangeEvent = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return;
          var e = this.createGeneralEvent(t);
          this._onGeneralEvent.dispatch(this, e);
        } catch (n) {
          s._POSignalsUtils.Logger.warn("error in LangChange event handler", n);
        }
      }, r.prototype.onOrientationChangeEvent = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return;
          var e = this.createGeneralEvent(t), n = s._POSignalsUtils.Util.getDeviceOrientation();
          e.additionalData.deviceOrientation = n.orientation, e.additionalData.deviceAngle = n.angle, this._onGeneralEvent.dispatch(this, e);
        } catch (i) {
          s._POSignalsUtils.Logger.warn("error in OrientationChange event handler", i);
        }
      }, r.prototype.onVisibilityChangeEvent = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return;
          var e = this.createGeneralEvent(t);
          e.additionalData.hidden = !!document[this.hiddenProperty], document.visibilityState && (e.additionalData.visibilityState = document.visibilityState.toString()), this._onGeneralEvent.dispatch(this, e);
        } catch (n) {
          s._POSignalsUtils.Logger.warn("error in VisibilityChange event handler", n);
        }
      }, r.prototype.createGeneralEvent = function(t) {
        return {
          category: "Event",
          type: t.type,
          eventTs: t.timeStamp,
          epochTs: (/* @__PURE__ */ new Date()).getTime(),
          additionalData: { locationHref: location.href }
        };
      }, r.prototype.start = function() {
        this._isStarted || (this._isStarted = !0, this.delegate.addEventListener(
          document,
          this.visibilityChangeEventName,
          this.onVisibilityChangeHandler
        ), this.delegate.addEventListener(document, "change", this.onGeneralEventHandler), this.delegate.addEventListener(
          document,
          "fullscreenchange",
          this.onGeneralEventHandler
        ), this.delegate.addEventListener(document, "invalid", this.onGeneralEventHandler), this.delegate.addEventListener(window, "languagechange", this.onLangChangeHandler), this.delegate.addEventListener(
          window,
          "orientationchange",
          this.onOrientationChangeHandler
        ), this.delegate.addEventListener(document, "seeked", this.onGeneralEventHandler), this.delegate.addEventListener(document, "seeking", this.onGeneralEventHandler), this.delegate.addEventListener(document, "selectstart", this.onGeneralEventHandler), this.delegate.addEventListener(
          document,
          "selectionchange",
          this.onGeneralEventHandler
        ), this.delegate.addEventListener(document, "submit", this.onGeneralEventHandler), this.delegate.addEventListener(document, "volumechange", this.onGeneralEventHandler), this.delegate.addEventListener(document, "reset", this.onGeneralEventHandler), this.delegate.addEventListener(document, "textInput", this.onGeneralEventHandler));
      }, r.prototype.stop = function() {
        this._isStarted && (this._isStarted = !1, document.removeEventListener(
          this.visibilityChangeEventName,
          this.onVisibilityChangeHandler
        ), document.removeEventListener("change", this.onGeneralEventHandler), document.removeEventListener("fullscreenchange", this.onGeneralEventHandler), document.removeEventListener("invalid", this.onGeneralEventHandler), window.removeEventListener("languagechange", this.onLangChangeHandler), window.removeEventListener("orientationchange", this.onOrientationChangeHandler), document.removeEventListener("seeked", this.onGeneralEventHandler), document.removeEventListener("seeking", this.onGeneralEventHandler), document.removeEventListener("selectstart", this.onGeneralEventHandler), document.removeEventListener("selectionchange", this.onGeneralEventHandler), document.removeEventListener("submit", this.onGeneralEventHandler), document.removeEventListener("volumechange", this.onGeneralEventHandler), document.removeEventListener("reset", this.onGeneralEventHandler), document.removeEventListener("textInput", this.onGeneralEventHandler));
      }, r;
    }();
    s.GeneralEvents = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.DEFAULT_INDIRECT_IDLE_INTERVAL = 1e3, this.MAX_INDIRECT_EVENTS = 25, this._onIndirect = new s.EventDispatcher(), this.indirectEvents = [], this.idleTimeInMillis = this.DEFAULT_INDIRECT_IDLE_INTERVAL, this.lastIndirectEventTimestamp = 0, this._isStarted = !1, this.clipboardEvents = new s.ClipboardEvents(t), this.clipboardEvents.onClipboardEvent.subscribe(this.handleEvent.bind(this)), this.dragEvents = new s.DragEvents(t), this.dragEvents.onDragEvent.subscribe(this.handleEvent.bind(this)), this.focusEvents = new s.FocusEvents(t), this.focusEvents.onFocusEvent.subscribe(this.handleEvent.bind(this)), this.uiEvents = new s.UIEvents(t), this.uiEvents.onUIEvent.subscribe(this.handleEvent.bind(this)), this.generalEvents = new s.GeneralEvents(t), this.generalEvents.onGeneralEvent.subscribe(this.handleEvent.bind(this)), this.onTimeElapsedHandler = this.onTimeElapsed.bind(this);
      }
      return Object.defineProperty(r.prototype, "onIndirect", {
        get: function() {
          return this._onIndirect.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.onTimeElapsed = function() {
        return Z(this, void 0, void 0, function() {
          return $(this, function(t) {
            return this.indirectEvents.length > 0 && (/* @__PURE__ */ new Date()).getTime() - this.lastIndirectEventTimestamp >= this.idleTimeInMillis && this.dispatch(), [2];
          });
        });
      }, r.prototype.handleEvent = function(t, e) {
        this.lastIndirectEventTimestamp = (/* @__PURE__ */ new Date()).getTime(), this.pushEvent(e);
      }, r.prototype.pushEvent = function(t) {
        this.indirectEvents.push(t), this.indirectEvents.length >= this.MAX_INDIRECT_EVENTS && this.dispatch();
      }, r.prototype.clearBuffer = function() {
        var t = { events: this.indirectEvents };
        return this.indirectEvents = [], t;
      }, r.prototype.dispatch = function() {
        try {
          clearInterval(this.updateIntervalHandle), this._onIndirect.dispatch(this, this.clearBuffer()), this.updateIntervalHandle = setInterval(
            this.onTimeElapsedHandler,
            s.PointerConfig.instance.pointerParams.indirectIntervalMillis
          );
        } catch (t) {
          s._POSignalsUtils.Logger.warn("Failed to dispatch indirect events", t);
        }
      }, Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.start = function() {
        this._isStarted || (this.updateIntervalHandle = setInterval(
          this.onTimeElapsedHandler,
          s.PointerConfig.instance.pointerParams.indirectIntervalMillis
        ), this.clipboardEvents.start(), this.dragEvents.start(), this.focusEvents.start(), this.uiEvents.start(), this.generalEvents.start(), this._isStarted = !0);
      }, r.prototype.stop = function() {
        this._isStarted && (this.clipboardEvents.stop(), this.dragEvents.stop(), this.focusEvents.stop(), this.uiEvents.stop(), this.generalEvents.stop(), clearInterval(this.updateIntervalHandle), this.updateIntervalHandle = null, this._isStarted = !1);
      }, r.prototype.unsubscribe = function() {
        this.clipboardEvents.onClipboardEvent.unsubscribe(this.handleEvent.bind(this)), this.dragEvents.onDragEvent.unsubscribe(this.handleEvent.bind(this)), this.focusEvents.onFocusEvent.unsubscribe(this.handleEvent.bind(this)), this.uiEvents.onUIEvent.unsubscribe(this.handleEvent.bind(this)), this.generalEvents.onGeneralEvent.unsubscribe(this.handleEvent.bind(this));
      }, r;
    }();
    s.IndirectClient = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
        this.config = {}, this._cacheHash = 0, this.cache = /* @__PURE__ */ new Map();
      }
      return r.prototype.refreshCssSelectors = function(t) {
        try {
          if (!t)
            return;
          var e = s._POSignalsUtils.Util.hashCode(JSON.stringify(t));
          if (this._cacheHash === e)
            return;
          this.config = t, this._cacheHash = e, this.cache = /* @__PURE__ */ new Map();
        } catch (n) {
          s._POSignalsUtils.Logger.warn("Failed to set css selectors", n);
        }
      }, r.prototype.getIdentification = function(t, e) {
        if (this.cache.get(t) === null)
          return null;
        if (this.cache.get(t) !== void 0)
          return this.cache.get(t);
        for (var n in this.config)
          try {
            if (!this.config.hasOwnProperty(n))
              continue;
            var i = this.config[n] || [];
            s._POSignalsUtils.Util.isArray(i) || (i = [].concat(i));
            for (var a = 0, u = i; a < u.length; a++) {
              var c = u[a];
              if (s._POSignalsUtils.Util.isSelectorMatches(t, c, e))
                return this.cache.set(t, n), n;
            }
          } catch (l) {
            s._POSignalsUtils.Logger.warn("Failed to find selector for " + n, l);
          }
        return this.cache.set(t, null), null;
      }, Object.defineProperty(r.prototype, "cacheHash", {
        get: function() {
          return this._cacheHash;
        },
        enumerable: !1,
        configurable: !0
      }), r;
    }();
    s.ElementsIdentifications = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t, e) {
        this.BEHAVIORAL_TYPE = "eventKeyboard", this._isStarted = !1, this._onInteraction = new s.EventDispatcher(), this._onEnterPress = new s.EventDispatcher(), this._onObfuscatedValue = new s.EventDispatcher(), this.interactionsMap = /* @__PURE__ */ new Map(), this._fieldsIdentifications = new s.ElementsIdentifications(), this.keyStrokeMap = /* @__PURE__ */ new Map(), this.delegate = t, this.uiControlManager = e, this.onKeyDownHandle = this.onKeyDown.bind(this), this.onKeyUpHandle = this.onKeyUp.bind(this), this.onFocusHandle = this.onFocus.bind(this), this.onBlurHandle = this.onBlur.bind(this);
      }
      return Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onInteraction", {
        get: function() {
          return this._onInteraction.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onEnterPress", {
        get: function() {
          return this._onEnterPress.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onObfuscatedValue", {
        get: function() {
          return this._onObfuscatedValue.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.refreshKeyboardCssSelectors = function(t) {
        this._fieldsIdentifications.refreshCssSelectors(t);
      }, Object.defineProperty(r.prototype, "modifiersKeys", {
        get: function() {
          return [
            "Alt",
            "AltGraph",
            "CapsLock",
            "Control",
            "Fn",
            "FnLock",
            "Hyper",
            "Meta",
            "NumLock",
            "OS",
            "ScrollLock",
            "Shift",
            "Super",
            "Symbol",
            "SymbolLock"
          ];
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "specialKeys", {
        get: function() {
          return [
            "Tab",
            "Shift",
            "Backspace",
            "Enter",
            "CapsLock",
            "Meta",
            "Delete",
            "Alt",
            "ArrowDown",
            "ArrowUp",
            "Control",
            "ArrowLeft",
            "End",
            "Unidentified",
            "Home",
            "ArrowRight",
            "Insert",
            "Pause",
            "PageDown",
            "PageUp",
            "F1",
            "F2",
            "F3",
            "F4",
            "F5",
            "F6",
            "F7",
            "F8",
            "F9",
            "F10",
            "F11",
            "F12",
            "AltGraph",
            "Escape"
          ];
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.countEvent = function(t, e) {
        e && (e.eventCounters[t] = (e.eventCounters[t] || 0) + 1);
      }, r.prototype.clearBuffer = function() {
        var t = s._POSignalsUtils.Util.getValuesOfMap(this.interactionsMap);
        return this.interactionsMap.clear(), t;
      }, r.prototype.start = function() {
        this._isStarted ? s._POSignalsUtils.Logger.debug("Desktop Keyboard events already listening") : (this.delegate.addEventListener(document, "keydown", this.onKeyDownHandle), this.delegate.addEventListener(document, "keyup", this.onKeyUpHandle), this.delegate.addEventListener(document, "focus", this.onFocusHandle, !0), this.delegate.addEventListener(document, "blur", this.onBlurHandle, !0), this._isStarted = !0, s._POSignalsUtils.Logger.debug("Desktop Keyboard events start listening..."));
      }, r.prototype.stop = function() {
        this._isStarted ? (document.removeEventListener("keydown", this.onKeyDownHandle), document.removeEventListener("keyup", this.onKeyUpHandle), document.removeEventListener("focus", this.onFocusHandle, !0), document.removeEventListener("blur", this.onBlurHandle, !0), this._isStarted = !1, s._POSignalsUtils.Logger.debug("Desktop Keyboard events stop listening...")) : s._POSignalsUtils.Logger.debug("Desktop Keyboard events already stopped");
      }, r.prototype.getInteractionFromElement = function(t) {
        var e, n = null, i = null, a = s._POSignalsUtils.Util.getSrcElement(t);
        if (a && a instanceof HTMLInputElement && !s._POSignalsUtils.Util.isClickableInput(a) && s._POSignalsUtils.Util.isFunction(a.getAttribute) && !(!((e = a.hasAttribute) === null || e === void 0) && e.call(a, "data-st-ignore")) && !s._POSignalsUtils.Util.anySelectorMatches(
          a,
          s.PointerConfig.instance.pointerParams.keyboardCssSelectorsBlacklist,
          0
        )) {
          i = this.delegate.getElementsStID(a);
          for (var u = s.PointerConfig.instance.pointerParams.keyboardIdentifierAttributes, c = 0; c < u.length && !i; c++)
            i = a.getAttribute(u[c]);
          i && !s.PointerConfig.instance.pointerParams.keyboardFieldBlackList.has(i) && ((n = this.interactionsMap.get(a)) || (n = {
            epochTs: (/* @__PURE__ */ new Date()).getTime(),
            stId: i,
            elementId: s._POSignalsUtils.Util.getAttribute(a, "id"),
            name: s._POSignalsUtils.Util.getAttribute(a, "name"),
            type: s._POSignalsUtils.Util.getAttribute(a, "type"),
            events: [],
            counter: this.delegate.keyboardCounter,
            eventCounters: {},
            duration: 0,
            numOfDeletions: 0,
            additionalData: this.delegate.additionalData
          }, this.interactionsMap.set(a, n)));
        }
        return n;
      }, r.prototype.getKeyCode = function(t) {
        return t.keyCode ? t.keyCode : t.which ? t.which : t.code ? s._POSignalsUtils.Util.hashCode(t.code) : s._POSignalsUtils.Util.hashCode(t.key) + (t.location || 0);
      }, r.prototype.getKeyboardEvent = function(t) {
        return t || window.event;
      }, r.prototype.getKeystrokeId = function(t, e) {
        var n, i = this.getKeyCode(t);
        return e === "keyup" && (this.keyStrokeMap.has(i) ? (n = this.keyStrokeMap.get(i), this.keyStrokeMap.delete(i)) : n = s._POSignalsUtils.Util.newGuid()), e === "keydown" && (this.keyStrokeMap.has(i) && t.repeat ? n = this.keyStrokeMap.get(i) : (n = s._POSignalsUtils.Util.newGuid(), this.keyStrokeMap.set(i, n))), n;
      }, r.prototype.createKeyboardInteractionEvent = function(t, e) {
        var n = s._POSignalsUtils.Util.getSrcElement(e), i = n.value ? n.value.toString().length : 0;
        return {
          type: t,
          eventTs: e.timeStamp,
          epochTs: (/* @__PURE__ */ new Date()).getTime(),
          selectionStart: s._POSignalsUtils.Util.getElementSelectionStart(n),
          selectionEnd: s._POSignalsUtils.Util.getElementSelectionEnd(n),
          key: null,
          keystrokeId: null,
          currentLength: i
        };
      }, r.prototype.enrichKeyboardEvent = function(t, e) {
        (this.modifiersKeys.indexOf(t.key) >= 0 || this.specialKeys.indexOf(t.key) >= 0) && (e.key = t.key), e.keystrokeId = this.getKeystrokeId(t, e.type);
        var n = s._POSignalsUtils.Util.getSrcElement(t);
        e.currentLength = String(n.value).length;
      }, r.prototype.onFocus = function(t) {
        var e, n;
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return void this._onInteraction.dispatch(this, null);
          t = this.getKeyboardEvent(t);
          var i = this.getInteractionFromElement(t);
          if (this.countEvent(t.type, i), s.PointerConfig.instance.pointerParams.eventsToIgnore.has(t.type))
            return;
          if (i) {
            var a = this.createKeyboardInteractionEvent("focus", t);
            i.events.push(a);
            var u = this.uiControlManager.createUIControlData(t);
            u && (i.uiControl = { uiElement: u.uiElement, enrichedData: u.enrichedData }, ((n = (e = u.uiElement) === null || e === void 0 ? void 0 : e.id) === null || n === void 0 ? void 0 : n.length) > 0 && s._POSignalsUtils.Logger.info(
              "Typing in element with id '" + u.uiElement.id + "'"
            ));
          }
        } catch (c) {
          s._POSignalsUtils.Logger.warn("error in keyboard focus handler", c);
        }
      }, r.prototype.onKeyUp = function(t) {
        try {
          if ((t = this.getKeyboardEvent(t)).keyCode !== 13 && t.which !== 13 || this._onEnterPress.dispatch(this, s._POSignalsUtils.Util.getSrcElement(t)), !this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return void this._onInteraction.dispatch(this, null);
          var e = this.getInteractionFromElement(t);
          if (this.countEvent(t.type, e), s.PointerConfig.instance.pointerParams.eventsToIgnore.has(t.type))
            return;
          if (e) {
            var n = this.createKeyboardInteractionEvent("keyup", t);
            this.enrichKeyboardEvent(t, n), e.events.push(n);
          } else
            this.keyStrokeMap.delete(this.getKeyCode(t));
        } catch (i) {
          s._POSignalsUtils.Logger.warn("error in keyUp handler", i);
        }
      }, r.prototype.isEmpty = function() {
        return this.interactionsMap.size === 0;
      }, r.prototype.onKeyDown = function(t) {
        try {
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return void this._onInteraction.dispatch(this, null);
          t = this.getKeyboardEvent(t);
          var e = this.getInteractionFromElement(t);
          if (this.countEvent(t.type, e), s.PointerConfig.instance.pointerParams.eventsToIgnore.has(t.type))
            return;
          if (e) {
            var n = this.createKeyboardInteractionEvent("keydown", t);
            this.enrichKeyboardEvent(t, n), e.events.push(n);
          }
        } catch (i) {
          s._POSignalsUtils.Logger.warn("error in keyDown handler", i);
        }
      }, r.prototype.onBlur = function(t) {
        try {
          t = this.getKeyboardEvent(t);
          var e = this.getInteractionFromElement(t);
          if (!this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE))
            return void this._onInteraction.dispatch(this, null);
          if (this.countEvent(t.type, e), s.PointerConfig.instance.pointerParams.eventsToIgnore.has(t.type))
            return;
          if (e) {
            var n = this.createKeyboardInteractionEvent("blur", t);
            e.events.push(n), e.duration = this.delegate.getInteractionDuration(e.events), e.numOfDeletions = this.calculateNumOfDeletions(e.events);
            var i = s._POSignalsUtils.Util.getSrcElement(t);
            this.interactionsMap.delete(i), this._onInteraction.dispatch(this, e);
          }
        } catch (a) {
          s._POSignalsUtils.Logger.warn("error in blur handler", a);
        }
      }, r.prototype.calculateNumOfDeletions = function(t) {
        if (!(t != null && t[0]))
          return 0;
        for (var e = 0, n = t[0].currentLength, i = 1; i < t.length; i++)
          t[i].currentLength < n && e++, n = t[i].currentLength;
        return e;
      }, Object.defineProperty(r.prototype, "fieldsIdentifications", {
        get: function() {
          return this._fieldsIdentifications;
        },
        enumerable: !1,
        configurable: !0
      }), r;
    }();
    s.Keyboard = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t, e) {
        var n, i = this, a = s.PointerConfig.instance.pointerParams.uiModelingElementFilters, u = s._POSignalsUtils.Util.getAttribute, c = (n = t.getBoundingClientRect) === null || n === void 0 ? void 0 : n.call(t);
        this._htmlElement = t, this._data = {
          location: this.getUIElementAttribute(a.location, function() {
            return window.location.href;
          }),
          id: this.getUIElementAttribute(a.id, function() {
            return u(t, "id");
          }),
          aria_label: this.getUIElementAttribute(a.aria_label, function() {
            return u(t, "aria-label");
          }),
          data_st_field: this.getUIElementAttribute(a.data_st_field, function() {
            return e.getElementsStID(t);
          }),
          data_st_tag: this.getUIElementAttribute(a.data_st_tag, function() {
            return u(t, "data-st-tag");
          }),
          data_selenium: this.getUIElementAttribute(a.data_selenium, function() {
            return u(t, "data-selenium");
          }),
          data_selenium_id: this.getUIElementAttribute(a.data_selenium_id, function() {
            return u(t, "data-selenium-id");
          }),
          data_testid: this.getUIElementAttribute(a.data_testid, function() {
            return u(t, "data-testid");
          }),
          data_test_id: this.getUIElementAttribute(a.data_test_id, function() {
            return u(t, "data-test-id");
          }),
          data_qa_id: this.getUIElementAttribute(a.data_qa_id, function() {
            return u(t, "data-qa-id");
          }),
          data_id: this.getUIElementAttribute(a.data_id, function() {
            return u(t, "data-id");
          }),
          name: this.getUIElementAttribute(a.name, function() {
            return u(t, "name");
          }),
          placeholder: this.getUIElementAttribute(a.placeholder, function() {
            return u(t, "placeholder");
          }),
          role: this.getUIElementAttribute(a.role, function() {
            return u(t, "role");
          }),
          type: this.getUIElementAttribute(a.type, function() {
            return u(t, "type");
          }),
          nodeTypeInt: this.getUIElementAttribute(a.nodeTypeInt, function() {
            return t.nodeType;
          }),
          nodeName: this.getUIElementAttribute(a.nodeName, function() {
            return t.nodeName;
          }),
          cursorType: this.getUIElementAttribute(a.cursorType, function() {
            return window.getComputedStyle(t).cursor;
          }),
          text: this.getUIElementAttribute(a.text, function() {
            return i.getElementText(t);
          }),
          textLength: this.getUIElementAttribute(a.textLength, function() {
            var l;
            return ((l = i.getElementText(t)) === null || l === void 0 ? void 0 : l.length) || null;
          }),
          bottom: this.getUIElementAttribute(a.bottom, function() {
            return c == null ? void 0 : c.bottom;
          }),
          height: this.getUIElementAttribute(a.height, function() {
            return c == null ? void 0 : c.height;
          }),
          left: this.getUIElementAttribute(a.left, function() {
            return c == null ? void 0 : c.left;
          }),
          right: this.getUIElementAttribute(a.right, function() {
            return c == null ? void 0 : c.right;
          }),
          top: this.getUIElementAttribute(a.top, function() {
            return c == null ? void 0 : c.top;
          }),
          width: this.getUIElementAttribute(a.width, function() {
            return c == null ? void 0 : c.width;
          }),
          x: this.getUIElementAttribute(a.x, function() {
            return c == null ? void 0 : c.x;
          }),
          y: this.getUIElementAttribute(a.y, function() {
            return c == null ? void 0 : c.y;
          })
        }, this._data.elementId = this.getStrongestElementID();
      }
      return Object.defineProperty(r.prototype, "data", {
        get: function() {
          return s._POSignalsUtils.Util.filterReduce(this._data, function(t) {
            return t != null && t !== "";
          });
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "htmlElement", {
        get: function() {
          return this._htmlElement;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.getUIElementAttribute = function(t, e) {
        var n;
        try {
          if ((n = t == null ? void 0 : t.enabled) === null || n === void 0 || n) {
            var i = e();
            return typeof i == "string" && (typeof (t == null ? void 0 : t.maxLength) == "number" && i.length > t.maxLength && (i = i.substring(0, t.maxLength)), t != null && t.filterRegex && (i = i.replace(new RegExp(t.filterRegex, "g"), "*"))), i;
          }
        } catch (a) {
          s._POSignalsUtils.Logger.warn("Failed to add ui element attribute", a);
        }
        return null;
      }, r.prototype.getStrongestElementID = function() {
        return this._data.data_st_field || this._data.data_selenium_id || this._data.data_selenium || this._data.data_testid || this._data.data_test_id || this._data.data_qa_id || this._data.data_id || this._data.id || "";
      }, r.prototype.getElementText = function(t) {
        return t instanceof HTMLInputElement && !s._POSignalsUtils.Util.isClickableInput(t) ? null : s._POSignalsUtils.Util.getElementText(t);
      }, r.prototype.equals = function(t) {
        return !!t && !(t.location && location.href.indexOf(t.location) < 0) && (!t.elementId || t.elementId === this._data.elementId) && (!t.id || t.id === this._data.id) && (!t.aria_label || t.aria_label === this._data.aria_label) && (!t.data_st_field || t.data_st_field === this._data.data_st_field) && (!t.data_st_tag || t.data_st_tag === this._data.data_st_tag) && (!t.data_selenium || t.data_selenium === this._data.data_selenium) && (!t.data_selenium_id || t.data_selenium_id === this._data.data_selenium_id) && (!t.data_testid || t.data_testid === this._data.data_testid) && (!t.data_test_id || t.data_test_id === this._data.data_test_id) && (!t.data_qa_id || t.data_qa_id === this._data.data_qa_id) && (!t.data_id || t.data_id === this._data.data_id) && (!t.name || t.name === this._data.name) && (!t.placeholder || t.placeholder === this._data.placeholder) && (!t.role || t.role === this._data.role) && (!t.type || t.type === this._data.type) && (!t.nodeTypeInt || t.nodeTypeInt === this._data.nodeTypeInt) && (!t.nodeName || t.nodeName === this._data.nodeName) && (!t.cursorType || t.cursorType === this._data.cursorType) && (!t.text || t.text === this._data.text) && (!t.textLength || t.textLength === this._data.textLength) && (!t.bottom || t.bottom === this._data.bottom) && (!t.height || t.height === this._data.height) && (!t.left || t.left === this._data.left) && (!t.right || t.right === this._data.right) && (!t.top || t.top === this._data.top) && (!t.width || t.width === this._data.width) && (!t.x || t.x === this._data.x) && (!t.y || t.y === this._data.y);
      }, r.createCssSelector = function(t) {
        var e = "";
        return t != null && t.nodeName && (e += t.nodeName.toLowerCase()), t != null && t.id && (e += '[id="' + t.id + '"]'), t != null && t.aria_label && (e += '[aria-label="' + t.aria_label + '"]'), t != null && t.data_st_field && (e += '[data-st-field="' + t.data_st_field + '"]'), t != null && t.data_st_tag && (e += '[data-st-tag="' + t.data_st_tag + '"]'), t != null && t.data_selenium && (e += '[data-selenium="' + t.data_selenium + '"]'), t != null && t.data_selenium_id && (e += '[data-selenium-id="' + t.data_selenium_id + '"]'), t != null && t.data_testid && (e += '[data-testid="' + t.data_testid + '"]'), t != null && t.data_test_id && (e += '[data-test-id="' + t.data_test_id + '"]'), t != null && t.data_qa_id && (e += '[data-qa-id="' + t.data_qa_id + '"]'), t != null && t.data_id && (e += '[data-id="' + t.data_id + '"]'), t != null && t.name && (e += '[name="' + t.name + '"]'), t != null && t.placeholder && (e += '[placeholder="' + t.placeholder + '"]'), t != null && t.role && (e += '[role="' + t.role + '"]'), t != null && t.type && (e += '[type="' + t.type + '"]'), e;
      }, r;
    }();
    s.UiElement = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this._clientDelegate = t;
      }
      return r.prototype.createUIControlData = function(t) {
        var e = s._POSignalsUtils.Util.getSrcElement(t);
        if (!e)
          return null;
        var n = s.PointerConfig.instance.pointerParams.uiModelingBlacklistRegex;
        if (n && window.location.href.match(n))
          return s._POSignalsUtils.Logger.debug("ui control data is disabled for this url"), null;
        var i = new s.UiElement(e, this._clientDelegate);
        return this.findMatchingUiControl(i) || { uiElement: i.data };
      }, r.prototype.findMatchingUiControl = function(t, e) {
        e === void 0 && (e = 0);
        try {
          var n = s.PointerConfig.instance.pointerParams.uiControlsConfig;
          if (n.length === 0 || e > s.PointerConfig.instance.pointerParams.uiModelingMaxMatchingParents)
            return null;
          for (var i = !1, a = 0, u = n; a < u.length; a++) {
            var c = u[a];
            if ((c.tagConfig || c.enrichedData) && (i = !0, t.equals(c.uiElement)))
              return {
                uiElement: t.data,
                enrichedData: c.enrichedData,
                tagConfig: c.tagConfig
              };
          }
          if (!i)
            return null;
          var l = t.htmlElement.parentElement;
          if ((l == null ? void 0 : l.nodeType) === Node.ELEMENT_NODE) {
            var d = new s.UiElement(l, this._clientDelegate);
            return this.findMatchingUiControl(d, e + 1);
          }
        } catch (p) {
          s._POSignalsUtils.Logger.warn("failed to find matching ui control", p);
        }
        return null;
      }, r.prototype.convertToTagValueConfig = function(t) {
        var e;
        return {
          context: (e = t == null ? void 0 : t.uiElement) === null || e === void 0 ? void 0 : e.location,
          valueSelector: s.UiElement.createCssSelector(
            t == null ? void 0 : t.uiElement
          ),
          operation: t == null ? void 0 : t.operation,
          valueMandatory: t == null ? void 0 : t.valueMandatory
        };
      }, r;
    }();
    s.UIControlManager = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t, e) {
        this.BEHAVIORAL_TYPE = "mouse", this._isStarted = !1, this._onInteraction = new s.EventDispatcher(), this._onClickEvent = new s.EventDispatcher(), this.lastMouseInteractionTimestamp = null, this.mouseEventsCounter = 0, this.eventCounters = {}, this.delegate = t, this.uiControlManager = e, this.wheelOptions = !!s._POSignalsUtils.Util.isPassiveSupported() && { passive: !0 }, this.onPointerHandle = this.onPointerEvent.bind(this), this.onClickHandle = this.onClick.bind(this), this.onDblclickHandle = this.onMouseClickEvent.bind(this), this.onMousedownHandle = this.onMouseClickEvent.bind(this), this.onMousemoveHandle = this.onMouseEvent.bind(this), this.onMouseoutHandle = this.onMouseout.bind(this), this.onMouseoverHandle = this.onMouseEvent.bind(this), this.onMouseupHandle = this.onMouseClickEvent.bind(this), this.onWheelHandle = this.onMouseEvent.bind(this), this.interactionUpdateHandle = this.interactionUpdate.bind(this);
      }
      return Object.defineProperty(r.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onInteraction", {
        get: function() {
          return this._onInteraction.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "onClickEvent", {
        get: function() {
          return this._onClickEvent.asEvent();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.countEvent = function(t) {
        this.eventCounters[t] = (this.eventCounters[t] || 0) + 1;
      }, r.prototype.interactionUpdate = function() {
        this.lastMouseInteraction ? (/* @__PURE__ */ new Date()).getTime() - this.lastMouseInteractionTimestamp >= s.PointerConfig.instance.pointerParams.mouseIdleTimeoutMillis && this.dispatch() : !this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE) && (/* @__PURE__ */ new Date()).getTime() - this.lastMouseInteractionTimestamp <= s.PointerConfig.instance.pointerParams.mouseIntervalMillis && this.dispatch();
      }, r.prototype.enrichLastInteraction = function() {
        var t;
        if (this.lastMouseInteraction) {
          this.lastMouseInteraction.eventCounters = this.eventCounters, this.lastMouseInteraction.duration = this.delegate.getInteractionDuration(
            this.lastMouseInteraction.events
          );
          var e = (t = this.lastMouseInteraction.events) === null || t === void 0 ? void 0 : t.filter(function(n) {
            return n.type === "mousemove";
          });
          this.lastMouseInteraction.timeProximity = s._POSignalsUtils.Util.calculateMeanTimeDeltasBetweenEvents(e), this.lastMouseInteraction.meanEuclidean = s._POSignalsUtils.Util.calculateMeanDistanceBetweenPoints(e);
        }
      }, r.prototype.dispatch = function() {
        try {
          this.enrichLastInteraction(), this._onInteraction.dispatch(this, this.lastMouseInteraction), this.eventCounters = {}, this.lastMouseInteraction = null, this.mouseEventsCounter = 0;
        } catch (t) {
          s._POSignalsUtils.Logger.warn("Failed to dispatch mouse events", t);
        }
      }, r.prototype.updateInteraction = function(t, e) {
        this.lastMouseInteraction || (this.lastMouseInteraction = {
          epochTs: (/* @__PURE__ */ new Date()).getTime(),
          events: [],
          counter: this.delegate.mouseCounter,
          additionalData: this.delegate.additionalData,
          eventCounters: {},
          duration: 0,
          timeProximity: 0,
          uiControl: void 0,
          meanEuclidean: 0,
          reduction: {}
        }), this.lastMouseInteraction.events.push(t), this.mouseEventsCounter++, e && (this.lastMouseInteraction.uiControl = {
          uiElement: e.uiElement,
          enrichedData: e.enrichedData
        }, this.delegate.addUiControlTags(e.tagConfig)), this.mouseEventsCounter >= s.PointerConfig.instance.pointerParams.maxMouseEvents && this.dispatch();
      }, r.prototype.start = function() {
        this._isStarted ? s._POSignalsUtils.Logger.debug("Desktop Mouse events already listening") : (this.delegate.addEventListener(document, "click", this.onClickHandle, !0), this.delegate.addEventListener(document, "dblclick", this.onDblclickHandle), this.delegate.addEventListener(document, "mousedown", this.onMousedownHandle), this.delegate.addEventListener(document, "mousemove", this.onMousemoveHandle), this.delegate.addEventListener(document, "mouseout", this.onMouseoutHandle), this.delegate.addEventListener(document, "mouseover", this.onMouseoverHandle), this.delegate.addEventListener(document, "mouseup", this.onMouseupHandle), this.delegate.addEventListener(
          document,
          "wheel",
          this.onWheelHandle,
          this.wheelOptions
        ), this.delegate.addEventListener(document, "pointerover", this.onPointerHandle), this.delegate.addEventListener(document, "pointerenter", this.onPointerHandle), this.delegate.addEventListener(document, "pointerdown", this.onPointerHandle), this.delegate.addEventListener(document, "pointermove", this.onPointerHandle), this.delegate.addEventListener(document, "pointerup", this.onPointerHandle), this.delegate.addEventListener(document, "pointercancel", this.onPointerHandle), this.delegate.addEventListener(document, "pointerout", this.onPointerHandle), this.delegate.addEventListener(document, "pointerleave", this.onPointerHandle), this.updateIntervalHandle = setInterval(
          this.interactionUpdateHandle,
          s.PointerConfig.instance.pointerParams.mouseIntervalMillis
        ), this._isStarted = !0, s._POSignalsUtils.Logger.debug("Desktop Mouse events start listening..."));
      }, r.prototype.stop = function() {
        this._isStarted ? (document.removeEventListener("click", this.onClickHandle, !0), document.removeEventListener("dblclick", this.onDblclickHandle), document.removeEventListener("mousedown", this.onMousedownHandle), document.removeEventListener("mousemove", this.onMousemoveHandle), document.removeEventListener("mouseout", this.onMouseoutHandle), document.removeEventListener("mouseover", this.onMouseoverHandle), document.removeEventListener("mouseup", this.onMouseupHandle), document.removeEventListener("wheel", this.onWheelHandle, this.wheelOptions), document.removeEventListener("pointerover", this.onPointerHandle), document.removeEventListener("pointerenter", this.onPointerHandle), document.removeEventListener("pointerdown", this.onPointerHandle), document.removeEventListener("pointermove", this.onPointerHandle), document.removeEventListener("pointerup", this.onPointerHandle), document.removeEventListener("pointercancel", this.onPointerHandle), document.removeEventListener("pointerout", this.onPointerHandle), document.removeEventListener("pointerleave", this.onPointerHandle), clearInterval(this.updateIntervalHandle), this.updateIntervalHandle = null, this._isStarted = !1, s._POSignalsUtils.Logger.debug("Desktop Mouse events stop listening...")) : s._POSignalsUtils.Logger.debug("Desktop Mouse events already stopped");
      }, r.prototype.onClick = function(t) {
        var e, n;
        try {
          this.lastMouseInteractionTimestamp = (/* @__PURE__ */ new Date()).getTime();
          var i = s._POSignalsUtils.Util.getSrcElement(t);
          if (this._onClickEvent.dispatch(this, i), !this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE) || (this.countEvent(t.type), s.PointerConfig.instance.pointerParams.eventsToIgnore.has(t.type)))
            return;
          var a = this.uiControlManager.createUIControlData(t);
          this.updateInteraction(this.createMouseClickEvent(t.type, t), a), this.dispatch(), ((n = (e = a == null ? void 0 : a.uiElement) === null || e === void 0 ? void 0 : e.id) === null || n === void 0 ? void 0 : n.length) > 0 && s._POSignalsUtils.Logger.info(
            "Tapped on element with id '" + a.uiElement.id + "'"
          );
        } catch (u) {
          s._POSignalsUtils.Logger.warn("error in " + t.type + " handler", u);
        }
      }, r.prototype.onMouseout = function(t) {
        try {
          this.onMouseEvent(t);
          var e = t.relatedTarget || t.toElement;
          e && e.nodeName !== "HTML" || this.dispatch();
        } catch (n) {
          s._POSignalsUtils.Logger.warn("error in " + t.type + " handler", n);
        }
      }, r.prototype.onMouseEvent = function(t) {
        try {
          if (t.type !== "wheel" && (this.lastMouseInteractionTimestamp = (/* @__PURE__ */ new Date()).getTime()), !this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE) || (this.countEvent(t.type), s.PointerConfig.instance.pointerParams.eventsToIgnore.has(t.type)))
            return;
          this.updateInteraction(this.createMouseEvent(t.type, t));
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in " + t.type + " handler", e);
        }
      }, r.prototype.onMouseClickEvent = function(t) {
        try {
          if (this.lastMouseInteractionTimestamp = (/* @__PURE__ */ new Date()).getTime(), !this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE) || (this.countEvent(t.type), s.PointerConfig.instance.pointerParams.eventsToIgnore.has(t.type)))
            return;
          this.updateInteraction(this.createMouseClickEvent(t.type, t));
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in " + t.type + " handler", e);
        }
      }, r.prototype.onPointerEvent = function(t) {
        try {
          if (this.lastMouseInteractionTimestamp = (/* @__PURE__ */ new Date()).getTime(), !this.delegate.collectBehavioralData(this.BEHAVIORAL_TYPE) || (this.countEvent(t.type), s.PointerConfig.instance.pointerParams.eventsToIgnore.has(t.type)))
            return;
          this.updateInteraction(this.createPointerEvent(t.type, t));
        } catch (e) {
          s._POSignalsUtils.Logger.warn("error in " + t.type + " handler", e);
        }
      }, r.prototype.clearBuffer = function() {
        var t = null;
        return this.lastMouseInteraction && (t = this.lastMouseInteraction), this.lastMouseInteraction = null, t;
      }, r.prototype.isEmpty = function() {
        return !this.lastMouseInteraction;
      }, r.prototype.createMouseEvent = function(t, e) {
        return {
          type: t,
          eventTs: e.timeStamp,
          epochTs: (/* @__PURE__ */ new Date()).getTime(),
          button: e.button,
          offsetX: e.offsetX,
          offsetY: e.offsetY,
          pageX: e.pageX,
          pageY: e.pageY,
          screenX: e.screenX,
          screenY: e.screenY,
          getX: function() {
            return e.screenX;
          },
          getY: function() {
            return e.screenY;
          }
        };
      }, r.prototype.createPointerEvent = function(t, e) {
        var n = this.createMouseEvent(t, e);
        return ve(ve({}, n), {
          pointerId: e.pointerId,
          width: e.width,
          height: e.height,
          pressure: e.pressure,
          tangentialPressure: e.tangentialPressure,
          tiltX: e.tiltX,
          tiltY: e.tiltY,
          twist: e.twist,
          pointerType: e.pointerType,
          isPrimary: e.isPrimary
        });
      }, r.prototype.createMouseClickEvent = function(t, e) {
        var n = this.createMouseEvent(t, e);
        if (e.target && s._POSignalsUtils.Util.isFunction(e.target.getBoundingClientRect)) {
          var i = e.target.getBoundingClientRect();
          n.targetBottom = i.bottom, n.targetHeight = i.height, n.targetLeft = i.left, n.targetRight = i.right, n.targetTop = i.top, n.targetWidth = i.width, n.targetX = i.x, n.targetY = i.y;
        }
        return n;
      }, r;
    }();
    s.Mouse = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.counter = 0, this.key = t, this.counter = this.loadFromStorage();
      }
      return r.prototype.loadFromStorage = function() {
        var t = r.sessionStorage.getItem(this.key);
        return Number(t) || 0;
      }, r.prototype.get = function() {
        return this.counter;
      }, r.prototype.increment = function(t) {
        t === void 0 && (t = 1), this.counter += t, r.sessionStorage.setItem(this.key, this.counter);
      }, r.prototype.decrement = function(t) {
        t === void 0 && (t = 1), this.increment(-1 * t);
      }, r.prototype.reset = function() {
        this.counter = 0, r.sessionStorage.removeItem(this.key);
      }, r.sessionStorage = s._POSignalsStorage.SessionStorage.instance.sessionStorage, r;
    }();
    s.StorageCounter = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.mapKey = t, this.cache = this.loadFromStorage();
      }
      return r.prototype.loadFromStorage = function() {
        var t = r.sessionStorage.getItem(this.mapKey);
        return t || (t = JSON.stringify({})), JSON.parse(t);
      }, r.prototype.asMap = function() {
        return this.cache;
      }, r.prototype.set = function(t, e, n) {
        n === void 0 && (n = !0), this.cache[t] = e, n && r.sessionStorage.setItem(this.mapKey, JSON.stringify(this.cache));
      }, r.prototype.sync = function() {
        r.sessionStorage.setItem(this.mapKey, JSON.stringify(this.cache));
      }, r.prototype.get = function(t) {
        return this.cache[t];
      }, r.prototype.delete = function(t) {
        delete this.cache[t], r.sessionStorage.setItem(this.mapKey, JSON.stringify(this.cache));
      }, r.prototype.values = function() {
        return s._POSignalsUtils.Util.values(this.cache);
      }, r.prototype.clear = function() {
        this.cache = {}, r.sessionStorage.removeItem(this.mapKey);
      }, r.sessionStorage = s._POSignalsStorage.SessionStorage.instance.sessionStorage, r;
    }();
    s.StorageMap = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
        this.config = {}, this._cacheHash = 0, this.cache = /* @__PURE__ */ new Map();
      }
      return r.prototype.refreshConfig = function(t) {
        try {
          if (!t)
            return;
          var e = s._POSignalsUtils.Util.hashCode(JSON.stringify(t));
          if (this._cacheHash === e)
            return;
          this.config = t, this._cacheHash = e, this.cache = /* @__PURE__ */ new Map();
        } catch (n) {
          s._POSignalsUtils.Logger.warn("Failed to set css selectors", n);
        }
      }, r.prototype.getMatchingTags = function(t, e) {
        var n = this.cache.get(t);
        if (n)
          return n;
        var i = {};
        for (var a in this.config)
          try {
            if (!this.config.hasOwnProperty(a))
              continue;
            var u = this.config[a].selector || [];
            s._POSignalsUtils.Util.isArray(u) || (u = [].concat(u));
            for (var c = 0, l = u; c < l.length; c++) {
              var d = l[c];
              s._POSignalsUtils.Util.isSelectorMatches(t, d, e) && (i[a] = this.config[a]);
            }
          } catch (p) {
            s._POSignalsUtils.Logger.warn("Failed to get the config for " + a + " tag", p);
          }
        return this.cache.set(t, i), i;
      }, r.prototype.getValue = function(t, e) {
        if (e && t)
          switch (e = e.trim(), t) {
            case "email_domain":
              return s._POSignalsUtils.Util.getEmailDomain(e);
            case "obfuscate":
              return "" + s._POSignalsUtils.Util.mod(e, 1e3);
            case "plain":
              return e;
            case "zip":
              return e.substr(0, 3);
            case "length":
              return "" + e.length;
          }
        return "";
      }, Object.defineProperty(r.prototype, "cacheHash", {
        get: function() {
          return this._cacheHash;
        },
        enumerable: !1,
        configurable: !0
      }), r;
    }();
    s.TagsIdentifications = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
        this._reduceFactorMap = null;
      }
      return Object.defineProperty(r.prototype, "reduceFactorMap", {
        get: function() {
          return this._reduceFactorMap;
        },
        set: function(t) {
          this._reduceFactorMap = t;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.reduceEventsByFactor = function(t) {
        var e = this;
        try {
          if (!t || t.length === 0 || !this.reduceFactorMap)
            return t;
          for (var n = /* @__PURE__ */ new Map(), i = [], a = 0; a < t.length; a++)
            n.get(t[a].type) ? n.get(t[a].type).push(a) : n.set(t[a].type, [a]);
          n.forEach(function(c, l) {
            var d = e.reduceFactorMap[l] ? Number(e.reduceFactorMap[l]) : 0;
            e.reduceByFactor(d, c, function(p) {
              i[c[p]] = !0;
            });
          });
          var u = [];
          for (a = 0; a < t.length; a++)
            i[a] && u.push(t[a]);
          return t.length !== u.length && s._POSignalsUtils.Logger.debug(
            t.length - u.length + " events reduced out of " + t.length
          ), u;
        } catch (c) {
          return s._POSignalsUtils.Logger.warn("Failed to reduce events", c), t;
        }
      }, r.prototype.reduceByFactor = function(t, e, n) {
        t = Math.min(t, 1);
        for (var i = Math.round(Math.max(e.length * (1 - t), 2)), a = (e.length - 1) / (i - 1), u = Math.min(e.length, i), c = 0; c < u; c++)
          n(Math.round(c * a));
      }, r;
    }();
    s.ReduceFactor = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.algorithm = t;
      }
      return r.prototype.reduce = function(t, e) {
        if (r.TYPES_TO_REDUCE.indexOf(e) === -1)
          return { keptEvents: t, epsilon: 0 };
        if (t.length <= r.MIN_EVENTS_TO_REDUCE)
          return { keptEvents: t, epsilon: 0 };
        var n = t.length < 50 ? 0.55 : t.length < 100 ? 0.35 : 0.2, i = t.length < 50 ? 1 : t.length < 100 ? 3 : 7, a = this.algorithm.reduceEvents(t, i), u = a.length / t.length;
        if (a.length >= 10 && u >= n)
          return { keptEvents: a, epsilon: i };
        var c = t.length < 50 ? 0.1 : t.length < 100 ? 0.3 : 0.7, l = this.algorithm.reduceEvents(t, c), d = l.length / t.length;
        if (l.length <= r.MIN_EVENTS_TO_REDUCE || d <= n)
          return { keptEvents: l, epsilon: c };
        var p = (Math.min(i, Math.pow(i, u / n)) * Math.abs(d - n) + c * Math.abs(u - n)) / Math.abs(u - d);
        return (p < c || p > i) && s._POSignalsUtils.Logger.warn(
          "linear weighted average - calculated epsilon is out of range, lowEpsilon: " + c + ", highEpsilon: " + i + ", epsilon: " + p
        ), { keptEvents: this.algorithm.reduceEvents(t, p), epsilon: p };
      }, r.MIN_EVENTS_TO_REDUCE = 18, r.TYPES_TO_REDUCE = ["mousemove", "touchmove"], r;
    }();
    s.RDPEpsilonStrategy = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r(t) {
        this.rdpStrategy = t;
      }
      return r.prototype.reduceWithRPD = function(t) {
        var e = this;
        if (!t || t.length === 0)
          return { events: t, reductionInfo: {} };
        for (var n = /* @__PURE__ */ new Map(), i = [], a = 0, u = t; a < u.length; a++) {
          var c = u[a];
          n.get(c.type) ? n.get(c.type).push(c) : n.set(c.type, [c]);
        }
        var l = {};
        return n.forEach(function(d, p) {
          var m = e.rdpStrategy.reduce(d, p), k = m.keptEvents, x = m.epsilon;
          x > 0 && (l[p] = { epsilon: x, originalLength: d.length, keptLength: k.length }), i = i.concat(k);
        }), { events: s._POSignalsUtils.Util.sortEventsByTimestamp(i), reductionInfo: l };
      }, r;
    }();
    s.ReduceRDP = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
      }
      return r.prototype.getSqDist = function(t, e) {
        var n = t.getX() - e.getX(), i = t.getY() - e.getY();
        return n * n + i * i;
      }, r.prototype.getSqSegDist = function(t, e, n) {
        var i = e.getX(), a = e.getY(), u = n.getX() - i, c = n.getY() - a;
        if (u !== 0 || c !== 0) {
          var l = ((t.getX() - i) * u + (t.getY() - a) * c) / (u * u + c * c);
          l > 1 ? (i = n.getX(), a = n.getY()) : l > 0 && (i += u * l, a += c * l);
        }
        return (u = t.getX() - i) * u + (c = t.getY() - a) * c;
      }, r.prototype.simplifyRadialDist = function(t, e) {
        for (var n, i = t[0], a = [i], u = 1, c = t.length; u < c; u++)
          n = t[u], this.getSqDist(n, i) > e && (a.push(n), i = n);
        return i !== n && a.push(n), a;
      }, r.prototype.simplifyDPStep = function(t, e, n, i, a) {
        for (var u, c = i, l = e + 1; l < n; l++) {
          var d = this.getSqSegDist(t[l], t[e], t[n]);
          d > c && (u = l, c = d);
        }
        c > i && (u - e > 1 && this.simplifyDPStep(t, e, u, i, a), a.push(t[u]), n - u > 1 && this.simplifyDPStep(t, u, n, i, a));
      }, r.prototype.simplifyDouglasPeucker = function(t, e) {
        var n = t.length - 1, i = [t[0]];
        return this.simplifyDPStep(t, 0, n, e, i), i.push(t[n]), i;
      }, r.prototype.simplify = function(t, e, n) {
        if (t.length <= 2)
          return t;
        var i = e !== void 0 ? e * e : 1;
        return t = n ? t : this.simplifyRadialDist(t, i), t = this.simplifyDouglasPeucker(t, i);
      }, r.prototype.reduceEvents = function(t, e) {
        return this.simplify(t, e);
      }, r;
    }();
    s.RDPReduction = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
      }
      return r.prototype.filterMoveEvents = function(t, e) {
        if (t.length <= 18)
          return t;
        for (var n = t.filter(function(d) {
          return d.type === e;
        }), i = s._POSignalsUtils.Util.keepFirstEventsWithDistance({
          events: n,
          threshold: 200,
          min: 18,
          max: 30
        }), a = -1, u = {}, c = 0; c < t.length; c++) {
          var l = t[c];
          l.type !== e && (l.type !== "mousedown" ? u[l.type] || (i.push(l), u[l.type] = !0) : a = c);
        }
        return a >= 0 && i.push(t[a]), s._POSignalsUtils.Util.sortEventsByTimestamp(i);
      }, r;
    }();
    s.EventsReduction = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
        this.reduceFactor = new s.ReduceFactor(), this.reduceRDP = new s.ReduceRDP(new s.RDPEpsilonStrategy(new s.RDPReduction())), this.eventsReduction = new s.EventsReduction();
      }
      return Object.defineProperty(r.prototype, "reduceFactorMap", {
        set: function(t) {
          this.reduceFactor.reduceFactorMap = t;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.reduceGesture = function(t) {
        var e = this.reduceRDP.reduceWithRPD(t.events);
        t.events = this.eventsReduction.filterMoveEvents(e.events, "touchmove"), t.reduction = e.reductionInfo;
      }, r.prototype.reduceKeyboardInteraction = function(t) {
        t.events = s._POSignalsUtils.Util.filterArrayByLength(t.events, 50);
      }, r.prototype.reduceMouseInteraction = function(t) {
        var e = this.reduceRDP.reduceWithRPD(t.events);
        t.events = this.eventsReduction.filterMoveEvents(e.events, "mousemove"), t.reduction = e.reductionInfo;
      }, r;
    }();
    s.ReductionManager = h;
  }(M || (M = {})), function(s) {
    var h = function(r) {
      function t(e, n) {
        var i = r.call(this, e) || this;
        return i.tagsWithValueIdentifications = new s.TagsIdentifications(), i.reductionManager = new s.ReductionManager(), i.lastGestureTimestamp = 0, i.currentBufferSize = 0, i.bufferingStrategy = s.StrategyFactory.createBufferingStrategy(n, i), i.capturedKeyboardInteractions = new s.StorageArray(
          s._POSignalsUtils.Constants.CAPTURED_KEYBOARD_INTERACTIONS
        ), i.keyboardInteractionsCount = new s.StorageCounter(
          s._POSignalsUtils.Constants.KEYBOARD_INTERACTIONS_COUNT
        ), i.mouseInteractionsCount = new s.StorageCounter(
          s._POSignalsUtils.Constants.MOUSE_INTERACTIONS_COUNT
        ), i.gesturesCount = new s.StorageCounter(s._POSignalsUtils.Constants.GESTURES_COUNT), i.eventCounters = new s.StorageMap(s._POSignalsUtils.Constants.EVENT_COUNTERS), i.capturedMouseInteractions = new s.StorageArray(
          s._POSignalsUtils.Constants.CAPTURED_MOUSE_INTERACTIONS
        ), i.capturedGestures = new s.StorageArray(
          s._POSignalsUtils.Constants.CAPTURED_GESTURES
        ), i.capturedIndirectEvents = new s.StorageArray(
          s._POSignalsUtils.Constants.CAPTURED_INDIRECT
        ), i.currentBufferSize = i.capturedGestures.length + i.capturedMouseInteractions.length + i.capturedKeyboardInteractions.length, i.uiControlManager = new s.UIControlManager(i), i.keyboard = new s.Keyboard(i, i.uiControlManager), i.keyboard.onInteraction.subscribe(i.handleKeyboardInteraction.bind(i)), i.keyboard.onEnterPress.subscribe(i.handleStTagOnEnter.bind(i)), i.keyboard.onObfuscatedValue.subscribe(i.handleTagValueOnBlur.bind(i)), i.mouse = new s.Mouse(i, i.uiControlManager), i.mouse.onInteraction.subscribe(i.handleMouseInteraction.bind(i)), i.mouse.onClickEvent.subscribe(i.handleStTagOnClick.bind(i)), i.sensors = new s.Sensors(i), i.gesture = new s.GestureEvents(i, i.sensors), i.gesture.onGesture.subscribe(i.handleGesture.bind(i)), i.indirect = new s.IndirectClient(i), i.indirect.onIndirect.subscribe(i.handleIndirect.bind(i)), i.onUrlChangeHandler = i.onUrlChange.bind(i), i.onEventHandler = i.onEvent.bind(i), i;
      }
      return _e(t, r), Object.defineProperty(t.prototype, "keyboardCounter", {
        get: function() {
          return this.keyboardInteractionsCount.get();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "mouseCounter", {
        get: function() {
          return this.mouseInteractionsCount.get();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "gesturesCounter", {
        get: function() {
          return this.gesturesCount.get();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(t.prototype, "additionalData", {
        get: function() {
          var e = s._POSignalsUtils.Util.getDeviceOrientation();
          return {
            locationHref: location.href,
            devTools: s._POSignalsUtils.Util.getDevToolsState(),
            innerWidth: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
            innerHeight: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight,
            outerWidth: window.outerWidth,
            outerHeight: window.outerHeight,
            width: screen.width,
            height: screen.height,
            availWidth: screen.availWidth,
            availHeight: screen.availHeight,
            pixelRatio: window.devicePixelRatio,
            deviceOrientation: e.orientation,
            deviceAngle: e.angle
          };
        },
        enumerable: !1,
        configurable: !0
      }), t.prototype.getBehavioralData = function() {
        return this.clearIndirectBuffer(), {
          mouse: {
            count: this.mouseInteractionsCount.get(),
            interactions: this.capturedMouseInteractions.get()
          },
          keyboard: {
            count: this.keyboardInteractionsCount.get(),
            interactions: this.capturedKeyboardInteractions.get()
          },
          touch: {
            count: this.gesturesCount.get(),
            interactions: this.capturedGestures.get()
          },
          indirect: { events: this.capturedIndirectEvents.get() },
          eventCounters: this.eventCounters.asMap()
        };
      }, t.prototype.getBufferSize = function() {
        return this.currentBufferSize;
      }, t.prototype.getInteractionDuration = function(e) {
        return (e == null ? void 0 : e.length) > 0 ? e[e.length - 1].epochTs - e[0].epochTs : 0;
      }, t.prototype.dispose = function() {
        return Z(this, void 0, void 0, function() {
          return $(this, function(e) {
            return this.stopListening(), this.keyboard.onInteraction.unsubscribe(
              this.handleKeyboardInteraction.bind(this)
            ), this.keyboard.onEnterPress.unsubscribe(this.handleStTagOnEnter.bind(this)), this.keyboard.onObfuscatedValue.unsubscribe(this.handleTagValueOnBlur.bind(this)), this.mouse.onInteraction.unsubscribe(this.handleMouseInteraction.bind(this)), this.mouse.onClickEvent.unsubscribe(this.handleStTagOnClick.bind(this)), this.gesture.onGesture.unsubscribe(this.handleGesture.bind(this)), this.indirect.unsubscribe(), this.indirect.onIndirect.unsubscribe(this.handleIndirect.bind(this)), [2];
          });
        });
      }, t.prototype.collectBehavioralData = function(e) {
        if (this.isBehavioralDataPaused)
          return !1;
        var n = s.PointerConfig.instance.pointerParams.behavioralBlacklist;
        return !(e && n && n[e]) || !window.location.href.match(n[e]);
      }, t.prototype.getElementsStID = function(e) {
        try {
          return s._POSignalsUtils.Util.getAttribute(e, "data-st-field") || this.keyboard.fieldsIdentifications.getIdentification(e, 0) || "";
        } catch (n) {
          return s._POSignalsUtils.Logger.warn("failed to get element stId", n), "";
        }
      }, t.prototype.addEventListener = function(e, n, i, a) {
        s.PointerConfig.instance.pointerParams.eventsBlackList.has(n) || (e.addEventListener(n, this.onEventHandler, a), e.addEventListener(n, i, a));
      }, t.prototype.addUiControlTags = function(e) {
        if ((e == null ? void 0 : e.length) > 0)
          for (var n = !1, i = 0, a = e; i < a.length; i++) {
            var u = a[i];
            try {
              if (u != null && u.name) {
                var c = this.uiControlManager.convertToTagValueConfig(u.value);
                n = this.addSingleTagWithValue(u.name, c) || n;
              }
            } catch (l) {
              s._POSignalsUtils.Logger.warn("failed to add tag config", l);
            }
          }
      }, t.prototype.refreshListening = function() {
        var e = s.PointerConfig.instance;
        this.tagsWithValueIdentifications.refreshConfig(e.pointerParams.remoteTags), this.reductionManager.reduceFactorMap = e.pointerParams.eventsReduceFactorMap, this.keyboard.refreshKeyboardCssSelectors(e.pointerParams.keyboardCssSelectors), this.sensors.maxSensorSamples = e.pointerParams.maxSensorSamples, this.sensors.sensorsTimestampDeltaInMillis = e.pointerParams.sensorsDeltaInMillis, this.mouse.start(), this.keyboard.start(), this.gesture.start(), this.indirect.start(), e.pointerParams.maxSensorSamples == 0 ? this.sensors.stop() : this.sensors.start(), this.addEventListener(window, "_onlocationchange", this.onUrlChangeHandler), this.addEventListener(window, "popstate", this.onUrlChangeHandler);
      }, t.prototype.addSingleTagWithValue = function(e, n) {
        try {
          if (n != null && n.context && !window.location.href.match(n.context))
            return !1;
          var i = "";
          if (n != null && n.operation && (n != null && n.valueSelector)) {
            var a = document.querySelector(n.valueSelector);
            if (a) {
              var u = s._POSignalsUtils.Util.getElementText(a);
              i = this.tagsWithValueIdentifications.getValue(n.operation, u);
            }
          }
          if (n != null && n.valueMandatory && !i)
            return s._POSignalsUtils.Logger.warn("tag '" + e + "' wasn't added. value is missing"), !1;
          this.addTag(e, i);
        } catch (c) {
          s._POSignalsUtils.Logger.warn("failed to add " + e + " tag", c);
        }
        return !1;
      }, t.prototype.addTagsWithValue = function(e) {
        var n = !1;
        for (var i in e)
          e.hasOwnProperty(i) && (n = this.addSingleTagWithValue(i, e[i]) || n);
      }, t.prototype.handleStTagOnEnter = function(e, n) {
        n instanceof HTMLInputElement && s._POSignalsUtils.Util.isTextInput(n) && this.handleStTagElement(n);
      }, t.prototype.handleTagValueOnBlur = function(e, n) {
        n && this.addTag(n.fieldKey, n.obfuscatedValue);
      }, t.prototype.handleStTagOnClick = function(e, n) {
        n instanceof HTMLInputElement && !s._POSignalsUtils.Util.isClickableInput(n) || this.handleStTagElement(n);
      }, t.prototype.handleMouseInteraction = function(e, n) {
        if (n) {
          this.mouseInteractionsCount.increment(), this.reductionManager.reduceMouseInteraction(n);
          var i = this.bufferingStrategy.calculateStrategyResult(n, "mouse");
          i.shouldCollect && (i.remove && this.removeInteraction(i.remove), this.capturedMouseInteractions.push(n), this.lastGestureTimestamp !== n.events[n.events.length - 1].eventTs && this.currentBufferSize++, this.eventCounters.sync());
        }
      }, t.prototype.handleIndirect = function(e, n) {
        this.addIndirectEvents(n), this.eventCounters.sync();
      }, t.prototype.handleKeyboardInteraction = function(e, n) {
        if (n) {
          this.keyboardInteractionsCount.increment(), this.reductionManager.reduceKeyboardInteraction(n);
          var i = this.bufferingStrategy.calculateStrategyResult(n, "keyboard");
          i.shouldCollect && (i.remove && this.removeInteraction(i.remove), this.capturedKeyboardInteractions.push(n), this.currentBufferSize++, this.eventCounters.sync());
        }
      }, t.prototype.handleGesture = function(e, n) {
        var i;
        if (this.isValidGesture(n)) {
          this.gesturesCount.increment(), this.reductionManager.reduceGesture(n);
          var a = this.bufferingStrategy.calculateStrategyResult(n, "touch");
          a.shouldCollect && (a.remove && this.removeInteraction(a.remove), this.sensors.onGesture(n), this.capturedGestures.push(n), this.currentBufferSize++, this.lastGestureTimestamp = (i = n.events[n.events.length - 1]) === null || i === void 0 ? void 0 : i.eventTs, this.eventCounters.sync());
        }
      }, t.prototype.clearIndirectBuffer = function() {
        var e = this.indirect.clearBuffer();
        this.addIndirectEvents(e);
      }, t.prototype.removeInteraction = function(e) {
        switch (e.type) {
          case "mouse":
            this.capturedMouseInteractions.remove(e.index);
            break;
          case "keyboard":
            this.capturedKeyboardInteractions.remove(e.index);
            break;
          case "touch":
            this.capturedGestures.remove(e.index);
        }
      }, t.prototype.addIndirectEvents = function(e) {
        var n;
        if (((n = e == null ? void 0 : e.events) === null || n === void 0 ? void 0 : n.length) > 0) {
          for (var i = [], a = s._POSignalsUtils.Util.typesCounter(this.capturedIndirectEvents.get()), u = 0, c = e.events; u < c.length; u++) {
            var l = c[u];
            s.PointerConfig.instance.pointerParams.highPriorityIndirectEvents.has(l.type) && this.capturedIndirectEvents.length + i.length < s.PointerConfig.instance.pointerParams.maxIndirectEvents && i.push(l), a[l.type] > 0 || (i.push(l), a[l.type] = 1);
          }
          this.capturedIndirectEvents.set(this.capturedIndirectEvents.concat(i));
        }
      }, t.prototype.onUrlChange = function() {
        this.addTag("location", window.location.href);
      }, t.prototype.onEvent = function(e) {
        this.isBehavioralDataPaused || this.eventCounters.set(e.type, (this.eventCounters.get(e.type) || 0) + 1, !1);
      }, t.prototype.handleStTagElement = function(e) {
        if (e) {
          var n = s.PointerConfig.instance.pointerParams.maxSelectorChildren, i = this.tagsWithValueIdentifications.getMatchingTags(e, n);
          this.addTagsWithValue(i);
          var a = s._POSignalsUtils.Util.isSelectorMatches(e, "[data-st-tag]", n);
          if (a instanceof Element) {
            var u = s._POSignalsUtils.Util.getAttribute(a, "data-st-tag"), c = s._POSignalsUtils.Util.getAttribute(a, "data-st-tag-value");
            u && this.addTag(u, c);
          }
        }
      }, t.prototype.stopListening = function() {
        this.keyboard.stop(), this.mouse.stop(), this.gesture.stop(), this.indirect.stop(), this.sensors.stop(), window.removeEventListener("_onlocationchange", this.onUrlChangeHandler), window.removeEventListener("popstate", this.onUrlChangeHandler);
      }, t.prototype.clearBehavioralData = function() {
        this.capturedKeyboardInteractions.clear(), this.capturedMouseInteractions.clear(), this.capturedGestures.clear(), this.capturedIndirectEvents.clear(), this.sensors.reset(), s.Tags.instance.reset(), this.currentBufferSize = 0, this.keyboardInteractionsCount.reset(), this.mouseInteractionsCount.reset(), this.gesturesCount.reset(), this.eventCounters.clear();
      }, t.prototype.isValidGesture = function(e) {
        var n, i;
        return ((n = e == null ? void 0 : e.events) === null || n === void 0 ? void 0 : n.length) > 0 && ((i = e == null ? void 0 : e.events) === null || i === void 0 ? void 0 : i.length) < s.PointerConfig.instance.pointerParams.maxSnapshotsCount;
      }, t;
    }(s.ClientBase);
    s.Client = h;
  }(M || (M = {}));
  var M, De = function() {
    function s() {
    }
    return s.getData = function() {
      return M.ClientBase.instance().getData();
    }, s.init = function(h) {
      return M._POSignalsUtils.Util.ieFix(), M.ClientBase.instance().startSignals(h);
    }, s.initSilent = function(h) {
      return this.init(h);
    }, s.pauseBehavioralData = function() {
      M.ClientBase.instance().pauseBehavioralData();
    }, s.resumeBehavioralData = function() {
      M.ClientBase.instance().resumeBehavioralData();
    }, s;
  }(), Ce = function(s) {
    document.readyState !== "loading" ? s() : document.addEventListener("DOMContentLoaded", s);
  };
  Ce(function() {
    if (!window._pingOneSignalsReady) {
      var s = new CustomEvent("PingOneSignalsReadyEvent");
      document.dispatchEvent(s), window._pingOneSignalsReady = !0;
    }
  }), function(s) {
    var h = function() {
      function r(t, e, n, i, a, u, c) {
        this.clientVersion = t, this.instanceUUID = e, this.initParams = n, this.metadata = i, this.behavioralDataHandler = a, this.externalIdentifiers = u, this.sessionStorage = c;
      }
      return r.prototype.getData = function(t) {
        return Z(this, void 0, void 0, function() {
          var e;
          return $(this, function(n) {
            switch (n.label) {
              case 0:
                return [4, this.getRiskData(t)];
              case 1:
                return e = n.sent(), [2, this.toString(e)];
            }
          });
        });
      }, r.prototype.getRiskData = function(t) {
        return Z(this, void 0, void 0, function() {
          var e, n;
          return $(this, function(i) {
            switch (i.label) {
              case 0:
                return n = {}, [4, this.metadata.getDeviceAttributes()];
              case 1:
                return n.deviceAttributes = i.sent(), n.behavioral = this.behavioralDataHandler.getBehavioralData(), n.tags = s.Tags.instance.tags, n.sdkConfig = this.initParams, n.epochTs = t, n.instanceUUID = this.instanceUUID, n.tabUUID = s._POSignalsStorage.SessionStorage.instance.tabUUID, n.origin = location.origin, n.href = location.href, n.sdkVersion = this.clientVersion, n.platform = "web", n.clientToken = window._pingOneSignalsToken, n.externalIdentifiers = this.externalIdentifiers, e = n, this.sessionStorage.deviceTrust && (e.deviceTrust = this.sessionStorage.deviceTrust), [2, e];
            }
          });
        });
      }, r.prototype.toString = function(t) {
        var e, n = this.metadata.getObfsInfo();
        try {
          e = s._POSignalsUtils.Util.string2buf(JSON.stringify(t));
        } catch (i) {
          throw new Error("Failed to create data, " + i.message);
        }
        try {
          e = s.pako.gzip(e);
        } catch (i) {
          throw new Error("Failed to compress data, " + i.message);
        }
        try {
          e = s._POSignalsUtils.Util.encryptionBytes(e, n.key);
        } catch (i) {
          throw new Error("failed to obfuscate data, " + i.message);
        }
        try {
          return s._POSignalsUtils.Util.base64Uint8Array(e) + "." + btoa(n.identifier);
        } catch (i) {
          throw new Error("failed to encode data, " + i.message);
        }
      }, r;
    }();
    s.DataHandler = h;
  }(M || (M = {})), function(s) {
    var h = function() {
      function r() {
        this._configuration = {
          enabled: r.ENABLED_DEFAULT,
          bufferSize: r.BUFFER_SIZE_DEFAULT,
          maxSnapshotsCount: r.MAX_SNAPSHOTS_COUNT_DEFAULT,
          sensors: r.SENSORS_DEFAULT,
          metadataBlacklist: r.METADATA_BLACK_LIST_DEFAULT,
          tagsBlacklistRegex: r.TAGS_BLACK_LIST_REGEX_DEFAULT,
          behavioralBlacklist: r.BEHAVIORAL_BLACK_LIST_DEFAULT,
          webRtcUrl: r.WEB_RTC_URL_DEFAULT,
          eventsBlackList: r.EVENTS_BLACK_LIST_DEFAULT,
          eventsToIgnore: r.EVENTS_TO_IGNORE_DEFAULT,
          highPriorityIndirectEvents: r.HIGH_PRIORITY_INDIRECT_EVENTS_DEFAULT,
          indirectIntervalMillis: r.INDIRECT_INTERVAL_MILLIS_DEFAULT,
          mouseIntervalMillis: r.MOUSE_INTERVAL_MILLIS_DEFAULT,
          mouseIdleTimeoutMillis: r.MOUSE_IDLE_TIMEOUT_MILLIS_DEFAULT,
          maxMouseEvents: r.MAX_MOUSE_EVENTS_DEFAULT,
          maxIndirectEvents: r.MAX_INDIRECT_EVENTS_DEFAULT,
          keyboardFieldBlackList: r.KEYBOARD_FIELD_BLACK_LIST_DEFAULT,
          keyboardCssSelectors: r.KEYBOARD_CSS_SELECTORS_DEFAULT,
          keyboardCssSelectorsBlacklist: r.KEYBOARD_CSS_SELECTORS_BLACKLIST_DEFAULT,
          keyboardIdentifierAttributes: r.KEYBOARD_IDENTIFIER_ATTRIBUTES_DEFAULT,
          remoteTags: r.REMOTE_TAGS_DEFAULT,
          maxSelectorChildren: r.MAX_SELECTOR_CHILDREN_DEFAULT,
          eventsReduceFactorMap: r.EVENTS_REDUCE_FACTOR_MAP_DEFAULT,
          propertyDescriptors: r.PROPERTY_DESCRIPTORS_DEFAULT,
          additionalMediaCodecs: r.ADDITIONAL_MEDIA_CODECS_DEFAULT,
          fingerprintTimeoutMillis: r.FINGER_PRINT_TIMEOUT_MILLIS_DEFAULT,
          metadataDataPoints: r.METADATA_DATA_POINTS_DEFAULT,
          uiModeling: r.UI_MODELING_CONFIG_DEFAULT,
          uiControl: r.UI_CONTROL_LIST_DEFAULT
        };
      }
      return r.prototype.updateParams = function(t) {
        t && (this._configuration = t);
      }, Object.defineProperty(r.prototype, "enabled", {
        get: function() {
          return typeof this._configuration.enabled == "boolean" ? this._configuration.enabled : r.ENABLED_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "bufferSize", {
        get: function() {
          return typeof this._configuration.bufferSize == "number" && this._configuration.bufferSize > 0 ? this._configuration.bufferSize : r.BUFFER_SIZE_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "maxSnapshotsCount", {
        get: function() {
          return typeof this._configuration.maxSnapshotsCount == "number" && this._configuration.maxSnapshotsCount >= 0 ? this._configuration.maxSnapshotsCount : r.MAX_SNAPSHOTS_COUNT_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "maxSensorSamples", {
        get: function() {
          var t = this._configuration.sensors;
          return t && typeof t.maxSensorSamples == "number" && t.maxSensorSamples >= 0 ? t.maxSensorSamples : r.SENSORS_DEFAULT.maxSensorSamples;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "sensorsDeltaInMillis", {
        get: function() {
          var t = this._configuration.sensors;
          return t && typeof t.sensorsDeltaInMillis == "number" && t.sensorsDeltaInMillis >= 0 ? t.sensorsDeltaInMillis : r.SENSORS_DEFAULT.sensorsDeltaInMillis;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "metadataBlackList", {
        get: function() {
          var t;
          return s._POSignalsUtils.Util.isArray(this._configuration.metadataBlacklist) && ((t = this._configuration.metadataBlacklist) === null || t === void 0 ? void 0 : t.length) > 0 ? this._configuration.metadataBlacklist : r.METADATA_BLACK_LIST_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "behavioralBlacklist", {
        get: function() {
          return this._configuration.behavioralBlacklist ? this._configuration.behavioralBlacklist : r.BEHAVIORAL_BLACK_LIST_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "tagsBlacklistRegex", {
        get: function() {
          return typeof this._configuration.tagsBlacklistRegex == "string" ? this._configuration.tagsBlacklistRegex : r.TAGS_BLACK_LIST_REGEX_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "webRtcUrl", {
        get: function() {
          return typeof this._configuration.webRtcUrl == "string" ? this._configuration.webRtcUrl : r.WEB_RTC_URL_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "eventsBlackList", {
        get: function() {
          return s._POSignalsUtils.Util.isArray(this._configuration.eventsBlackList) && (this._configuration.eventsBlackList = new Set(
            this._configuration.eventsBlackList
          )), this._configuration.eventsBlackList instanceof Set ? this._configuration.eventsBlackList : r.EVENTS_BLACK_LIST_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "eventsToIgnore", {
        get: function() {
          return s._POSignalsUtils.Util.isArray(this._configuration.eventsToIgnore) && (this._configuration.eventsToIgnore = new Set(
            this._configuration.eventsToIgnore
          )), this._configuration.eventsToIgnore instanceof Set ? this._configuration.eventsToIgnore : r.EVENTS_TO_IGNORE_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "highPriorityIndirectEvents", {
        get: function() {
          return s._POSignalsUtils.Util.isArray(this._configuration.highPriorityIndirectEvents) && (this._configuration.highPriorityIndirectEvents = new Set(
            this._configuration.highPriorityIndirectEvents
          )), this._configuration.highPriorityIndirectEvents instanceof Set ? this._configuration.highPriorityIndirectEvents : r.HIGH_PRIORITY_INDIRECT_EVENTS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "indirectIntervalMillis", {
        get: function() {
          return typeof this._configuration.indirectIntervalMillis == "number" && this._configuration.indirectIntervalMillis > 0 ? this._configuration.indirectIntervalMillis : r.INDIRECT_INTERVAL_MILLIS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "mouseIntervalMillis", {
        get: function() {
          return typeof this._configuration.mouseIntervalMillis == "number" && this._configuration.mouseIntervalMillis > 0 ? this._configuration.mouseIntervalMillis : r.MOUSE_INTERVAL_MILLIS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "mouseIdleTimeoutMillis", {
        get: function() {
          return typeof this._configuration.mouseIdleTimeoutMillis == "number" && this._configuration.mouseIdleTimeoutMillis > 0 ? this._configuration.mouseIdleTimeoutMillis : r.MOUSE_IDLE_TIMEOUT_MILLIS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "maxMouseEvents", {
        get: function() {
          return typeof this._configuration.maxMouseEvents == "number" && this._configuration.maxMouseEvents >= 0 ? this._configuration.maxMouseEvents : r.MAX_MOUSE_EVENTS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "maxIndirectEvents", {
        get: function() {
          return typeof this._configuration.maxIndirectEvents == "number" && this._configuration.maxIndirectEvents >= 0 ? this._configuration.maxIndirectEvents : r.MAX_INDIRECT_EVENTS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "keyboardFieldBlackList", {
        get: function() {
          return s._POSignalsUtils.Util.isArray(this._configuration.keyboardFieldBlackList) && (this._configuration.keyboardFieldBlackList = new Set(
            this._configuration.keyboardFieldBlackList
          )), this._configuration.keyboardFieldBlackList instanceof Set ? this._configuration.keyboardFieldBlackList : r.KEYBOARD_FIELD_BLACK_LIST_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "keyboardCssSelectors", {
        get: function() {
          return this._configuration.keyboardCssSelectors ? this._configuration.keyboardCssSelectors : r.KEYBOARD_CSS_SELECTORS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "keyboardCssSelectorsBlacklist", {
        get: function() {
          return s._POSignalsUtils.Util.isArray(
            this._configuration.keyboardCssSelectorsBlacklist
          ) ? this._configuration.keyboardCssSelectorsBlacklist : r.KEYBOARD_CSS_SELECTORS_BLACKLIST_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "keyboardIdentifierAttributes", {
        get: function() {
          return s._POSignalsUtils.Util.isArray(
            this._configuration.keyboardIdentifierAttributes
          ) ? this._configuration.keyboardIdentifierAttributes : r.KEYBOARD_IDENTIFIER_ATTRIBUTES_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "remoteTags", {
        get: function() {
          return this._configuration.remoteTags ? this._configuration.remoteTags : r.REMOTE_TAGS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "maxSelectorChildren", {
        get: function() {
          return typeof this._configuration.maxSelectorChildren == "number" && this._configuration.maxSelectorChildren > 0 ? this._configuration.maxSelectorChildren : r.MAX_SELECTOR_CHILDREN_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "eventsReduceFactorMap", {
        get: function() {
          return this._configuration.eventsReduceFactorMap ? this._configuration.eventsReduceFactorMap : r.EVENTS_REDUCE_FACTOR_MAP_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "propertyDescriptors", {
        get: function() {
          return this._configuration.propertyDescriptors ? this._configuration.propertyDescriptors : r.PROPERTY_DESCRIPTORS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "additionalMediaCodecs", {
        get: function() {
          return this._configuration.additionalMediaCodecs ? this._configuration.additionalMediaCodecs : r.ADDITIONAL_MEDIA_CODECS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "fingerprintTimeoutMillis", {
        get: function() {
          return typeof this._configuration.fingerprintTimeoutMillis == "number" && this._configuration.fingerprintTimeoutMillis > 0 ? this._configuration.fingerprintTimeoutMillis : r.FINGER_PRINT_TIMEOUT_MILLIS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "metadataDataPoints", {
        get: function() {
          return this._configuration.metadataDataPoints ? this._configuration.metadataDataPoints : r.METADATA_DATA_POINTS_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "uiModelingBlacklistRegex", {
        get: function() {
          var t;
          return typeof ((t = this._configuration.uiModeling) === null || t === void 0 ? void 0 : t.blacklistRegex) == "string" ? this._configuration.uiModeling.blacklistRegex : r.UI_MODELING_CONFIG_DEFAULT.blacklistRegex;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "uiModelingElementFilters", {
        get: function() {
          var t;
          return !((t = this._configuration.uiModeling) === null || t === void 0) && t.uiElementFilters ? this._configuration.uiModeling.uiElementFilters : r.UI_MODELING_CONFIG_DEFAULT.uiElementFilters;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "uiModelingMaxMatchingParents", {
        get: function() {
          var t;
          return typeof ((t = this._configuration.uiModeling) === null || t === void 0 ? void 0 : t.maxMatchingParents) == "number" ? this._configuration.uiModeling.maxMatchingParents : r.UI_MODELING_CONFIG_DEFAULT.maxMatchingParents;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "uiControlsConfig", {
        get: function() {
          return s._POSignalsUtils.Util.isArray(this._configuration.uiControl) ? this._configuration.uiControl : r.UI_CONTROL_LIST_DEFAULT;
        },
        enumerable: !1,
        configurable: !0
      }), r.ENABLED_DEFAULT = !0, r.BUFFER_SIZE_DEFAULT = 4, r.MAX_SNAPSHOTS_COUNT_DEFAULT = 500, r.METADATA_BLACK_LIST_DEFAULT = [], r.TAGS_BLACK_LIST_REGEX_DEFAULT = "", r.BEHAVIORAL_BLACK_LIST_DEFAULT = {}, r.WEB_RTC_URL_DEFAULT = "", r.EVENTS_BLACK_LIST_DEFAULT = /* @__PURE__ */ new Set(), r.EVENTS_TO_IGNORE_DEFAULT = /* @__PURE__ */ new Set([
        "pointerover",
        "pointerenter",
        "pointerdown",
        "pointermove",
        "pointerup",
        "pointercancel",
        "pointerout",
        "pointerleave",
        "dragstart",
        "dragexit",
        "drop",
        "dragend"
      ]), r.MAX_INDIRECT_EVENTS_DEFAULT = 15, r.HIGH_PRIORITY_INDIRECT_EVENTS_DEFAULT = /* @__PURE__ */ new Set([
        "copy",
        "cut",
        "paste",
        "resize",
        "orientationchange",
        "languagechange",
        "submit",
        "select"
      ]), r.INDIRECT_INTERVAL_MILLIS_DEFAULT = 1e3, r.MOUSE_INTERVAL_MILLIS_DEFAULT = 1e3, r.MOUSE_IDLE_TIMEOUT_MILLIS_DEFAULT = 1e3, r.MAX_MOUSE_EVENTS_DEFAULT = 500, r.KEYBOARD_FIELD_BLACK_LIST_DEFAULT = /* @__PURE__ */ new Set(), r.KEYBOARD_CSS_SELECTORS_DEFAULT = {}, r.KEYBOARD_CSS_SELECTORS_BLACKLIST_DEFAULT = [], r.KEYBOARD_IDENTIFIER_ATTRIBUTES_DEFAULT = [
        "data-selenium",
        "data-selenium-id",
        "data-testid",
        "data-test-id",
        "data-qa-id",
        "data-id",
        "id"
      ], r.REMOTE_TAGS_DEFAULT = {
        dv_form_submit: { selector: '[data-skbuttontype="form-submit"]' },
        login_attempt_email_domain: {
          selector: '[data-st-tag="login.login_attempt"]',
          operation: "email_domain",
          valueSelector: '[data-st-field="username"]',
          valueMandatory: !0
        },
        login_attempt_hash: {
          selector: '[data-st-tag="login.login_attempt"]',
          operation: "obfuscate",
          valueSelector: '[data-st-field="username"]',
          valueMandatory: !0
        },
        login_attempt_length: {
          selector: '[data-st-tag="login.login_attempt"]',
          operation: "length",
          valueSelector: '[data-st-field="username"]',
          valueMandatory: !0
        },
        registration_attempt_email_domain: {
          selector: '[data-st-tag="registration.registration_attempt"]',
          operation: "email_domain",
          valueSelector: '[data-st-field="username"]',
          valueMandatory: !0
        },
        registration_attempt_hash: {
          selector: '[data-st-tag="registration.registration_attempt"]',
          operation: "obfuscate",
          valueSelector: '[data-st-field="username"]',
          valueMandatory: !0
        },
        registration_attempt_length: {
          selector: '[data-st-tag="registration.registration_attempt"]',
          operation: "length",
          valueSelector: '[data-st-field="username"]',
          valueMandatory: !0
        }
      }, r.MAX_SELECTOR_CHILDREN_DEFAULT = 2, r.EVENTS_REDUCE_FACTOR_MAP_DEFAULT = {}, r.PROPERTY_DESCRIPTORS_DEFAULT = {
        chrome: ["app", "csi", "loadtimes", "runtime"],
        navigator: ["webdriver"],
        Navigator: ["languages", "hardwareConcurrency"],
        window: ["outerWidth", "outerHeight"],
        Screen: ["width", "height"]
      }, r.ADDITIONAL_MEDIA_CODECS_DEFAULT = {}, r.FINGER_PRINT_TIMEOUT_MILLIS_DEFAULT = 3e3, r.METADATA_DATA_POINTS_DEFAULT = {}, r.UI_CONTROL_LIST_DEFAULT = [], r.UI_MODELING_CONFIG_DEFAULT = {
        blacklistRegex: "",
        uiElementFilters: { text: { maxLength: 25 }, placeholder: { maxLength: 25 } },
        maxMatchingParents: 2
      }, r.SENSORS_DEFAULT = { maxSensorSamples: 1, sensorsDeltaInMillis: 0 }, r;
    }();
    s.PointerParams = h;
  }(M || (M = {})), window._POSignalsEntities = M, window._pingOneSignals = De;
}

var index3 = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var browser$1 = {};

// can-promise has a crash in some versions of react native that dont have
// standard global objects
// https://github.com/soldair/node-qrcode/issues/157

var canPromise$1 = function () {
  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
};

var qrcode = {};

var utils$1 = {};

let toSJISFunction;
const CODEWORDS_COUNT = [
  0, // Not used
  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
];

/**
 * Returns the QR Code size for the specified version
 *
 * @param  {Number} version QR Code version
 * @return {Number}         size of QR code
 */
utils$1.getSymbolSize = function getSymbolSize (version) {
  if (!version) throw new Error('"version" cannot be null or undefined')
  if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
  return version * 4 + 17
};

/**
 * Returns the total number of codewords used to store data and EC information.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Data length in bits
 */
utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {
  return CODEWORDS_COUNT[version]
};

/**
 * Encode data with Bose-Chaudhuri-Hocquenghem
 *
 * @param  {Number} data Value to encode
 * @return {Number}      Encoded value
 */
utils$1.getBCHDigit = function (data) {
  let digit = 0;

  while (data !== 0) {
    digit++;
    data >>>= 1;
  }

  return digit
};

utils$1.setToSJISFunction = function setToSJISFunction (f) {
  if (typeof f !== 'function') {
    throw new Error('"toSJISFunc" is not a valid function.')
  }

  toSJISFunction = f;
};

utils$1.isKanjiModeEnabled = function () {
  return typeof toSJISFunction !== 'undefined'
};

utils$1.toSJIS = function toSJIS (kanji) {
  return toSJISFunction(kanji)
};

var errorCorrectionLevel = {};

(function (exports) {
	exports.L = { bit: 1 };
	exports.M = { bit: 0 };
	exports.Q = { bit: 3 };
	exports.H = { bit: 2 };

	function fromString (string) {
	  if (typeof string !== 'string') {
	    throw new Error('Param is not a string')
	  }

	  const lcStr = string.toLowerCase();

	  switch (lcStr) {
	    case 'l':
	    case 'low':
	      return exports.L

	    case 'm':
	    case 'medium':
	      return exports.M

	    case 'q':
	    case 'quartile':
	      return exports.Q

	    case 'h':
	    case 'high':
	      return exports.H

	    default:
	      throw new Error('Unknown EC Level: ' + string)
	  }
	}

	exports.isValid = function isValid (level) {
	  return level && typeof level.bit !== 'undefined' &&
	    level.bit >= 0 && level.bit < 4
	};

	exports.from = function from (value, defaultValue) {
	  if (exports.isValid(value)) {
	    return value
	  }

	  try {
	    return fromString(value)
	  } catch (e) {
	    return defaultValue
	  }
	}; 
} (errorCorrectionLevel));

function BitBuffer$1 () {
  this.buffer = [];
  this.length = 0;
}

BitBuffer$1.prototype = {

  get: function (index) {
    const bufIndex = Math.floor(index / 8);
    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
  },

  put: function (num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit(((num >>> (length - i - 1)) & 1) === 1);
    }
  },

  getLengthInBits: function () {
    return this.length
  },

  putBit: function (bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }

    if (bit) {
      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
    }

    this.length++;
  }
};

var bitBuffer = BitBuffer$1;

/**
 * Helper class to handle QR Code symbol modules
 *
 * @param {Number} size Symbol size
 */

function BitMatrix$1 (size) {
  if (!size || size < 1) {
    throw new Error('BitMatrix size must be defined and greater than 0')
  }

  this.size = size;
  this.data = new Uint8Array(size * size);
  this.reservedBit = new Uint8Array(size * size);
}

/**
 * Set bit value at specified location
 * If reserved flag is set, this bit will be ignored during masking process
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 * @param {Boolean} reserved
 */
BitMatrix$1.prototype.set = function (row, col, value, reserved) {
  const index = row * this.size + col;
  this.data[index] = value;
  if (reserved) this.reservedBit[index] = true;
};

/**
 * Returns bit value at specified location
 *
 * @param  {Number}  row
 * @param  {Number}  col
 * @return {Boolean}
 */
BitMatrix$1.prototype.get = function (row, col) {
  return this.data[row * this.size + col]
};

/**
 * Applies xor operator at specified location
 * (used during masking process)
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 */
BitMatrix$1.prototype.xor = function (row, col, value) {
  this.data[row * this.size + col] ^= value;
};

/**
 * Check if bit at specified location is reserved
 *
 * @param {Number}   row
 * @param {Number}   col
 * @return {Boolean}
 */
BitMatrix$1.prototype.isReserved = function (row, col) {
  return this.reservedBit[row * this.size + col]
};

var bitMatrix = BitMatrix$1;

var alignmentPattern = {};

/**
 * Alignment pattern are fixed reference pattern in defined positions
 * in a matrix symbology, which enables the decode software to re-synchronise
 * the coordinate mapping of the image modules in the event of moderate amounts
 * of distortion of the image.
 *
 * Alignment patterns are present only in QR Code symbols of version 2 or larger
 * and their number depends on the symbol version.
 */

(function (exports) {
	const getSymbolSize = utils$1.getSymbolSize;

	/**
	 * Calculate the row/column coordinates of the center module of each alignment pattern
	 * for the specified QR Code version.
	 *
	 * The alignment patterns are positioned symmetrically on either side of the diagonal
	 * running from the top left corner of the symbol to the bottom right corner.
	 *
	 * Since positions are simmetrical only half of the coordinates are returned.
	 * Each item of the array will represent in turn the x and y coordinate.
	 * @see {@link getPositions}
	 *
	 * @param  {Number} version QR Code version
	 * @return {Array}          Array of coordinate
	 */
	exports.getRowColCoords = function getRowColCoords (version) {
	  if (version === 1) return []

	  const posCount = Math.floor(version / 7) + 2;
	  const size = getSymbolSize(version);
	  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
	  const positions = [size - 7]; // Last coord is always (size - 7)

	  for (let i = 1; i < posCount - 1; i++) {
	    positions[i] = positions[i - 1] - intervals;
	  }

	  positions.push(6); // First coord is always 6

	  return positions.reverse()
	};

	/**
	 * Returns an array containing the positions of each alignment pattern.
	 * Each array's element represent the center point of the pattern as (x, y) coordinates
	 *
	 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
	 * and filtering out the items that overlaps with finder pattern
	 *
	 * @example
	 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
	 * The alignment patterns, therefore, are to be centered on (row, column)
	 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
	 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
	 * and are not therefore used for alignment patterns.
	 *
	 * let pos = getPositions(7)
	 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
	 *
	 * @param  {Number} version QR Code version
	 * @return {Array}          Array of coordinates
	 */
	exports.getPositions = function getPositions (version) {
	  const coords = [];
	  const pos = exports.getRowColCoords(version);
	  const posLength = pos.length;

	  for (let i = 0; i < posLength; i++) {
	    for (let j = 0; j < posLength; j++) {
	      // Skip if position is occupied by finder patterns
	      if ((i === 0 && j === 0) || // top-left
	          (i === 0 && j === posLength - 1) || // bottom-left
	          (i === posLength - 1 && j === 0)) { // top-right
	        continue
	      }

	      coords.push([pos[i], pos[j]]);
	    }
	  }

	  return coords
	}; 
} (alignmentPattern));

var finderPattern = {};

const getSymbolSize = utils$1.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;

/**
 * Returns an array containing the positions of each finder pattern.
 * Each array's element represent the top-left point of the pattern as (x, y) coordinates
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
finderPattern.getPositions = function getPositions (version) {
  const size = getSymbolSize(version);

  return [
    // top-left
    [0, 0],
    // top-right
    [size - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size - FINDER_PATTERN_SIZE]
  ]
};

var maskPattern = {};

/**
 * Data mask pattern reference
 * @type {Object}
 */

(function (exports) {
	exports.Patterns = {
	  PATTERN000: 0,
	  PATTERN001: 1,
	  PATTERN010: 2,
	  PATTERN011: 3,
	  PATTERN100: 4,
	  PATTERN101: 5,
	  PATTERN110: 6,
	  PATTERN111: 7
	};

	/**
	 * Weighted penalty scores for the undesirable features
	 * @type {Object}
	 */
	const PenaltyScores = {
	  N1: 3,
	  N2: 3,
	  N3: 40,
	  N4: 10
	};

	/**
	 * Check if mask pattern value is valid
	 *
	 * @param  {Number}  mask    Mask pattern
	 * @return {Boolean}         true if valid, false otherwise
	 */
	exports.isValid = function isValid (mask) {
	  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
	};

	/**
	 * Returns mask pattern from a value.
	 * If value is not valid, returns undefined
	 *
	 * @param  {Number|String} value        Mask pattern value
	 * @return {Number}                     Valid mask pattern or undefined
	 */
	exports.from = function from (value) {
	  return exports.isValid(value) ? parseInt(value, 10) : undefined
	};

	/**
	* Find adjacent modules in row/column with the same color
	* and assign a penalty value.
	*
	* Points: N1 + i
	* i is the amount by which the number of adjacent modules of the same color exceeds 5
	*/
	exports.getPenaltyN1 = function getPenaltyN1 (data) {
	  const size = data.size;
	  let points = 0;
	  let sameCountCol = 0;
	  let sameCountRow = 0;
	  let lastCol = null;
	  let lastRow = null;

	  for (let row = 0; row < size; row++) {
	    sameCountCol = sameCountRow = 0;
	    lastCol = lastRow = null;

	    for (let col = 0; col < size; col++) {
	      let module = data.get(row, col);
	      if (module === lastCol) {
	        sameCountCol++;
	      } else {
	        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
	        lastCol = module;
	        sameCountCol = 1;
	      }

	      module = data.get(col, row);
	      if (module === lastRow) {
	        sameCountRow++;
	      } else {
	        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
	        lastRow = module;
	        sameCountRow = 1;
	      }
	    }

	    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
	    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
	  }

	  return points
	};

	/**
	 * Find 2x2 blocks with the same color and assign a penalty value
	 *
	 * Points: N2 * (m - 1) * (n - 1)
	 */
	exports.getPenaltyN2 = function getPenaltyN2 (data) {
	  const size = data.size;
	  let points = 0;

	  for (let row = 0; row < size - 1; row++) {
	    for (let col = 0; col < size - 1; col++) {
	      const last = data.get(row, col) +
	        data.get(row, col + 1) +
	        data.get(row + 1, col) +
	        data.get(row + 1, col + 1);

	      if (last === 4 || last === 0) points++;
	    }
	  }

	  return points * PenaltyScores.N2
	};

	/**
	 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
	 * preceded or followed by light area 4 modules wide
	 *
	 * Points: N3 * number of pattern found
	 */
	exports.getPenaltyN3 = function getPenaltyN3 (data) {
	  const size = data.size;
	  let points = 0;
	  let bitsCol = 0;
	  let bitsRow = 0;

	  for (let row = 0; row < size; row++) {
	    bitsCol = bitsRow = 0;
	    for (let col = 0; col < size; col++) {
	      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);
	      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;

	      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);
	      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
	    }
	  }

	  return points * PenaltyScores.N3
	};

	/**
	 * Calculate proportion of dark modules in entire symbol
	 *
	 * Points: N4 * k
	 *
	 * k is the rating of the deviation of the proportion of dark modules
	 * in the symbol from 50% in steps of 5%
	 */
	exports.getPenaltyN4 = function getPenaltyN4 (data) {
	  let darkCount = 0;
	  const modulesCount = data.data.length;

	  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];

	  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);

	  return k * PenaltyScores.N4
	};

	/**
	 * Return mask value at given position
	 *
	 * @param  {Number} maskPattern Pattern reference value
	 * @param  {Number} i           Row
	 * @param  {Number} j           Column
	 * @return {Boolean}            Mask value
	 */
	function getMaskAt (maskPattern, i, j) {
	  switch (maskPattern) {
	    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0
	    case exports.Patterns.PATTERN001: return i % 2 === 0
	    case exports.Patterns.PATTERN010: return j % 3 === 0
	    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0
	    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
	    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0
	    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0
	    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0

	    default: throw new Error('bad maskPattern:' + maskPattern)
	  }
	}

	/**
	 * Apply a mask pattern to a BitMatrix
	 *
	 * @param  {Number}    pattern Pattern reference number
	 * @param  {BitMatrix} data    BitMatrix data
	 */
	exports.applyMask = function applyMask (pattern, data) {
	  const size = data.size;

	  for (let col = 0; col < size; col++) {
	    for (let row = 0; row < size; row++) {
	      if (data.isReserved(row, col)) continue
	      data.xor(row, col, getMaskAt(pattern, row, col));
	    }
	  }
	};

	/**
	 * Returns the best mask pattern for data
	 *
	 * @param  {BitMatrix} data
	 * @return {Number} Mask pattern reference number
	 */
	exports.getBestMask = function getBestMask (data, setupFormatFunc) {
	  const numPatterns = Object.keys(exports.Patterns).length;
	  let bestPattern = 0;
	  let lowerPenalty = Infinity;

	  for (let p = 0; p < numPatterns; p++) {
	    setupFormatFunc(p);
	    exports.applyMask(p, data);

	    // Calculate penalty
	    const penalty =
	      exports.getPenaltyN1(data) +
	      exports.getPenaltyN2(data) +
	      exports.getPenaltyN3(data) +
	      exports.getPenaltyN4(data);

	    // Undo previously applied mask
	    exports.applyMask(p, data);

	    if (penalty < lowerPenalty) {
	      lowerPenalty = penalty;
	      bestPattern = p;
	    }
	  }

	  return bestPattern
	}; 
} (maskPattern));

var errorCorrectionCode = {};

const ECLevel$1 = errorCorrectionLevel;

const EC_BLOCKS_TABLE = [
// L  M  Q  H
  1, 1, 1, 1,
  1, 1, 1, 1,
  1, 1, 2, 2,
  1, 2, 2, 4,
  1, 2, 4, 4,
  2, 4, 4, 4,
  2, 4, 6, 5,
  2, 4, 6, 6,
  2, 5, 8, 8,
  4, 5, 8, 8,
  4, 5, 8, 11,
  4, 8, 10, 11,
  4, 9, 12, 16,
  4, 9, 16, 16,
  6, 10, 12, 18,
  6, 10, 17, 16,
  6, 11, 16, 19,
  6, 13, 18, 21,
  7, 14, 21, 25,
  8, 16, 20, 25,
  8, 17, 23, 25,
  9, 17, 23, 34,
  9, 18, 25, 30,
  10, 20, 27, 32,
  12, 21, 29, 35,
  12, 23, 34, 37,
  12, 25, 34, 40,
  13, 26, 35, 42,
  14, 28, 38, 45,
  15, 29, 40, 48,
  16, 31, 43, 51,
  17, 33, 45, 54,
  18, 35, 48, 57,
  19, 37, 51, 60,
  19, 38, 53, 63,
  20, 40, 56, 66,
  21, 43, 59, 70,
  22, 45, 62, 74,
  24, 47, 65, 77,
  25, 49, 68, 81
];

const EC_CODEWORDS_TABLE = [
// L  M  Q  H
  7, 10, 13, 17,
  10, 16, 22, 28,
  15, 26, 36, 44,
  20, 36, 52, 64,
  26, 48, 72, 88,
  36, 64, 96, 112,
  40, 72, 108, 130,
  48, 88, 132, 156,
  60, 110, 160, 192,
  72, 130, 192, 224,
  80, 150, 224, 264,
  96, 176, 260, 308,
  104, 198, 288, 352,
  120, 216, 320, 384,
  132, 240, 360, 432,
  144, 280, 408, 480,
  168, 308, 448, 532,
  180, 338, 504, 588,
  196, 364, 546, 650,
  224, 416, 600, 700,
  224, 442, 644, 750,
  252, 476, 690, 816,
  270, 504, 750, 900,
  300, 560, 810, 960,
  312, 588, 870, 1050,
  336, 644, 952, 1110,
  360, 700, 1020, 1200,
  390, 728, 1050, 1260,
  420, 784, 1140, 1350,
  450, 812, 1200, 1440,
  480, 868, 1290, 1530,
  510, 924, 1350, 1620,
  540, 980, 1440, 1710,
  570, 1036, 1530, 1800,
  570, 1064, 1590, 1890,
  600, 1120, 1680, 1980,
  630, 1204, 1770, 2100,
  660, 1260, 1860, 2220,
  720, 1316, 1950, 2310,
  750, 1372, 2040, 2430
];

/**
 * Returns the number of error correction block that the QR Code should contain
 * for the specified version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction blocks
 */
errorCorrectionCode.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
};

/**
 * Returns the number of error correction codewords to use for the specified
 * version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction codewords
 */
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
};

var polynomial = {};

var galoisField = {};

const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256)
/**
 * Precompute the log and anti-log tables for faster computation later
 *
 * For each possible value in the galois field 2^8, we will pre-compute
 * the logarithm and anti-logarithm (exponential) of this value
 *
 * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
 */
;(function initTables () {
  let x = 1;
  for (let i = 0; i < 255; i++) {
    EXP_TABLE[i] = x;
    LOG_TABLE[x] = i;

    x <<= 1; // multiply by 2

    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
    // This means that when a number is 256 or larger, it should be XORed with 0x11D.
    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
      x ^= 0x11D;
    }
  }

  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
  // stay inside the bounds (because we will mainly use this table for the multiplication of
  // two GF numbers, no more).
  // @see {@link mul}
  for (let i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255];
  }
}());

/**
 * Returns log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
galoisField.log = function log (n) {
  if (n < 1) throw new Error('log(' + n + ')')
  return LOG_TABLE[n]
};

/**
 * Returns anti-log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
galoisField.exp = function exp (n) {
  return EXP_TABLE[n]
};

/**
 * Multiplies two number inside Galois Field
 *
 * @param  {Number} x
 * @param  {Number} y
 * @return {Number}
 */
galoisField.mul = function mul (x, y) {
  if (x === 0 || y === 0) return 0

  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
  // @see {@link initTables}
  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
};

(function (exports) {
	const GF = galoisField;

	/**
	 * Multiplies two polynomials inside Galois Field
	 *
	 * @param  {Uint8Array} p1 Polynomial
	 * @param  {Uint8Array} p2 Polynomial
	 * @return {Uint8Array}    Product of p1 and p2
	 */
	exports.mul = function mul (p1, p2) {
	  const coeff = new Uint8Array(p1.length + p2.length - 1);

	  for (let i = 0; i < p1.length; i++) {
	    for (let j = 0; j < p2.length; j++) {
	      coeff[i + j] ^= GF.mul(p1[i], p2[j]);
	    }
	  }

	  return coeff
	};

	/**
	 * Calculate the remainder of polynomials division
	 *
	 * @param  {Uint8Array} divident Polynomial
	 * @param  {Uint8Array} divisor  Polynomial
	 * @return {Uint8Array}          Remainder
	 */
	exports.mod = function mod (divident, divisor) {
	  let result = new Uint8Array(divident);

	  while ((result.length - divisor.length) >= 0) {
	    const coeff = result[0];

	    for (let i = 0; i < divisor.length; i++) {
	      result[i] ^= GF.mul(divisor[i], coeff);
	    }

	    // remove all zeros from buffer head
	    let offset = 0;
	    while (offset < result.length && result[offset] === 0) offset++;
	    result = result.slice(offset);
	  }

	  return result
	};

	/**
	 * Generate an irreducible generator polynomial of specified degree
	 * (used by Reed-Solomon encoder)
	 *
	 * @param  {Number} degree Degree of the generator polynomial
	 * @return {Uint8Array}    Buffer containing polynomial coefficients
	 */
	exports.generateECPolynomial = function generateECPolynomial (degree) {
	  let poly = new Uint8Array([1]);
	  for (let i = 0; i < degree; i++) {
	    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
	  }

	  return poly
	}; 
} (polynomial));

const Polynomial = polynomial;

function ReedSolomonEncoder$1 (degree) {
  this.genPoly = undefined;
  this.degree = degree;

  if (this.degree) this.initialize(this.degree);
}

/**
 * Initialize the encoder.
 * The input param should correspond to the number of error correction codewords.
 *
 * @param  {Number} degree
 */
ReedSolomonEncoder$1.prototype.initialize = function initialize (degree) {
  // create an irreducible generator polynomial
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};

/**
 * Encodes a chunk of data
 *
 * @param  {Uint8Array} data Buffer containing input data
 * @return {Uint8Array}      Buffer containing encoded data
 */
ReedSolomonEncoder$1.prototype.encode = function encode (data) {
  if (!this.genPoly) {
    throw new Error('Encoder not initialized')
  }

  // Calculate EC for this data block
  // extends data size to data+genPoly size
  const paddedData = new Uint8Array(data.length + this.degree);
  paddedData.set(data);

  // The error correction codewords are the remainder after dividing the data codewords
  // by a generator polynomial
  const remainder = Polynomial.mod(paddedData, this.genPoly);

  // return EC data blocks (last n byte, where n is the degree of genPoly)
  // If coefficients number in remainder are less than genPoly degree,
  // pad with 0s to the left to reach the needed number of coefficients
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);

    return buff
  }

  return remainder
};

var reedSolomonEncoder = ReedSolomonEncoder$1;

var version = {};

var mode = {};

var versionCheck = {};

/**
 * Check if QR Code version is valid
 *
 * @param  {Number}  version QR Code version
 * @return {Boolean}         true if valid version, false otherwise
 */

versionCheck.isValid = function isValid (version) {
  return !isNaN(version) && version >= 1 && version <= 40
};

var regex = {};

const numeric = '[0-9]+';
const alphanumeric = '[A-Z $%*+\\-./:]+';
let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
kanji = kanji.replace(/u/g, '\\u');

const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';

regex.KANJI = new RegExp(kanji, 'g');
regex.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
regex.BYTE = new RegExp(byte, 'g');
regex.NUMERIC = new RegExp(numeric, 'g');
regex.ALPHANUMERIC = new RegExp(alphanumeric, 'g');

const TEST_KANJI = new RegExp('^' + kanji + '$');
const TEST_NUMERIC = new RegExp('^' + numeric + '$');
const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');

regex.testKanji = function testKanji (str) {
  return TEST_KANJI.test(str)
};

regex.testNumeric = function testNumeric (str) {
  return TEST_NUMERIC.test(str)
};

regex.testAlphanumeric = function testAlphanumeric (str) {
  return TEST_ALPHANUMERIC.test(str)
};

(function (exports) {
	const VersionCheck = versionCheck;
	const Regex = regex;

	/**
	 * Numeric mode encodes data from the decimal digit set (0 - 9)
	 * (byte values 30HEX to 39HEX).
	 * Normally, 3 data characters are represented by 10 bits.
	 *
	 * @type {Object}
	 */
	exports.NUMERIC = {
	  id: 'Numeric',
	  bit: 1 << 0,
	  ccBits: [10, 12, 14]
	};

	/**
	 * Alphanumeric mode encodes data from a set of 45 characters,
	 * i.e. 10 numeric digits (0 - 9),
	 *      26 alphabetic characters (A - Z),
	 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
	 * Normally, two input characters are represented by 11 bits.
	 *
	 * @type {Object}
	 */
	exports.ALPHANUMERIC = {
	  id: 'Alphanumeric',
	  bit: 1 << 1,
	  ccBits: [9, 11, 13]
	};

	/**
	 * In byte mode, data is encoded at 8 bits per character.
	 *
	 * @type {Object}
	 */
	exports.BYTE = {
	  id: 'Byte',
	  bit: 1 << 2,
	  ccBits: [8, 16, 16]
	};

	/**
	 * The Kanji mode efficiently encodes Kanji characters in accordance with
	 * the Shift JIS system based on JIS X 0208.
	 * The Shift JIS values are shifted from the JIS X 0208 values.
	 * JIS X 0208 gives details of the shift coded representation.
	 * Each two-byte character value is compacted to a 13-bit binary codeword.
	 *
	 * @type {Object}
	 */
	exports.KANJI = {
	  id: 'Kanji',
	  bit: 1 << 3,
	  ccBits: [8, 10, 12]
	};

	/**
	 * Mixed mode will contain a sequences of data in a combination of any of
	 * the modes described above
	 *
	 * @type {Object}
	 */
	exports.MIXED = {
	  bit: -1
	};

	/**
	 * Returns the number of bits needed to store the data length
	 * according to QR Code specifications.
	 *
	 * @param  {Mode}   mode    Data mode
	 * @param  {Number} version QR Code version
	 * @return {Number}         Number of bits
	 */
	exports.getCharCountIndicator = function getCharCountIndicator (mode, version) {
	  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

	  if (!VersionCheck.isValid(version)) {
	    throw new Error('Invalid version: ' + version)
	  }

	  if (version >= 1 && version < 10) return mode.ccBits[0]
	  else if (version < 27) return mode.ccBits[1]
	  return mode.ccBits[2]
	};

	/**
	 * Returns the most efficient mode to store the specified data
	 *
	 * @param  {String} dataStr Input data string
	 * @return {Mode}           Best mode
	 */
	exports.getBestModeForData = function getBestModeForData (dataStr) {
	  if (Regex.testNumeric(dataStr)) return exports.NUMERIC
	  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
	  else if (Regex.testKanji(dataStr)) return exports.KANJI
	  else return exports.BYTE
	};

	/**
	 * Return mode name as string
	 *
	 * @param {Mode} mode Mode object
	 * @returns {String}  Mode name
	 */
	exports.toString = function toString (mode) {
	  if (mode && mode.id) return mode.id
	  throw new Error('Invalid mode')
	};

	/**
	 * Check if input param is a valid mode object
	 *
	 * @param   {Mode}    mode Mode object
	 * @returns {Boolean} True if valid mode, false otherwise
	 */
	exports.isValid = function isValid (mode) {
	  return mode && mode.bit && mode.ccBits
	};

	/**
	 * Get mode object from its name
	 *
	 * @param   {String} string Mode name
	 * @returns {Mode}          Mode object
	 */
	function fromString (string) {
	  if (typeof string !== 'string') {
	    throw new Error('Param is not a string')
	  }

	  const lcStr = string.toLowerCase();

	  switch (lcStr) {
	    case 'numeric':
	      return exports.NUMERIC
	    case 'alphanumeric':
	      return exports.ALPHANUMERIC
	    case 'kanji':
	      return exports.KANJI
	    case 'byte':
	      return exports.BYTE
	    default:
	      throw new Error('Unknown mode: ' + string)
	  }
	}

	/**
	 * Returns mode from a value.
	 * If value is not a valid mode, returns defaultValue
	 *
	 * @param  {Mode|String} value        Encoding mode
	 * @param  {Mode}        defaultValue Fallback value
	 * @return {Mode}                     Encoding mode
	 */
	exports.from = function from (value, defaultValue) {
	  if (exports.isValid(value)) {
	    return value
	  }

	  try {
	    return fromString(value)
	  } catch (e) {
	    return defaultValue
	  }
	}; 
} (mode));

(function (exports) {
	const Utils = utils$1;
	const ECCode = errorCorrectionCode;
	const ECLevel = errorCorrectionLevel;
	const Mode = mode;
	const VersionCheck = versionCheck;

	// Generator polynomial used to encode version information
	const G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
	const G18_BCH = Utils.getBCHDigit(G18);

	function getBestVersionForDataLength (mode, length, errorCorrectionLevel) {
	  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
	    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
	      return currentVersion
	    }
	  }

	  return undefined
	}

	function getReservedBitsCount (mode, version) {
	  // Character count indicator + mode indicator bits
	  return Mode.getCharCountIndicator(mode, version) + 4
	}

	function getTotalBitsFromDataArray (segments, version) {
	  let totalBits = 0;

	  segments.forEach(function (data) {
	    const reservedBits = getReservedBitsCount(data.mode, version);
	    totalBits += reservedBits + data.getBitsLength();
	  });

	  return totalBits
	}

	function getBestVersionForMixedData (segments, errorCorrectionLevel) {
	  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
	    const length = getTotalBitsFromDataArray(segments, currentVersion);
	    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
	      return currentVersion
	    }
	  }

	  return undefined
	}

	/**
	 * Returns version number from a value.
	 * If value is not a valid version, returns defaultValue
	 *
	 * @param  {Number|String} value        QR Code version
	 * @param  {Number}        defaultValue Fallback value
	 * @return {Number}                     QR Code version number
	 */
	exports.from = function from (value, defaultValue) {
	  if (VersionCheck.isValid(value)) {
	    return parseInt(value, 10)
	  }

	  return defaultValue
	};

	/**
	 * Returns how much data can be stored with the specified QR code version
	 * and error correction level
	 *
	 * @param  {Number} version              QR Code version (1-40)
	 * @param  {Number} errorCorrectionLevel Error correction level
	 * @param  {Mode}   mode                 Data mode
	 * @return {Number}                      Quantity of storable data
	 */
	exports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {
	  if (!VersionCheck.isValid(version)) {
	    throw new Error('Invalid QR Code version')
	  }

	  // Use Byte mode as default
	  if (typeof mode === 'undefined') mode = Mode.BYTE;

	  // Total codewords for this QR code version (Data + Error correction)
	  const totalCodewords = Utils.getSymbolTotalCodewords(version);

	  // Total number of error correction codewords
	  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);

	  // Total number of data codewords
	  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

	  if (mode === Mode.MIXED) return dataTotalCodewordsBits

	  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);

	  // Return max number of storable codewords
	  switch (mode) {
	    case Mode.NUMERIC:
	      return Math.floor((usableBits / 10) * 3)

	    case Mode.ALPHANUMERIC:
	      return Math.floor((usableBits / 11) * 2)

	    case Mode.KANJI:
	      return Math.floor(usableBits / 13)

	    case Mode.BYTE:
	    default:
	      return Math.floor(usableBits / 8)
	  }
	};

	/**
	 * Returns the minimum version needed to contain the amount of data
	 *
	 * @param  {Segment} data                    Segment of data
	 * @param  {Number} [errorCorrectionLevel=H] Error correction level
	 * @param  {Mode} mode                       Data mode
	 * @return {Number}                          QR Code version
	 */
	exports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {
	  let seg;

	  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);

	  if (Array.isArray(data)) {
	    if (data.length > 1) {
	      return getBestVersionForMixedData(data, ecl)
	    }

	    if (data.length === 0) {
	      return 1
	    }

	    seg = data[0];
	  } else {
	    seg = data;
	  }

	  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
	};

	/**
	 * Returns version information with relative error correction bits
	 *
	 * The version information is included in QR Code symbols of version 7 or larger.
	 * It consists of an 18-bit sequence containing 6 data bits,
	 * with 12 error correction bits calculated using the (18, 6) Golay code.
	 *
	 * @param  {Number} version QR Code version
	 * @return {Number}         Encoded version info bits
	 */
	exports.getEncodedBits = function getEncodedBits (version) {
	  if (!VersionCheck.isValid(version) || version < 7) {
	    throw new Error('Invalid QR Code version')
	  }

	  let d = version << 12;

	  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
	    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH));
	  }

	  return (version << 12) | d
	}; 
} (version));

var formatInfo = {};

const Utils$3 = utils$1;

const G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
const G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
const G15_BCH = Utils$3.getBCHDigit(G15);

/**
 * Returns format information with relative error correction bits
 *
 * The format information is a 15-bit sequence containing 5 data bits,
 * with 10 error correction bits calculated using the (15, 5) BCH code.
 *
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Number} mask                 Mask pattern
 * @return {Number}                      Encoded format information bits
 */
formatInfo.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {
  const data = ((errorCorrectionLevel.bit << 3) | mask);
  let d = data << 10;

  while (Utils$3.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= (G15 << (Utils$3.getBCHDigit(d) - G15_BCH));
  }

  // xor final data with mask pattern in order to ensure that
  // no combination of Error Correction Level and data mask pattern
  // will result in an all-zero data string
  return ((data << 10) | d) ^ G15_MASK
};

var segments = {};

const Mode$4 = mode;

function NumericData (data) {
  this.mode = Mode$4.NUMERIC;
  this.data = data.toString();
}

NumericData.getBitsLength = function getBitsLength (length) {
  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
};

NumericData.prototype.getLength = function getLength () {
  return this.data.length
};

NumericData.prototype.getBitsLength = function getBitsLength () {
  return NumericData.getBitsLength(this.data.length)
};

NumericData.prototype.write = function write (bitBuffer) {
  let i, group, value;

  // The input data string is divided into groups of three digits,
  // and each group is converted to its 10-bit binary equivalent.
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3);
    value = parseInt(group, 10);

    bitBuffer.put(value, 10);
  }

  // If the number of input digits is not an exact multiple of three,
  // the final one or two digits are converted to 4 or 7 bits respectively.
  const remainingNum = this.data.length - i;
  if (remainingNum > 0) {
    group = this.data.substr(i);
    value = parseInt(group, 10);

    bitBuffer.put(value, remainingNum * 3 + 1);
  }
};

var numericData = NumericData;

const Mode$3 = mode;

/**
 * Array of characters available in alphanumeric mode
 *
 * As per QR Code specification, to each character
 * is assigned a value from 0 to 44 which in this case coincides
 * with the array index
 *
 * @type {Array}
 */
const ALPHA_NUM_CHARS = [
  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  ' ', '$', '%', '*', '+', '-', '.', '/', ':'
];

function AlphanumericData (data) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data;
}

AlphanumericData.getBitsLength = function getBitsLength (length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2)
};

AlphanumericData.prototype.getLength = function getLength () {
  return this.data.length
};

AlphanumericData.prototype.getBitsLength = function getBitsLength () {
  return AlphanumericData.getBitsLength(this.data.length)
};

AlphanumericData.prototype.write = function write (bitBuffer) {
  let i;

  // Input data characters are divided into groups of two characters
  // and encoded as 11-bit binary codes.
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    // The character value of the first character is multiplied by 45
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;

    // The character value of the second digit is added to the product
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);

    // The sum is then stored as 11-bit binary number
    bitBuffer.put(value, 11);
  }

  // If the number of input data characters is not a multiple of two,
  // the character value of the final character is encoded as a 6-bit binary number.
  if (this.data.length % 2) {
    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
  }
};

var alphanumericData = AlphanumericData;

var encodeUtf8$1 = function encodeUtf8 (input) {
  var result = [];
  var size = input.length;

  for (var index = 0; index < size; index++) {
    var point = input.charCodeAt(index);

    if (point >= 0xD800 && point <= 0xDBFF && size > index + 1) {
      var second = input.charCodeAt(index + 1);

      if (second >= 0xDC00 && second <= 0xDFFF) {
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        point = (point - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        index += 1;
      }
    }

    // US-ASCII
    if (point < 0x80) {
      result.push(point);
      continue
    }

    // 2-byte UTF-8
    if (point < 0x800) {
      result.push((point >> 6) | 192);
      result.push((point & 63) | 128);
      continue
    }

    // 3-byte UTF-8
    if (point < 0xD800 || (point >= 0xE000 && point < 0x10000)) {
      result.push((point >> 12) | 224);
      result.push(((point >> 6) & 63) | 128);
      result.push((point & 63) | 128);
      continue
    }

    // 4-byte UTF-8
    if (point >= 0x10000 && point <= 0x10FFFF) {
      result.push((point >> 18) | 240);
      result.push(((point >> 12) & 63) | 128);
      result.push(((point >> 6) & 63) | 128);
      result.push((point & 63) | 128);
      continue
    }

    // Invalid character
    result.push(0xEF, 0xBF, 0xBD);
  }

  return new Uint8Array(result).buffer
};

const encodeUtf8 = encodeUtf8$1;
const Mode$2 = mode;

function ByteData (data) {
  this.mode = Mode$2.BYTE;
  if (typeof (data) === 'string') {
    data = encodeUtf8(data);
  }
  this.data = new Uint8Array(data);
}

ByteData.getBitsLength = function getBitsLength (length) {
  return length * 8
};

ByteData.prototype.getLength = function getLength () {
  return this.data.length
};

ByteData.prototype.getBitsLength = function getBitsLength () {
  return ByteData.getBitsLength(this.data.length)
};

ByteData.prototype.write = function (bitBuffer) {
  for (let i = 0, l = this.data.length; i < l; i++) {
    bitBuffer.put(this.data[i], 8);
  }
};

var byteData = ByteData;

const Mode$1 = mode;
const Utils$2 = utils$1;

function KanjiData (data) {
  this.mode = Mode$1.KANJI;
  this.data = data;
}

KanjiData.getBitsLength = function getBitsLength (length) {
  return length * 13
};

KanjiData.prototype.getLength = function getLength () {
  return this.data.length
};

KanjiData.prototype.getBitsLength = function getBitsLength () {
  return KanjiData.getBitsLength(this.data.length)
};

KanjiData.prototype.write = function (bitBuffer) {
  let i;

  // In the Shift JIS system, Kanji characters are represented by a two byte combination.
  // These byte values are shifted from the JIS X 0208 values.
  // JIS X 0208 gives details of the shift coded representation.
  for (i = 0; i < this.data.length; i++) {
    let value = Utils$2.toSJIS(this.data[i]);

    // For characters with Shift JIS values from 0x8140 to 0x9FFC:
    if (value >= 0x8140 && value <= 0x9FFC) {
      // Subtract 0x8140 from Shift JIS value
      value -= 0x8140;

    // For characters with Shift JIS values from 0xE040 to 0xEBBF
    } else if (value >= 0xE040 && value <= 0xEBBF) {
      // Subtract 0xC140 from Shift JIS value
      value -= 0xC140;
    } else {
      throw new Error(
        'Invalid SJIS character: ' + this.data[i] + '\n' +
        'Make sure your charset is UTF-8')
    }

    // Multiply most significant byte of result by 0xC0
    // and add least significant byte to product
    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);

    // Convert result to a 13-bit binary string
    bitBuffer.put(value, 13);
  }
};

var kanjiData = KanjiData;

var dijkstra = {exports: {}};

(function (module) {

	/******************************************************************************
	 * Created 2008-08-19.
	 *
	 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
	 *
	 * Copyright (C) 2008
	 *   Wyatt Baldwin <self@wyattbaldwin.com>
	 *   All rights reserved
	 *
	 * Licensed under the MIT license.
	 *
	 *   http://www.opensource.org/licenses/mit-license.php
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *****************************************************************************/
	var dijkstra = {
	  single_source_shortest_paths: function(graph, s, d) {
	    // Predecessor map for each node that has been encountered.
	    // node ID => predecessor node ID
	    var predecessors = {};

	    // Costs of shortest paths from s to all nodes encountered.
	    // node ID => cost
	    var costs = {};
	    costs[s] = 0;

	    // Costs of shortest paths from s to all nodes encountered; differs from
	    // `costs` in that it provides easy access to the node that currently has
	    // the known shortest path from s.
	    // XXX: Do we actually need both `costs` and `open`?
	    var open = dijkstra.PriorityQueue.make();
	    open.push(s, 0);

	    var closest,
	        u, v,
	        cost_of_s_to_u,
	        adjacent_nodes,
	        cost_of_e,
	        cost_of_s_to_u_plus_cost_of_e,
	        cost_of_s_to_v,
	        first_visit;
	    while (!open.empty()) {
	      // In the nodes remaining in graph that have a known cost from s,
	      // find the node, u, that currently has the shortest path from s.
	      closest = open.pop();
	      u = closest.value;
	      cost_of_s_to_u = closest.cost;

	      // Get nodes adjacent to u...
	      adjacent_nodes = graph[u] || {};

	      // ...and explore the edges that connect u to those nodes, updating
	      // the cost of the shortest paths to any or all of those nodes as
	      // necessary. v is the node across the current edge from u.
	      for (v in adjacent_nodes) {
	        if (adjacent_nodes.hasOwnProperty(v)) {
	          // Get the cost of the edge running from u to v.
	          cost_of_e = adjacent_nodes[v];

	          // Cost of s to u plus the cost of u to v across e--this is *a*
	          // cost from s to v that may or may not be less than the current
	          // known cost to v.
	          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

	          // If we haven't visited v yet OR if the current known cost from s to
	          // v is greater than the new cost we just found (cost of s to u plus
	          // cost of u to v across e), update v's cost in the cost list and
	          // update v's predecessor in the predecessor list (it's now u).
	          cost_of_s_to_v = costs[v];
	          first_visit = (typeof costs[v] === 'undefined');
	          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
	            costs[v] = cost_of_s_to_u_plus_cost_of_e;
	            open.push(v, cost_of_s_to_u_plus_cost_of_e);
	            predecessors[v] = u;
	          }
	        }
	      }
	    }

	    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
	      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
	      throw new Error(msg);
	    }

	    return predecessors;
	  },

	  extract_shortest_path_from_predecessor_list: function(predecessors, d) {
	    var nodes = [];
	    var u = d;
	    while (u) {
	      nodes.push(u);
	      predecessors[u];
	      u = predecessors[u];
	    }
	    nodes.reverse();
	    return nodes;
	  },

	  find_path: function(graph, s, d) {
	    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
	    return dijkstra.extract_shortest_path_from_predecessor_list(
	      predecessors, d);
	  },

	  /**
	   * A very naive priority queue implementation.
	   */
	  PriorityQueue: {
	    make: function (opts) {
	      var T = dijkstra.PriorityQueue,
	          t = {},
	          key;
	      opts = opts || {};
	      for (key in T) {
	        if (T.hasOwnProperty(key)) {
	          t[key] = T[key];
	        }
	      }
	      t.queue = [];
	      t.sorter = opts.sorter || T.default_sorter;
	      return t;
	    },

	    default_sorter: function (a, b) {
	      return a.cost - b.cost;
	    },

	    /**
	     * Add a new item to the queue and ensure the highest priority element
	     * is at the front of the queue.
	     */
	    push: function (value, cost) {
	      var item = {value: value, cost: cost};
	      this.queue.push(item);
	      this.queue.sort(this.sorter);
	    },

	    /**
	     * Return the highest priority element in the queue.
	     */
	    pop: function () {
	      return this.queue.shift();
	    },

	    empty: function () {
	      return this.queue.length === 0;
	    }
	  }
	};


	// node.js module exports
	{
	  module.exports = dijkstra;
	} 
} (dijkstra));

var dijkstraExports = dijkstra.exports;

(function (exports) {
	const Mode = mode;
	const NumericData = numericData;
	const AlphanumericData = alphanumericData;
	const ByteData = byteData;
	const KanjiData = kanjiData;
	const Regex = regex;
	const Utils = utils$1;
	const dijkstra = dijkstraExports;

	/**
	 * Returns UTF8 byte length
	 *
	 * @param  {String} str Input string
	 * @return {Number}     Number of byte
	 */
	function getStringByteLength (str) {
	  return unescape(encodeURIComponent(str)).length
	}

	/**
	 * Get a list of segments of the specified mode
	 * from a string
	 *
	 * @param  {Mode}   mode Segment mode
	 * @param  {String} str  String to process
	 * @return {Array}       Array of object with segments data
	 */
	function getSegments (regex, mode, str) {
	  const segments = [];
	  let result;

	  while ((result = regex.exec(str)) !== null) {
	    segments.push({
	      data: result[0],
	      index: result.index,
	      mode: mode,
	      length: result[0].length
	    });
	  }

	  return segments
	}

	/**
	 * Extracts a series of segments with the appropriate
	 * modes from a string
	 *
	 * @param  {String} dataStr Input string
	 * @return {Array}          Array of object with segments data
	 */
	function getSegmentsFromString (dataStr) {
	  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
	  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
	  let byteSegs;
	  let kanjiSegs;

	  if (Utils.isKanjiModeEnabled()) {
	    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
	    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
	  } else {
	    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
	    kanjiSegs = [];
	  }

	  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);

	  return segs
	    .sort(function (s1, s2) {
	      return s1.index - s2.index
	    })
	    .map(function (obj) {
	      return {
	        data: obj.data,
	        mode: obj.mode,
	        length: obj.length
	      }
	    })
	}

	/**
	 * Returns how many bits are needed to encode a string of
	 * specified length with the specified mode
	 *
	 * @param  {Number} length String length
	 * @param  {Mode} mode     Segment mode
	 * @return {Number}        Bit length
	 */
	function getSegmentBitsLength (length, mode) {
	  switch (mode) {
	    case Mode.NUMERIC:
	      return NumericData.getBitsLength(length)
	    case Mode.ALPHANUMERIC:
	      return AlphanumericData.getBitsLength(length)
	    case Mode.KANJI:
	      return KanjiData.getBitsLength(length)
	    case Mode.BYTE:
	      return ByteData.getBitsLength(length)
	  }
	}

	/**
	 * Merges adjacent segments which have the same mode
	 *
	 * @param  {Array} segs Array of object with segments data
	 * @return {Array}      Array of object with segments data
	 */
	function mergeSegments (segs) {
	  return segs.reduce(function (acc, curr) {
	    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
	    if (prevSeg && prevSeg.mode === curr.mode) {
	      acc[acc.length - 1].data += curr.data;
	      return acc
	    }

	    acc.push(curr);
	    return acc
	  }, [])
	}

	/**
	 * Generates a list of all possible nodes combination which
	 * will be used to build a segments graph.
	 *
	 * Nodes are divided by groups. Each group will contain a list of all the modes
	 * in which is possible to encode the given text.
	 *
	 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
	 * The group for '12345' will contain then 3 objects, one for each
	 * possible encoding mode.
	 *
	 * Each node represents a possible segment.
	 *
	 * @param  {Array} segs Array of object with segments data
	 * @return {Array}      Array of object with segments data
	 */
	function buildNodes (segs) {
	  const nodes = [];
	  for (let i = 0; i < segs.length; i++) {
	    const seg = segs[i];

	    switch (seg.mode) {
	      case Mode.NUMERIC:
	        nodes.push([seg,
	          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
	          { data: seg.data, mode: Mode.BYTE, length: seg.length }
	        ]);
	        break
	      case Mode.ALPHANUMERIC:
	        nodes.push([seg,
	          { data: seg.data, mode: Mode.BYTE, length: seg.length }
	        ]);
	        break
	      case Mode.KANJI:
	        nodes.push([seg,
	          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
	        ]);
	        break
	      case Mode.BYTE:
	        nodes.push([
	          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
	        ]);
	    }
	  }

	  return nodes
	}

	/**
	 * Builds a graph from a list of nodes.
	 * All segments in each node group will be connected with all the segments of
	 * the next group and so on.
	 *
	 * At each connection will be assigned a weight depending on the
	 * segment's byte length.
	 *
	 * @param  {Array} nodes    Array of object with segments data
	 * @param  {Number} version QR Code version
	 * @return {Object}         Graph of all possible segments
	 */
	function buildGraph (nodes, version) {
	  const table = {};
	  const graph = { start: {} };
	  let prevNodeIds = ['start'];

	  for (let i = 0; i < nodes.length; i++) {
	    const nodeGroup = nodes[i];
	    const currentNodeIds = [];

	    for (let j = 0; j < nodeGroup.length; j++) {
	      const node = nodeGroup[j];
	      const key = '' + i + j;

	      currentNodeIds.push(key);
	      table[key] = { node: node, lastCount: 0 };
	      graph[key] = {};

	      for (let n = 0; n < prevNodeIds.length; n++) {
	        const prevNodeId = prevNodeIds[n];

	        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
	          graph[prevNodeId][key] =
	            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
	            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);

	          table[prevNodeId].lastCount += node.length;
	        } else {
	          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;

	          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
	            4 + Mode.getCharCountIndicator(node.mode, version); // switch cost
	        }
	      }
	    }

	    prevNodeIds = currentNodeIds;
	  }

	  for (let n = 0; n < prevNodeIds.length; n++) {
	    graph[prevNodeIds[n]].end = 0;
	  }

	  return { map: graph, table: table }
	}

	/**
	 * Builds a segment from a specified data and mode.
	 * If a mode is not specified, the more suitable will be used.
	 *
	 * @param  {String} data             Input data
	 * @param  {Mode | String} modesHint Data mode
	 * @return {Segment}                 Segment
	 */
	function buildSingleSegment (data, modesHint) {
	  let mode;
	  const bestMode = Mode.getBestModeForData(data);

	  mode = Mode.from(modesHint, bestMode);

	  // Make sure data can be encoded
	  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
	    throw new Error('"' + data + '"' +
	      ' cannot be encoded with mode ' + Mode.toString(mode) +
	      '.\n Suggested mode is: ' + Mode.toString(bestMode))
	  }

	  // Use Mode.BYTE if Kanji support is disabled
	  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
	    mode = Mode.BYTE;
	  }

	  switch (mode) {
	    case Mode.NUMERIC:
	      return new NumericData(data)

	    case Mode.ALPHANUMERIC:
	      return new AlphanumericData(data)

	    case Mode.KANJI:
	      return new KanjiData(data)

	    case Mode.BYTE:
	      return new ByteData(data)
	  }
	}

	/**
	 * Builds a list of segments from an array.
	 * Array can contain Strings or Objects with segment's info.
	 *
	 * For each item which is a string, will be generated a segment with the given
	 * string and the more appropriate encoding mode.
	 *
	 * For each item which is an object, will be generated a segment with the given
	 * data and mode.
	 * Objects must contain at least the property "data".
	 * If property "mode" is not present, the more suitable mode will be used.
	 *
	 * @param  {Array} array Array of objects with segments data
	 * @return {Array}       Array of Segments
	 */
	exports.fromArray = function fromArray (array) {
	  return array.reduce(function (acc, seg) {
	    if (typeof seg === 'string') {
	      acc.push(buildSingleSegment(seg, null));
	    } else if (seg.data) {
	      acc.push(buildSingleSegment(seg.data, seg.mode));
	    }

	    return acc
	  }, [])
	};

	/**
	 * Builds an optimized sequence of segments from a string,
	 * which will produce the shortest possible bitstream.
	 *
	 * @param  {String} data    Input string
	 * @param  {Number} version QR Code version
	 * @return {Array}          Array of segments
	 */
	exports.fromString = function fromString (data, version) {
	  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());

	  const nodes = buildNodes(segs);
	  const graph = buildGraph(nodes, version);
	  const path = dijkstra.find_path(graph.map, 'start', 'end');

	  const optimizedSegs = [];
	  for (let i = 1; i < path.length - 1; i++) {
	    optimizedSegs.push(graph.table[path[i]].node);
	  }

	  return exports.fromArray(mergeSegments(optimizedSegs))
	};

	/**
	 * Splits a string in various segments with the modes which
	 * best represent their content.
	 * The produced segments are far from being optimized.
	 * The output of this function is only used to estimate a QR Code version
	 * which may contain the data.
	 *
	 * @param  {string} data Input string
	 * @return {Array}       Array of segments
	 */
	exports.rawSplit = function rawSplit (data) {
	  return exports.fromArray(
	    getSegmentsFromString(data, Utils.isKanjiModeEnabled())
	  )
	}; 
} (segments));

const Utils$1 = utils$1;
const ECLevel = errorCorrectionLevel;
const BitBuffer = bitBuffer;
const BitMatrix = bitMatrix;
const AlignmentPattern = alignmentPattern;
const FinderPattern = finderPattern;
const MaskPattern = maskPattern;
const ECCode = errorCorrectionCode;
const ReedSolomonEncoder = reedSolomonEncoder;
const Version = version;
const FormatInfo = formatInfo;
const Mode = mode;
const Segments = segments;

/**
 * QRCode for JavaScript
 *
 * modified by Ryan Day for nodejs support
 * Copyright (c) 2011 Ryan Day
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
//---------------------------------------------------------------------
// QRCode for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//   http://www.opensource.org/licenses/mit-license.php
//
// The word "QR Code" is registered trademark of
// DENSO WAVE INCORPORATED
//   http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------
*/

/**
 * Add finder patterns bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupFinderPattern (matrix, version) {
  const size = matrix.size;
  const pos = FinderPattern.getPositions(version);

  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];

    for (let r = -1; r <= 7; r++) {
      if (row + r <= -1 || size <= row + r) continue

      for (let c = -1; c <= 7; c++) {
        if (col + c <= -1 || size <= col + c) continue

        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
          matrix.set(row + r, col + c, true, true);
        } else {
          matrix.set(row + r, col + c, false, true);
        }
      }
    }
  }
}

/**
 * Add timing pattern bits to matrix
 *
 * Note: this function must be called before {@link setupAlignmentPattern}
 *
 * @param  {BitMatrix} matrix Modules matrix
 */
function setupTimingPattern (matrix) {
  const size = matrix.size;

  for (let r = 8; r < size - 8; r++) {
    const value = r % 2 === 0;
    matrix.set(r, 6, value, true);
    matrix.set(6, r, value, true);
  }
}

/**
 * Add alignment patterns bits to matrix
 *
 * Note: this function must be called after {@link setupTimingPattern}
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupAlignmentPattern (matrix, version) {
  const pos = AlignmentPattern.getPositions(version);

  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];

    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        if (r === -2 || r === 2 || c === -2 || c === 2 ||
          (r === 0 && c === 0)) {
          matrix.set(row + r, col + c, true, true);
        } else {
          matrix.set(row + r, col + c, false, true);
        }
      }
    }
  }
}

/**
 * Add version info bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupVersionInfo (matrix, version) {
  const size = matrix.size;
  const bits = Version.getEncodedBits(version);
  let row, col, mod;

  for (let i = 0; i < 18; i++) {
    row = Math.floor(i / 3);
    col = i % 3 + size - 8 - 3;
    mod = ((bits >> i) & 1) === 1;

    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}

/**
 * Add format info bits to matrix
 *
 * @param  {BitMatrix} matrix               Modules matrix
 * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
 * @param  {Number}    maskPattern          Mask pattern reference value
 */
function setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {
  const size = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
  let i, mod;

  for (i = 0; i < 15; i++) {
    mod = ((bits >> i) & 1) === 1;

    // vertical
    if (i < 6) {
      matrix.set(i, 8, mod, true);
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true);
    } else {
      matrix.set(size - 15 + i, 8, mod, true);
    }

    // horizontal
    if (i < 8) {
      matrix.set(8, size - i - 1, mod, true);
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i - 1, mod, true);
    }
  }

  // fixed module
  matrix.set(size - 8, 8, 1, true);
}

/**
 * Add encoded data bits to matrix
 *
 * @param  {BitMatrix}  matrix Modules matrix
 * @param  {Uint8Array} data   Data codewords
 */
function setupData (matrix, data) {
  const size = matrix.size;
  let inc = -1;
  let row = size - 1;
  let bitIndex = 7;
  let byteIndex = 0;

  for (let col = size - 1; col > 0; col -= 2) {
    if (col === 6) col--;

    while (true) {
      for (let c = 0; c < 2; c++) {
        if (!matrix.isReserved(row, col - c)) {
          let dark = false;

          if (byteIndex < data.length) {
            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
          }

          matrix.set(row, col - c, dark);
          bitIndex--;

          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }

      row += inc;

      if (row < 0 || size <= row) {
        row -= inc;
        inc = -inc;
        break
      }
    }
  }
}

/**
 * Create encoded codewords from data input
 *
 * @param  {Number}   version              QR Code version
 * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
 * @param  {ByteData} data                 Data input
 * @return {Uint8Array}                    Buffer containing encoded codewords
 */
function createData (version, errorCorrectionLevel, segments) {
  // Prepare data buffer
  const buffer = new BitBuffer();

  segments.forEach(function (data) {
    // prefix data with mode indicator (4 bits)
    buffer.put(data.mode.bit, 4);

    // Prefix data with character count indicator.
    // The character count indicator is a string of bits that represents the
    // number of characters that are being encoded.
    // The character count indicator must be placed after the mode indicator
    // and must be a certain number of bits long, depending on the QR version
    // and data mode
    // @see {@link Mode.getCharCountIndicator}.
    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));

    // add binary data sequence to buffer
    data.write(buffer);
  });

  // Calculate required number of bits
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

  // Add a terminator.
  // If the bit string is shorter than the total number of required bits,
  // a terminator of up to four 0s must be added to the right side of the string.
  // If the bit string is more than four bits shorter than the required number of bits,
  // add four 0s to the end.
  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer.put(0, 4);
  }

  // If the bit string is fewer than four bits shorter, add only the number of 0s that
  // are needed to reach the required number of bits.

  // After adding the terminator, if the number of bits in the string is not a multiple of 8,
  // pad the string on the right with 0s to make the string's length a multiple of 8.
  while (buffer.getLengthInBits() % 8 !== 0) {
    buffer.putBit(0);
  }

  // Add pad bytes if the string is still shorter than the total number of required bits.
  // Extend the buffer to fill the data capacity of the symbol corresponding to
  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
  // and 00010001 (0x11) alternately.
  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
  for (let i = 0; i < remainingByte; i++) {
    buffer.put(i % 2 ? 0x11 : 0xEC, 8);
  }

  return createCodewords(buffer, version, errorCorrectionLevel)
}

/**
 * Encode input data with Reed-Solomon and return codewords with
 * relative error correction bits
 *
 * @param  {BitBuffer} bitBuffer            Data to encode
 * @param  {Number}    version              QR Code version
 * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
 * @return {Uint8Array}                     Buffer containing encoded codewords
 */
function createCodewords (bitBuffer, version, errorCorrectionLevel) {
  // Total codewords for this QR code version (Data + Error correction)
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version);

  // Total number of error correction codewords
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);

  // Total number of data codewords
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;

  // Total number of blocks
  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);

  // Calculate how many blocks each group should contain
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;

  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);

  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;

  // Number of EC codewords is the same for both groups
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;

  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
  const rs = new ReedSolomonEncoder(ecCount);

  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer = new Uint8Array(bitBuffer.buffer);

  // Divide the buffer into the required number of blocks
  for (let b = 0; b < ecTotalBlocks; b++) {
    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;

    // extract a block of data from buffer
    dcData[b] = buffer.slice(offset, offset + dataSize);

    // Calculate EC codewords for this data block
    ecData[b] = rs.encode(dcData[b]);

    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }

  // Create final data
  // Interleave the data and error correction codewords from each block
  const data = new Uint8Array(totalCodewords);
  let index = 0;
  let i, r;

  // Add data codewords
  for (i = 0; i < maxDataSize; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      if (i < dcData[r].length) {
        data[index++] = dcData[r][i];
      }
    }
  }

  // Apped EC codewords
  for (i = 0; i < ecCount; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      data[index++] = ecData[r][i];
    }
  }

  return data
}

/**
 * Build QR Code symbol
 *
 * @param  {String} data                 Input string
 * @param  {Number} version              QR Code version
 * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
 * @param  {MaskPattern} maskPattern     Mask pattern
 * @return {Object}                      Object containing symbol data
 */
function createSymbol (data, version, errorCorrectionLevel, maskPattern) {
  let segments;

  if (Array.isArray(data)) {
    segments = Segments.fromArray(data);
  } else if (typeof data === 'string') {
    let estimatedVersion = version;

    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data);

      // Estimate best version that can contain raw splitted segments
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
    }

    // Build optimized segments
    // If estimated version is undefined, try with the highest version
    segments = Segments.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error('Invalid data')
  }

  // Get the min version that can contain data
  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);

  // If no version is found, data cannot be stored
  if (!bestVersion) {
    throw new Error('The amount of data is too big to be stored in a QR Code')
  }

  // If not specified, use min version as default
  if (!version) {
    version = bestVersion;

  // Check if the specified version can contain the data
  } else if (version < bestVersion) {
    throw new Error('\n' +
      'The chosen QR Code version cannot contain this amount of data.\n' +
      'Minimum version required to store current data is: ' + bestVersion + '.\n'
    )
  }

  const dataBits = createData(version, errorCorrectionLevel, segments);

  // Allocate matrix buffer
  const moduleCount = Utils$1.getSymbolSize(version);
  const modules = new BitMatrix(moduleCount);

  // Add function modules
  setupFinderPattern(modules, version);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version);

  // Add temporary dummy bits for format info just to set them as reserved.
  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
  // since the masking operation must be performed only on the encoding region.
  // These blocks will be replaced with correct values later in code.
  setupFormatInfo(modules, errorCorrectionLevel, 0);

  if (version >= 7) {
    setupVersionInfo(modules, version);
  }

  // Add data codewords
  setupData(modules, dataBits);

  if (isNaN(maskPattern)) {
    // Find best mask pattern
    maskPattern = MaskPattern.getBestMask(modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel));
  }

  // Apply mask pattern
  MaskPattern.applyMask(maskPattern, modules);

  // Replace format info bits with correct values
  setupFormatInfo(modules, errorCorrectionLevel, maskPattern);

  return {
    modules: modules,
    version: version,
    errorCorrectionLevel: errorCorrectionLevel,
    maskPattern: maskPattern,
    segments: segments
  }
}

/**
 * QR Code
 *
 * @param {String | Array} data                 Input data
 * @param {Object} options                      Optional configurations
 * @param {Number} options.version              QR Code version
 * @param {String} options.errorCorrectionLevel Error correction level
 * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
 */
qrcode.create = function create (data, options) {
  if (typeof data === 'undefined' || data === '') {
    throw new Error('No input text')
  }

  let errorCorrectionLevel = ECLevel.M;
  let version;
  let mask;

  if (typeof options !== 'undefined') {
    // Use higher error correction level as default
    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version = Version.from(options.version);
    mask = MaskPattern.from(options.maskPattern);

    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }

  return createSymbol(data, version, errorCorrectionLevel, mask)
};

var canvas = {};

var utils = {};

(function (exports) {
	function hex2rgba (hex) {
	  if (typeof hex === 'number') {
	    hex = hex.toString();
	  }

	  if (typeof hex !== 'string') {
	    throw new Error('Color should be defined as hex string')
	  }

	  let hexCode = hex.slice().replace('#', '').split('');
	  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
	    throw new Error('Invalid hex color: ' + hex)
	  }

	  // Convert from short to long form (fff -> ffffff)
	  if (hexCode.length === 3 || hexCode.length === 4) {
	    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
	      return [c, c]
	    }));
	  }

	  // Add default alpha value
	  if (hexCode.length === 6) hexCode.push('F', 'F');

	  const hexValue = parseInt(hexCode.join(''), 16);

	  return {
	    r: (hexValue >> 24) & 255,
	    g: (hexValue >> 16) & 255,
	    b: (hexValue >> 8) & 255,
	    a: hexValue & 255,
	    hex: '#' + hexCode.slice(0, 6).join('')
	  }
	}

	exports.getOptions = function getOptions (options) {
	  if (!options) options = {};
	  if (!options.color) options.color = {};

	  const margin = typeof options.margin === 'undefined' ||
	    options.margin === null ||
	    options.margin < 0
	    ? 4
	    : options.margin;

	  const width = options.width && options.width >= 21 ? options.width : undefined;
	  const scale = options.scale || 4;

	  return {
	    width: width,
	    scale: width ? 4 : scale,
	    margin: margin,
	    color: {
	      dark: hex2rgba(options.color.dark || '#000000ff'),
	      light: hex2rgba(options.color.light || '#ffffffff')
	    },
	    type: options.type,
	    rendererOpts: options.rendererOpts || {}
	  }
	};

	exports.getScale = function getScale (qrSize, opts) {
	  return opts.width && opts.width >= qrSize + opts.margin * 2
	    ? opts.width / (qrSize + opts.margin * 2)
	    : opts.scale
	};

	exports.getImageWidth = function getImageWidth (qrSize, opts) {
	  const scale = exports.getScale(qrSize, opts);
	  return Math.floor((qrSize + opts.margin * 2) * scale)
	};

	exports.qrToImageData = function qrToImageData (imgData, qr, opts) {
	  const size = qr.modules.size;
	  const data = qr.modules.data;
	  const scale = exports.getScale(size, opts);
	  const symbolSize = Math.floor((size + opts.margin * 2) * scale);
	  const scaledMargin = opts.margin * scale;
	  const palette = [opts.color.light, opts.color.dark];

	  for (let i = 0; i < symbolSize; i++) {
	    for (let j = 0; j < symbolSize; j++) {
	      let posDst = (i * symbolSize + j) * 4;
	      let pxColor = opts.color.light;

	      if (i >= scaledMargin && j >= scaledMargin &&
	        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
	        const iSrc = Math.floor((i - scaledMargin) / scale);
	        const jSrc = Math.floor((j - scaledMargin) / scale);
	        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
	      }

	      imgData[posDst++] = pxColor.r;
	      imgData[posDst++] = pxColor.g;
	      imgData[posDst++] = pxColor.b;
	      imgData[posDst] = pxColor.a;
	    }
	  }
	}; 
} (utils));

(function (exports) {
	const Utils = utils;

	function clearCanvas (ctx, canvas, size) {
	  ctx.clearRect(0, 0, canvas.width, canvas.height);

	  if (!canvas.style) canvas.style = {};
	  canvas.height = size;
	  canvas.width = size;
	  canvas.style.height = size + 'px';
	  canvas.style.width = size + 'px';
	}

	function getCanvasElement () {
	  try {
	    return document.createElement('canvas')
	  } catch (e) {
	    throw new Error('You need to specify a canvas element')
	  }
	}

	exports.render = function render (qrData, canvas, options) {
	  let opts = options;
	  let canvasEl = canvas;

	  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
	    opts = canvas;
	    canvas = undefined;
	  }

	  if (!canvas) {
	    canvasEl = getCanvasElement();
	  }

	  opts = Utils.getOptions(opts);
	  const size = Utils.getImageWidth(qrData.modules.size, opts);

	  const ctx = canvasEl.getContext('2d');
	  const image = ctx.createImageData(size, size);
	  Utils.qrToImageData(image.data, qrData, opts);

	  clearCanvas(ctx, canvasEl, size);
	  ctx.putImageData(image, 0, 0);

	  return canvasEl
	};

	exports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {
	  let opts = options;

	  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
	    opts = canvas;
	    canvas = undefined;
	  }

	  if (!opts) opts = {};

	  const canvasEl = exports.render(qrData, canvas, opts);

	  const type = opts.type || 'image/png';
	  const rendererOpts = opts.rendererOpts || {};

	  return canvasEl.toDataURL(type, rendererOpts.quality)
	}; 
} (canvas));

var svgTag = {};

const Utils = utils;

function getColorAttrib (color, attrib) {
  const alpha = color.a / 255;
  const str = attrib + '="' + color.hex + '"';

  return alpha < 1
    ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
    : str
}

function svgCmd (cmd, x, y) {
  let str = cmd + x;
  if (typeof y !== 'undefined') str += ' ' + y;

  return str
}

function qrToPath (data, size, margin) {
  let path = '';
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;

  for (let i = 0; i < data.length; i++) {
    const col = Math.floor(i % size);
    const row = Math.floor(i / size);

    if (!col && !newRow) newRow = true;

    if (data[i]) {
      lineLength++;

      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow
          ? svgCmd('M', col + margin, 0.5 + row + margin)
          : svgCmd('m', moveBy, 0);

        moveBy = 0;
        newRow = false;
      }

      if (!(col + 1 < size && data[i + 1])) {
        path += svgCmd('h', lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }

  return path
}

svgTag.render = function render (qrData, options, cb) {
  const opts = Utils.getOptions(options);
  const size = qrData.modules.size;
  const data = qrData.modules.data;
  const qrcodesize = size + opts.margin * 2;

  const bg = !opts.color.light.a
    ? ''
    : '<path ' + getColorAttrib(opts.color.light, 'fill') +
      ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';

  const path =
    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
    ' d="' + qrToPath(data, size, opts.margin) + '"/>';

  const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';

  const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';

  const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';

  if (typeof cb === 'function') {
    cb(null, svgTag);
  }

  return svgTag
};

const canPromise = canPromise$1;

const QRCode = qrcode;
const CanvasRenderer = canvas;
const SvgRenderer = svgTag;

function renderCanvas (renderFunc, canvas, text, opts, cb) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === 'function';

  if (!isLastArgCb && !canPromise()) {
    throw new Error('Callback required as last argument')
  }

  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 2) {
      cb = text;
      text = canvas;
      canvas = opts = undefined;
    } else if (argsNum === 3) {
      if (canvas.getContext && typeof cb === 'undefined') {
        cb = opts;
        opts = undefined;
      } else {
        cb = opts;
        opts = text;
        text = canvas;
        canvas = undefined;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 1) {
      text = canvas;
      canvas = opts = undefined;
    } else if (argsNum === 2 && !canvas.getContext) {
      opts = text;
      text = canvas;
      canvas = undefined;
    }

    return new Promise(function (resolve, reject) {
      try {
        const data = QRCode.create(text, opts);
        resolve(renderFunc(data, canvas, opts));
      } catch (e) {
        reject(e);
      }
    })
  }

  try {
    const data = QRCode.create(text, opts);
    cb(null, renderFunc(data, canvas, opts));
  } catch (e) {
    cb(e);
  }
}

var create = browser$1.create = QRCode.create;
var toCanvas = browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
var toDataURL = browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);

// only svg for now.
var toString = browser$1.toString = renderCanvas.bind(null, function (data, _, opts) {
  return SvgRenderer.render(data, opts)
});

var browser = /*#__PURE__*/_mergeNamespaces({
    __proto__: null,
    create: create,
    default: browser$1,
    toCanvas: toCanvas,
    toDataURL: toDataURL,
    toString: toString
}, [browser$1]);

export { component, configuration, Widget as default, journey, protect, request, user };
//# sourceMappingURL=index.js.map
